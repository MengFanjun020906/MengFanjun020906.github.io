{"meta":{"title":"MengFanjun的博客","subtitle":"","description":"20级通信工程大学生的个人博客","author":"MengFanjun","url":"https://mengfanjun020906.github.io","root":"/"},"pages":[{"title":"","date":"2024-08-13T15:16:04.905Z","updated":"2024-08-13T15:16:04.888Z","comments":true,"path":"about/index.html","permalink":"https://mengfanjun020906.github.io/about/index.html","excerpt":"","text":"关于我 北京电子信息研究生在读 这是我的Github，里面大部分是我学习时候做的一些小项目，嵌入式的相对多一点，也有一部分MATLAB和Python的项目 我的邮箱，大家有什么问题可以与我联系 这些仓库和博客也可以说是我大学路上的见证者 持续创作，持续输出，做一个终身学习者"},{"title":"所有分类","date":"2023-02-25T09:09:48.702Z","updated":"2023-02-25T09:09:47.938Z","comments":true,"path":"categories/index.html","permalink":"https://mengfanjun020906.github.io/categories/index.html","excerpt":"","text":"没有你想看的东西？🤥 立刻发邮件告诉我(不一定会写，但是一定会出现)😜"},{"title":"charts","date":"2023-03-04T14:13:01.000Z","updated":"2023-03-04T14:13:01.093Z","comments":true,"path":"charts/index.html","permalink":"https://mengfanjun020906.github.io/charts/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-08-25T13:40:24.976Z","updated":"2023-03-10T06:09:43.449Z","comments":true,"path":"friends/index.html","permalink":"https://mengfanjun020906.github.io/friends/index.html","excerpt":"","text":"都是大佬啊！🥳 一起互换友链吧😃，快快联系我"},{"title":"所有标签","date":"2024-02-29T06:54:51.881Z","updated":"2023-02-25T05:20:41.597Z","comments":true,"path":"tags/index.html","permalink":"https://mengfanjun020906.github.io/tags/index.html","excerpt":"","text":"看起来标签很多 但是实际上不过就是一个缝合怪罢了🥲 强烈推荐单片机标签系列和matlab标签，我写的超认真👏👏👏"}],"posts":[{"title":"【文献阅读】DeepSIG_A_Hybrid_Heterogeneous_Deep_Learning_Framework_for_Radio_Signal_Classification","slug":"【文献阅读】DeepSIG_A_Hybrid_Heterogeneous_Deep_Learning_Framework_for_Radio_Signal_Classification","date":"2024-05-25T03:49:26.000Z","updated":"2024-05-24T04:31:48.709Z","comments":true,"path":"2024/05/25/【文献阅读】DeepSIG_A_Hybrid_Heterogeneous_Deep_Learning_Framework_for_Radio_Signal_Classification/","link":"","permalink":"https://mengfanjun020906.github.io/2024/05/25/%E3%80%90%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E3%80%91DeepSIG_A_Hybrid_Heterogeneous_Deep_Learning_Framework_for_Radio_Signal_Classification/","excerpt":"","text":"缩写词 AMC：automatic modulation classification ，自动调制分类。 SIG：S for Sequence, I for Image and G for Graph。 LFGM：Limited Fixed Graph Mapping # 摘要 目的：为了处理异构输入格式的无线电信号，文章提出了一种名为DeepSIG的混合异构调制分类架构，该架构将递归神经网络（RNN），卷积神经网络（CNN）和图神经网络（GNN）模型集成在单个框架中。 in-phase (I) and quadrature (Q) sequences,IQ信号即同相正交信号，I为in-phase同相分量，Q为quadrature正交分量，Q与I的相位相差了90度。 # Introduction 第一章主要讲述了论文的研究背景、现有的调制分类方法及其局限性，以及提出的新的混合异构深度学习框架DeepSIG。以下是具体内容的概述： 研究背景与动机 无线通信技术的发展：随着物联网（IoT）、5G技术等无线通信技术的快速发展，电磁环境变得越来越复杂，频谱资源短缺问题变得更加严重。 频谱利用率的重要性：提高频谱利用率变得愈发重要。认知无线电技术是一种有效的提高频谱效率的方法，它可以动态管理频谱资源的使用。 调制分类的角色 调制识别在频谱感知中的作用：调制分类有助于频谱感知，是认知无线电中的关键技术之一。 传统调制分类方法 手工特征提取：传统的调制分类方法依赖于手工设计的特征提取步骤，需要专业知识支持，且在复杂环境下分类准确率可能不高。 基于深度学习的自动调制分类（AMC） 深度学习的发展：随着人工智能的发展，基于深度学习的AMC方法逐渐兴起，这些方法能够自动学习和提取特征，实现端到端的调制分类。 深度学习AMC的输入格式：根据输入格式，基于深度学习的AMC方法可以分为基于序列输入、图像输入和图形输入三类。 各类深度学习AMC方法的特点 基于序列输入： 输入一般为接收信号的同相（I）和正交（Q）分量，通常使用循环神经网络（RNN）模型来捕捉IQ信号的时间相关信息。 基于图像输入： 将IQ信号按照一定规则或通过可训练的神经网络层映射成图像，然后使用卷积神经网络（CNN）进行分类。该方法能够利用图像分类领域的技术，但可能会在转换过程中丢失原始信号中的某些信息。 基于图形输入： 将信号转换为图数据并进行分类。这类方法通过图嵌入方法或图神经网络（GNN）模型实现信号分类，但图映射算法的转换速度较慢，对长时间信号的处理有一定局限性。 DeepSIG框架 提出DeepSIG：为了充分利用不同输入格式的数据所包含的潜在信息，本文提出了一个混合异构框架DeepSIG，集成了基于序列、图像和图的三种AMC模型。 框架结构：DeepSIG包括四部分：序列网络、图像网络、图网络和融合分类网络。 序列网络：使用长短时记忆网络（LSTM）处理IQ信号，提取时间相关特征信息。 图像网络：提出了一种新的图像映射方法DWTDR，通过离散小波变换（DWT）的分解和重构将IQ信号映射为双通道窄边图像，然后使用ResNet18模型提取图像特征。 图形网络：提出了一种新的图映射方法LFGM，将IQ信号根据其过采样率映射为稀疏图，并使用DiffPool模型提取图特征。 融合分类（fusion）网络：将前面三部分提取的特征向量进行归一化和拼接融合，通过全连接层进行最终的调制分类。 主要贡献 提出DeepSIG框架：整合了基于序列、图像和图的三种AMC模型，提高了调制识别的准确性。 新图像映射方法DWTDR：将IQ信号转换为双通道窄边图像，保留了原始信号中的隐含信息，有助于后续分类。 新图映射方法LFGM：高效地将IQ信号映射为稀疏图，适合处理长时间信号。 实验验证：在多个数据集和少样本场景下验证了DeepSIG的性能，显示其优于单一输入格式的分类方法。 论文结构 第二章：介绍了基于序列、图像和图的调制分类方法的相关工作。 第三章：详细介绍了DeepSIG的架构。 第四章：提供了仿真结果。 第五章：对论文进行了总结。 总体而言，第一章为整个论文奠定了基础，介绍了研究的背景、现有方法的局限性以及提出的新的解决方案DeepSIG的整体框架和贡献。 Related Work A.AMC Methods With Sequence Input 在当前无线电调制分类的领域，基于序列输入即IQ信号的AMC方法是最常见的。然后列举了一些其他学者所做的调制分类方法。 B.AMC Methods With Image Input 在AMC处理图像输入时，将无线电信号转换成图像的方法是其中的关键步骤之一。可以分为两类：基于固定规则的图像映射方法和基于可训练神经网络层的图像映射方法。在目前来看，前者是很常见的。 总的来说，目前基于固定规则的图像映射方法在转换过程中，容易丢失原始无线电信号的部分信息。基于可训练神经网络层的图像映射方法，需要人工设计再去与特定的网络模型相结合。 ## C.AMC Methods With Graph Input 在基于图形输入的AMC方法中，将信号映射成图形的方法是必不可少的。文章在这一节介绍了许多类似的基于图形输入的图形映射方法，现有的图映射方法都存在一个共同的问题，都不能很好地应用于长信号。 PROPOSED DEEPSIG FRAMEWORK A.Problem Formulation 在无线通信领域，调制分类旨在通过对接收信号\\(r(n)\\)的分析来推断所发送的基带信号\\(s(n)\\)的调制方案。接收信号\\(r(n)\\)和发射信号\\(s(n)\\)的关系如下： \\(g(n)\\)是滤波器的响应，\\(h(n)\\)是无线信道的响应，\\(\\Delta f\\)是由接收器和发射器之间的时钟的多普勒频移或同步引起的载波频率偏差。\\(\\theta\\)是相位偏差，\\(\\omega(n)\\)是加性白色高斯噪声，\\(N\\)是信号长度，\\(*\\)代表卷积操作。 \\(C\\)代表了调制方案的数量，因此，调制分类问题可以被视为具有\\(C\\)类的分类问题。 若接收信号是复函数的形式，则以下列I/Q的形式去表示，I代表实部，Q代表虚部。 B.Overall Framework 整体的框架如下，对于图像，输入的是映射后的双通道窄边缘图像，经过了没有分类的resnet18，输出了\\(F_s\\),对于序列信号，输入的是IQ信号，经过了没有分类的 LSTM，输出了\\(F_I\\),对于图形，输入的是映射后的图形，经过了没有分类的DiffPool，输出了\\(F_G\\)。其中图像和图形都是由IQ信号得到的，对IQ信号做DWT运算，得到了双通道窄边缘图像，对IQ信号做LFGM运算，得到了映射后的图形。这一框架里面还包含了全连接层，作为分类层。 对于输入进的信号，如果不是IQ信号，我们需要做一些预处理。 我们在DeepSIG的训练过程中做了一些处理，可以分为两步： 1.利用IQ信号序列、DWT得到的图像数据和LFGM得到的图形数据，分别训练LSTM、ResNet18和DiffPool；根据初步训练后保存的三个模型，可以提取每个无线电信号的三个特征向量\\(F_S\\)，\\(F_I\\)和\\(F_G\\)，它们是LSTM，ResNet18和DiffPool模型中最后一个全连接层的对应输入向量。 2.再对这三个特征向量进行归一化处理后，通过拼接处理可以得到融合的特征向量\\(F_H\\)，并将其作为输入向量训练新加入的全连接层，以获得最终的分类结果。 ## C.Sequence Network 在DeepSIG的序列网络部分，输入数据是IQ信号，属于一种时间序列数据，使用的网络模型是LSTM。目前，RNN通常用于通过深度学习处理时间序列。其中，LSTM是较为流行的一种，它可以有效地解决RNN的长期依赖问题。LSTM主要通过遗忘门、更新门和输出门三种门机制来控制从时间序列中提取的特征信息的流动和损失，从而解决普通RNN在训练长时间序列过程中的梯度消失和梯度爆炸问题。 下图就是文中给出LSTM的详细构造，因为整个系统的容量是有限的，为了清除与本次过程无关的记忆内容，保留与本次有关的记忆内容，我们就引入了==遗忘门== 其中，遗忘门\\(f_t\\)的公式如下 根据这公式所展示的sigmoid，其中\\(W_f\\)和\\(b_f\\)分别表示当前神经网络层的可训练权重和偏置。我们会把有用的记忆保留为1，不需要的变为0，这样往上走，进行乘法运算。 ==更新门==代表经过本次的学习产生了新的内容，但是对于这些内容，我们需要进行筛选，再输出，所以用Sigmoid和Tanh进行了筛选。 其中\\(W_u\\)、\\(b_u\\)、&amp;W_Y\\(和\\)b_Y$表示相应神经网络层的权重和偏置。 ==输出门==使用Sigmiod函数来确定需要输出单元状态\\(V_t\\)的哪一部分，我们经过tanh就是为了筛选出我们需要的部分。 其中\\(W_o\\)和\\(b_o\\)分别表示当前神经网络层的权重和偏置。 文章使用了两个LSTM层和一个全连接层来分类序列网络中归一化为[-1，1]的IQ信号数据。下面是归一化的算法伪代码： 第一层由128个LSTM细胞组成，第二层有4个细胞，最后一个全连接层是分类层，用于将第二个LSTM层的输出特征映射到数据集的调制类别数量。 D.Image Network 提出了一种图像映射方法，对IQ信号数据进行DWT处理，得到双通道窄边缘图像数据，然后使用ResNet18模型进行调制识别任务。 1）算法：小波变换是一种具有多分辨率分析特点的时频分析方法，在低频区和高频区分别具有较高的频域分辨率和时间分辨率。用DWT分解信号的层次结构如图所示。 i阶段的DWT信号分解公式如下所示， 其中\\(g(k)\\)和\\(h(k)\\)分别表示低通滤波器和高通滤波器，\\(K\\)是它们的长度。\\(k\\)代表着信号中的时间索引或位置 每次进行DWT分解，得到的两个分量的长度将减少一半，因此我们最多可以对长度为N的序列进行\\(log_2 N\\)阶DWT分解。 在实际应用中，对于包括无线电信号在内的许多序列数据，低频分量是重要的，它往往包含了信号的特征，而高频分量则显示了信号中的细节。 基于近似分量及其对应细节分量的DWT重建过程可以表示为： 在DWT重构过程中，两个等长的信号分量可以合并为一个新的、长度为原来两倍的信号分量。 利用DWT的多层分解，可以将信号分解成多个高频和低频分量，然后通过多次DWT重构操作将这些分量组合回原始长度的信号。文章的方法与传统的信号重构方法不同之处在于，在DWTDR方法中，信号重构操作包含了一些预处理步骤，以便更好地处理信号分量。 从IQ信号到图像的算法如下所示： 通道1的重建过程如图所示： 对I通道数据进行多次DWT分解，获取多个高频分量和一个低频分量。根据分解得到的频率分量进行多次重构操作。每次重构操作中，仅保留一个分量，其余设为零，通过多次重构得到新的序列。将所有重构序列组合成一个矩阵。对Q通道数据进行相同处理，得到对应矩阵。将I和Q通道的矩阵拼接，生成最终的图像。 总结一下，就是对I通道和Q通道数据分别进行多次DWT分解和重构操作，生成多个重构序列，然后将这些序列组合成矩阵，最终通过连接I和Q通道的矩阵，生成一个双通道窄边图像。这种方法通过保留和重构频率分量，确保了信号的时间和频率信息在图像映射中的保留和表达。 在得到每个IQ信号对应的\\(M_{IQ}\\)图像后，文章利用resnet18进行调制分类。从理论上讲，神经网络模型的网络层越深，可以获得的信息越多，特征越丰富。但在实际中，当网络层数超过一定程度时，继续加深网络会造成梯度爆炸或梯度消失的问题，这将对网络的优化产生不利影响。 为了解决这一问题，文章使用了以残差块为核心的resnet18。下图展示了一个残差块的构造： resnet为何能解决梯度爆炸等问题呢？ 在深层神经网络中，随着层数的增加，梯度在反向传播过程中会逐层相乘，如果每一层的梯度都非常小（小于1），会导致梯度逐渐变得非常小，称为梯度消失；反之，如果每一层的梯度都非常大（大于1），会导致梯度逐渐变得非常大，称为梯度爆炸。这两种情况都会导致网络难以训练。 残差块通过引入跳跃连接，使得每一个块的输入可以绕过中间的层，直接连接到输出。跳跃连接（Skip Connections）使得梯度可以直接从较深的层传递到较浅的层，从而有效缓解梯度消失和梯度爆炸问题。 从图中可以看出，残差块之间有跳跃连接，跳跃连接提供了一条直接的梯度传播路径，使得梯度可以绕过多个中间层直接传递。这意味着即使中间层的梯度变得非常小或非常大，梯度仍然可以通过跳跃连接有效地传播。 2）Complexity Analysis： 文章在这里分析DWTDR的复杂性，以Haar小波为例子，首先分析时间复杂度，假设他的滤波器长度\\(K=2\\)。当对具有长度\\(N\\)的IQ信号的信道执行Haar离散小波分解时，需要总共\\(N/2\\)次加法和\\(N/2\\)次乘法运算。因此，Haar离散小波分解对长度为N的通道数据的时间复杂度为函数\\(O(N)\\)。对于2个通道的IQ信号，时间复杂度为\\(O(2N)\\)。在DWTDR过程中，总共需要\\(log_2N\\)分解，并且每个分解的序列长度是前一个分解长度的一半。 因此，在DWTDR中IQ信号的整个分解过程的时间复杂度为: 其次，在DWTDR的重构过程中，以处理长度为N的IQ信号的通道序列为例，基于从上述分解获得的一个低频分量和\\(N\\)个高频分量，需要递归地执行\\(log_2N\\)次DWT重构操作以获得长度为\\(N\\)的序列，即一次信号重构。每次小波变换重构的时间复杂度与相应的小波变换分解的时间复杂度相同，均为\\(O\\)(重建序列的长度)。因此，对信道序列执行信号重构操作的时间复杂度为： 对于IQ信号，存在两个通道序列，并且每个通道序列在整个DWTDR重构过程中需要\\((1+log_2N)\\)个信号重构操作。 因此，IQ信号的DWTDR重建的时间复杂度为： 最后，我们可以知道DWTDR的时间复杂度是： 同样，DWTDR的空间复杂度也可以分为两部分：分解和重构。以IQ信号的信道序列为例，在分解过程中，\\((1+log_2N)\\)的数组空间，需要存储一个低频分量和分解后得到的N个高频分量。因此，在DWTDR分解过程中IQ信号的空间复杂度为： 在重构过程中，我们需要一个数组来存储从当前DWT重构获得的分量，单通道信号重构包括\\(log_2 N\\) DWT重构，而DWTDR重构包括\\((1+log_2N)\\)信号重构。因此，在DWTDR重构过程期间IQ信号的空间复杂度为： 最后，我们可以得到DWTDR的空间复杂度： ## E.Graph Network 这里讲的是用图形表示IQ信号，然而，这些图映射方法很耗时，特别是在处理长信号时，所以我们提出了一种方法称为LFGM，来映射IQ信号到图形。通过LFGM，我们用相同结构的图来表示不同的IQ信号。不同之处在于不同图中节点的特征向量。将IQ信号映射到图形的过程见下面的伪代码： 以下是伪代码的详细步骤解释： 输入 超参数 \\(( k )\\)：控制节点之间连接的范围。 IQ信号 \\(( S_{IQ} )\\)：包含 \\(( I )\\)（同相分量）和\\(( Q )\\)（正交分量）的时间序列信号。 输出 图 \\(( G = \\langle V_N, E \\rangle )\\)：包含节点集合 \\(( V_N )\\) 和边集合 \\(( E )\\)。 在这里插入图片描述 具体地，对于长度为N的无线电信号样本\\(S_{IQ}\\) 我们把它转换成相应的图\\(G = \\langle V_N, E \\rangle\\)。其中\\(V_N\\)和\\(E\\)表示图G的节点集和边集。在图\\(G\\)中，\\(N\\)个节点对应于相应IQ信号的时间采样点，节点的属性值是由采样点对应的IQ通道的两个值组成的向量。图\\(G\\)的边由时间采样点的距离决定。间隔小于\\(k\\)的时间采样点可以形成边，其中\\(k\\)是一个超参数，可以用来控制图\\(G\\)的连接关系的稀疏性。\\(k\\)越大，生成的图越密集。为了更好地保留原始IQ信号的隐含信息，我们将\\(k\\)设置为无线电信号的过采样率。 我们以\\(v_3\\)为例子，\\(4-3=1\\)小于2，所以\\(v_3\\)连接\\(v_4\\)，而不能连接其他的节点。 在将每个IQ信号映射到相应的图中之后，现有的用于图分类的GNN可以直接用于无线电信号调制分类。用GNN进行图分类是根据拓扑连接关系学习每个节点的嵌入表示向量，文章选择DiffPool对映射图进行分类，DiffPool实际上是一个可微分图池模块，可以生成图的层次表示，并且可以以端到端的方式与各种图神经网络架构相结合。DiffPool的架构图如图所示。 在这里插入图片描述 原始图经过第一层池化，节点被聚合成超节点。图中用不同颜色（例如绿色、灰色、黄色和橙色）表示不同的超节点，每个超节点代表了一组原始节点的聚合。 第一层池化后的图进一步经过第二层池化，超节点再次被聚合成更高层次的超节点。图中用蓝色和灰色表示这一级别的超节点。 第二层池化后的图继续进行第三层池化，形成更少的超节点，用橙色表示。 最终，经过多层池化后的图被转化为一个特征向量，提取出了代表图的全局信息的特征。 在这里插入图片描述 它为每一层中的节点学习可区分的集群分配，将节点映射到一组集群，然后形成下一个GNN层的粗糙化输入。图的边连通度一般用一个形状为\\(N×N\\)的矩阵表示。为了保存存储空间，我们可以用\\(S_E\\)二进制群来表示边集，其中\\(S_E\\)表示图中边的个数。 通过算法3，我们得到了 因此LFGM的空间复杂度为\\(O(2S_E)\\) ## F.Fusion Training 通过这三个训练好的模型，可以分别得到输入格式为序列、图像和图形的分类模型的特征向量\\(F_S\\)、\\(F_I\\)和\\(F_G\\)。 \\(\\Gamma s\\)、\\(\\Gamma i\\)、\\(\\Gamma g\\)分别表示训练好的没有最后一个分类层的ResNet18、LSTM和DiffPool模型。然后，对所获得的三个特征向量\\(F_S\\)、\\(F_I\\)和\\(F_G\\)执行相同的归一化处理，并且将三个归一化向量拼接以获得如下融合特征向量\\(F_H\\): 这个\\(N\\)代表了归一化运算。其中\\(v\\)是要处理的一维特征向量，\\(l\\)是向量\\(v\\)的长度，\\(v_i\\)表示\\(v\\)的第\\(i\\)个元素，\\(\\epsilon\\)是一个小值，用于避免被零除，\\(\\left \\| v \\right \\| _p\\)表示\\(v\\)上的L-p范数运算，\\(p\\)表示范数公式中的指数值,|·|是绝对值运算。随后，增加用于分类的全连接层，并将拼接后的融合特征向量\\(F_H\\)用作新层的输入： 其中\\(L_{FC}\\)表示添加的全连接层，\\(O\\)是预测的标签.最后，将基于序列、图像和图形的前三个网络的最后一个全连接层去掉，并将神经网络与新增加的全连接层进行融合训练。在融合训练的过程中，新的全连接层需要用更大的学习率进行训练，其他神经网络层\\(\\Gamma s\\)、\\(\\Gamma i\\)、\\(\\Gamma g\\)需要用更小的学习率进行微调。 SIMULATIONS A.Datasets 文章使用三个无线电信号数据集RML2016.10a [25]，SigData18和SigData36来展示我们提出的DeepSIG的性能，其中第一个是公共数据集，另外两个是文章作者团队自己生成的。下表是其基本信息： 其中，RML2016.10a有11种调制方案。每种调制的信噪比（SNR）范围为−20 dB至18 dB，间隔为2 dB。每个信号的长度为128，过采样率为8。该数据集共有220000个样本。在仿真过程中，我们取800个从每个调制方案中，作为样本训练，剩下的作为测试样本。 SigData-18包含18种调制方案。信号长度为512，过采样率为8。脉冲整形采用升余弦滤波，滚降系数在[0.2，0.7]范围内随机选择。SNR范围为−20dB至30dB，间隔也为2dB。我们在每个调制方案的每个SNR下从该数据集中随机挑选800个信号作为训练集，并将剩余样本合并到测试集中。 SigData-36类似于SigData-18，除了SigData-36的信号长度为1024，并且它具有额外的18种调制方案，即BPSK，OQPSK，32APSK，64 APSK，128 APSK，256 APSK，4ASK，8ASK，4FSK，8 FSK，4CPM，8 CPM，OOK，AM，FM，AM-MSK，FM-MSK和OFDMBPSK。 ## B. Simulation Setting 所有仿真过程都在NVIDIA Tesla T4上运行。在训练过程中，我们使用的深度学习框架是PyTorch。我们使用PyTorch Geometric来构建GNN模型DiffPool。优化器和损失函数分别是Adam和交叉熵。在训练模型时，我们使用固定步长的学习率衰减策略，初始学习率为0.001，每5个epoch调整一次学习率，衰减到前一个值的80%。此外，在对DeepSIG进行融合训练时，除最终分类层外的其他网络层的初始学习率均设置为0.00001。在数据集RML2016.10a、SigData—18和SigData—36上训练时，minibatch大小分别设置为128、128和32。我们在通过DWTDR将IQ信号映射到图像的过程中使用的小波函数是Daubechies（db1），即Haar。当在0.5%、1%和完整训练集的数据集RML 2016.10a上训练DeepSIG时，（28）公式中提到的\\(p\\)分别被设置为（50，1）和1，并且在其他情况下指数值\\(p\\)被设置为2。 ## C. Performance of DWTDR and LFGM 为了验证DWTDR和LFGM的性能，文章采用了GAF和AVG（两种图形转化算法）作为对照。自适应可见性图（AVG）、Gramian角场（GAF）。然后下文给了选择GAF和AVG的一些理由。 为了公平起见，在用GAF和DWTDR将信号映射到图像后，使用ResNet18模型进行分类。对于AVG和LFGM，都结合DiffPool模型进行分类，结果展示如下： 其中，表II中的“FLOP”和“Parameters”分别表示当推断IQ信号样本时计算中的相应浮点运算和存储中的参数的数量。我们可以看到，与GAF相比，基于我们提出的DWTDR的调制分类方法在三个数据集上具有更高的准确性，特别是在RML2016.10a和SigData-18上。由于LFGM得到的窄边矩阵比GAF得到的窄边矩阵小得多，因此基于LFGM的调制识别方法的总体计算复杂度和空间复杂度都明显小于基于GAF的调制识别方法。 通过比较基于可训练映射算法的AVG和基于固定映射规则的LFGM的结果可以看出，我们提出的LFGM在复杂长信号数据集SigData—36上具有更好的性能，准确率提高了约4%，但不可否认的是，RML 2016.10a和SigData—18上的平均分类准确率分别降低了约0.4%和1.4%。与通过神经网络层学习和调整映射图结构的AVG相比，虽然LFGM在两个信号相对较短的数据集上的性能略低，但LFGM更简单高效，直接使用相同结构的图来表示不同的信号，不需要在用于学习图结构的神经网络层上花费冗余的资源和时间。表II中的“FLOP”表明基于LFGM的分类方法的计算复杂度上级基于AVG的分类方法。因此表II中基于AVG的分类方法的“Parametes”不包括图形的边缘信息。 基于LFGM的分类方法的“Parameters”是通过考虑边缘信息参数和模型参数而获得的参数的数目。在上述三个数据集的仿真中，当处理相同的无线电信号时，基于AVG获得的映射图中的边的数量通常多于基于LFGM获得的映射图中的边的数量。因此，实际上，基于LFGM的分类方法的参数的数目少于基于AVG的分类方法的参数的数目。总的来说，我们提出的DWTDR和LFGM在分类精度和实现可行性方面具有良好的性能。 ## D. Results on Complete Datasets 文章首先讨论DeepSIG在上述三个数据集上的调制分类性能。使用了第二节中提到的序列、图像和图三种分类方法。单独使用图像、序列、图形方法分别和把它们结合在一起的DeepSIG方法去做一个比较。比较的结果如下表所示 得出结论：DeepSIG可以将分类准确率大幅提高近2.5%。 下图展示出了在不同SNR上的调制分类精度： 很明显，在数据集RML2016.10a上，我们提出的DeepSIG在− 12 dB和− 8 dB等低SNR下略有优势，在其他SNR下的性能与其他方法基本相同。根据图8（b）所示的数据集SigData-18的详细分类结果，我们可以看到DeepSIG的性能明显优于其他三个单独的分类网络，特别是在8 dB以上的高SNR下。 从图8（c）可以看出，集成了三个独立分类网络的DeepSIG也可以提高数据集SigData-36的调制分类精度，特别是在-12 dB和2 dB之间的SNR区域。 在一定程度上可以说明，DeepSIG通过LSTM处理IQ序列数据可以提取时间信息，也能够通过处理映射的图像和图形，挖掘原始信号潜在的图像表示特征和潜在的图形特征。它可以充分利用这三个不同尺度上的特征来提高调制分类的准确性。 为了进一步分析这些方法在不同调制类型下的识别性能，我们绘制了SNR = 10 dB时的混淆矩阵，如图所示 混淆矩阵就对其分类的结果进行了进一步的验证。 从图9（a）至图9（d）可以看出，在调制类别数量相对较少的数据集RML 2016.10a上，这些方法的分类精度相似，混淆矩阵差异不明显。这些方法都容易将WBFM误认为AMDSB。 图9（e）至图9（h）是数据集SigData-18上的混淆矩阵。可以很明显的观察出DeepSIG的性能更优越在8PAM和16PAM，图像网络容易将OFDM—QPSK误分类为OFDM—16QAM，相比之下，图网络和DeepSIG对OFDM—QPSK的识别准确率更高。 对于数据集SigData—36，从图9（i）到图9（l）可以看出，与其他三个单独的分类网络相比，混合异构DeepSIG在64QAM、128QAM和256QAM的识别能力上有一定的提升。 总的来说，基于深度学习的调制识别网络本质上可以分为特征提取和分类。前者可以自动学习和提取能够代表输入信号的特征表示，而后者基于提取的特征向量进行分类处理。简单的说就是，提取的特征越多，对分类越有利。文章提出的混合异构框架DeepSIG包括三种不同类型的神经网络，可以处理代表同一信号样本的三种不同类型的输入，并从不同方面从原始信号数据中提取三个包含隐含信息的特征向量。这三个特征向量的融合导致更丰富和更全面的特征表示，通过充分利用丰富的特征，允许更好的分类性能。 E. Results in Few-Shot Scenarios 现在是对少样本的场景分析DeepSIG的性能，模拟也是基于上述三个数据集。与上文不同的是，文章只使用训练集中的一部分数据来训练网络模型。三种少数情况，其中训练样本是从原始训练集中以不同比例随机提取的，分别是0.5%、1%和5%。仿真的结果如下表和图所示。 从表四可以看出，在三个少样本的场景中，DeepSIG的分类性能最好。RML2016.10a的类别较少，还有一定的进步空间。在另外两个数据集上，即，SigData-18和SigData-36，DeepSIG在分类准确性方面在少数场景中具有更好的分类性能。 在数据集SigData—18的三个少样本中，与三个单独的分类网络（图像、图形、序列）相比，DeepSIG的性能将提高至少2%。在数据集SigData-36上，性能增益至少为4%。 从图10中可以看出，DeepSIG在数据集SigData—18和SigData—36的几乎所有SNR中都具有比其他模型更高的分类准确度。这些结果表明，DeepSIG可以从不同角度充分挖掘和利用特征信息，以提高复杂无线电信号的少样本学习中的调制分类性能。 在实际的场景中，训练的样本常常是不足够的，此时，我们可以使用本文提到的三种不同形式的输入来表示同一个信号样本，然后从不同的角度提取、融合和使用信号特征表示，以在训练样本有限的场景下尽可能提高调制识别精度。 CONCLUSION 在本文中，我们提出了一种用于无线电调制分类的混合异构深度学习框架，即DeepSIG。DeepSIG接收输入数据，这些数据可以以三种不同的格式表示IQ信号：序列，图像和图形。更重要的是，DeepSIG集成了RNN，CNN和GNN领域的网络模型。在三个无线电信号数据集上的仿真结果表明，我们提出的DeepSIG比基于三个独立字段的模型具有更好的分类性能。它的性能增益更明显，特别是在少数镜头的情况下。 在未来，我们将尝试其他映射方法，将IQ信号映射到图像和图形中，并研究DeepSIG中的其他RNN，CNN和GNN架构。此外，我们将进行空中实验，以进一步验证所提出的方法的性能。","categories":[{"name":"文献阅读","slug":"文献阅读","permalink":"https://mengfanjun020906.github.io/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"文献","slug":"文献","permalink":"https://mengfanjun020906.github.io/tags/%E6%96%87%E7%8C%AE/"},{"name":"研究所","slug":"研究所","permalink":"https://mengfanjun020906.github.io/tags/%E7%A0%94%E7%A9%B6%E6%89%80/"}]},{"title":"学习通信原理之——彻底理解频谱和频谱密度","slug":"学习通信原理之——彻底理解频谱和频谱密度","date":"2024-02-21T08:11:56.000Z","updated":"2024-02-29T07:51:01.986Z","comments":true,"path":"2024/02/21/学习通信原理之——彻底理解频谱和频谱密度/","link":"","permalink":"https://mengfanjun020906.github.io/2024/02/21/%E5%AD%A6%E4%B9%A0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B9%8B%E2%80%94%E2%80%94%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%A2%91%E8%B0%B1%E5%92%8C%E9%A2%91%E8%B0%B1%E5%AF%86%E5%BA%A6/","excerpt":"","text":"前言 最近还是在复习通信原理，但是对于频谱/频谱密度/能量谱/能量谱密度/功率谱/功率谱密度还是一知半解的，所以我就去各种看资料，看视频，又去问了问老师。 所以我在这里写下自己对这两个概念的一些分析和理解，不敢说100%正确，仅供大家参考。 频谱 频谱的定义 我感觉最通俗的解释就是信号的某种特征量随信号频率的关系，称为频谱 符号定义 接下来文中出现的符号定义 符号 含义 T 信号周期 \\[\\Omega\\] 频域信号两个谱线之间的间距 \\[\\tau\\] 时域信号宽度 周期信号 周期信号的傅立叶级数具有幅频特性和相频特性 单边谱 这里是傅立叶级数的普通形式 \\[ \\begin{Bmatrix}A_{n}(幅度) \\sim \\omega \\\\ \\varphi_{n}(相位) \\sim \\omega \\end{Bmatrix} \\] \\[ A_n=\\sqrt[]{a^2_n+b^2_n}~~~ n=1,2,3... \\] 双边谱 这里是傅立叶级数的复数形式 \\[ \\begin{Bmatrix} \\left | F_{n}(幅度)\\right | \\sim \\omega \\\\ \\varphi_{n}(相位)\\sim \\omega \\end{Bmatrix} \\] \\[ \\left | F_{n}\\right |=\\frac{A_n}{2}~~~n=0,\\pm 1,\\pm 2,... \\] 例子：周期矩形波信号 我拿GeoGebra画了一个很粗略的表示，这个其实是周期性的，就是他其实是无限个矩形波函数，大家应该都懂我意思🤪 \\[ 矩形波信号：幅度为1 宽度为\\tau 周期为T \\] 我们求其频谱也就是求傅立叶级数的系数Fn 求其傅立叶级数的Fn \\[ \\begin{aligned} Fn&amp;=\\frac{1}{T}\\int_{-\\frac{T}{2} }^{\\frac{T}{2} } f(t)e^{-jn\\Omega t}dt \\\\ &amp;=\\frac{1}{T}\\int_{-\\frac{T}{2} }^{\\frac{T}{2} } e^{-jn\\Omega t}dt \\\\ &amp;=\\frac{1}{T}\\frac{1}{-jn\\Omega} e^{-jn\\Omega t}|_{-\\frac{T}{2}}^{\\frac{T}{2}} \\\\ &amp;=\\frac{1}{T}\\frac{1}{-jn\\Omega} [e^{-jn\\Omega \\frac{T}{2} }-e^{-jn\\Omega (-\\frac{T}{2}) }] \\\\ &amp;=\\frac{1}{T}\\frac{1}{-jn\\Omega}[-2jsin(n\\Omega\\frac{\\tau }{2} )] \\\\ &amp;=\\frac{2}{T}\\frac{sin(\\frac{n\\Omega\\tau}{2} )}{\\frac{n\\Omega\\tau}{2}} ·\\frac{\\tau}{2} \\\\ &amp;=\\frac{\\tau}{T}Sa(\\frac{n\\Omega\\tau}{2}) (n=0,\\pm 1,\\pm 2...) \\end{aligned} \\] \\[ 我们已知抽样函数Sa(x)函数=\\frac{sinx}{x} \\\\\\tau是信号宽度,T是信号周期 \\] 画出其频谱图 先画出Sa函数，注意坐标轴，我这里为了方便显示，取了几个具体的数值，实际上要根据题中的条件计算。 1234567891011121314151617181920212223242526272829clearclose allclc% 定义时间轴t和信号xt = -16:0.01:16;x = (0.25)*sinc(t / pi);% 绘制原始信号plot(t, x, &#x27;--&#x27;,&#x27;LineWidth&#x27;, 3);xlabel(&#x27;时间&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;Sa(t)&#x27;);grid on;hold on;% 进行1/4倍采样x_downsampled = downsample(x, 80);% 计算新的时间轴t_downsampled = t(1:80:end);% 绘制降采样后的信号stem(t_downsampled, x_downsampled, &#x27;LineWidth&#x27;, 3);xlabel(&#x27;w&#x27;);ylabel(&#x27;Fn&#x27;);title(&#x27;频谱图&#x27;);legend(&#x27;频谱信号&#x27;, &#x27;谱线&#x27;);grid on; \\[ 我们设T=4\\tau~~ Fn=\\frac{1}{4}Sa(\\frac{n\\Omega\\tau }{2} ) \\\\则零点\\frac{n\\Omega\\tau }{2}=\\pi m\\Rightarrow n\\Omega =\\frac{2m\\pi}{\\tau} \\] 两个零点之间有4条谱线，这些谱线的位置和数量取决于信号的采样率和矩形波函数的宽度。 \\[ 两个零点之间有4条谱线,谱线间隔为\\Omega \\\\ \\frac{\\omega }{\\Omega}=\\frac{\\frac{2\\pi }{\\tau } }{\\frac{2\\pi }{T} } =4 \\\\ 最高点是0.25 \\] \\[ \\Omega=\\frac{2\\pi }{T}=2\\pi f \\] 因为周期门函数在时域是周期连续的，所以他在频谱上就是非周期离散的。 对应关系 时域/频域 时域/频域 周期 离散 非周期 连续 举个例子： 矩形波函数在时域是连续周期的，那么他在频谱上就是非周期离散的。 门函数做傅立叶变换后就是Sa函数，如果把它在时域上周期化，那他的频谱就被离散化了，也就是变成了上图的样子，包络是一个Sa函数，但是谱线是离散的。 特点 周期信号频谱是离散谱（谐波性）。 谱线所处的位置是基频Ω的整数倍。 一般具有收敛性，总趋势减小。 T不变，改变τ，观察三个脉冲时间不同的矩形波信号 \\[ 函数g_\\tau (t)=\\frac{\\tau}{T}Sa(\\frac{n\\pi \\tau }{T} ) \\] 结论 观察这些图，我们可以得到结论： \\[ 若T不变\\tau 减小\\left\\{\\begin{matrix}1.最大点\\frac{\\tau}{T} \\downarrow \\\\2.谱线间隔不变 \\\\2.零点向右移动，零点横坐标变大了 \\\\4. 谱线数目\\frac{T}{\\tau} \\end{matrix}\\right. \\] \\[ 当\\tau\\longrightarrow 0,图像会变成一条直线，也就是我们说的冲激函数\\delta (t) \\] τ不变，改变T，观察四个周期不同的矩形波信号 \\[ 若\\tau 不变，T增加\\left\\{\\begin{matrix}最大值\\frac{\\tau }{T}\\downarrow \\\\谱线间隔\\Omega=\\frac{2\\pi}{T} \\downarrow,当T\\rightarrow \\infty ，\\Omega\\rightarrow 0 \\\\零点\\frac{2m\\pi}{\\tau },\\tau 不变,0点不变 \\\\谱线数\\frac{T}{\\tau }\\uparrow ,谱线数\\rightarrow \\infty \\end{matrix}\\right. \\] 结论 我们重点看一下最后一个图，当T趋于∞，周期信号的周期无穷大，那么他就变成了非周期信号，频域变成了连续函数。 我们知道： \\[ n\\Omega=\\frac{2\\pi}{T}n , T\\rightarrow \\infty ,n\\Omega\\rightarrow 0 \\] 上面的公式是什么意思呢，就是频域的离散函数变成了连续函数，因为每一个谱线的间隔的无限小。 \\[ 在数学上，当\\Omega\\rightarrow 0时,我们称其为\\omega \\] 其实最后一个图像我们就从傅立叶级数得到了傅立叶变换——计算非周期信号的频谱。关于其数学公式的推导，我也写了一篇博客但是因为公式实在太多，只推导了一部分，后期我会把坑填上的。 频谱密度 这个概念可折磨我太久了，主要是网上好多说的感觉不太准确，也没有合适的视频讲解，只能靠着我自己搜集资料来做一个浅浅的解释。 我去问老师的时候，他先举了一个例子： 假如这有一本书，书上画满了点，那么书上的点就是无限的，随便在书上找一页，每个点上面“占有了”这个书多少呢。 答案是0，点是无限的，所以平均到每个点上面，占有的书就是0。 在Wikipedia中，对于密度的定义是这样的： 密度是指一物质单位体积下的质量 我们常说的密度是连续的，所以那频谱密度也是连续的，这里我给个频谱密度一个定义，是指信号单位频率下的能量。 频谱密度函数\\(F\\left( \\omega \\right)\\)公式 \\[ F\\left( \\omega \\right) =\\lim_{T\\rightarrow \\infty} \\frac{F_n}{1/T}=\\lim_{T\\rightarrow \\infty} F_n \\cdot T= \\lim_{w\\rightarrow 0} \\frac{F_n\\cdot 2\\pi}{w} \\] 在这里\\(F_n\\)(指数型傅里叶级数的系数)是趋于无穷小的，\\(T\\)是趋于无穷大的，所以这两者相乘是一个常数。 但是话又说回来，为什么频谱密度要叫频谱密度呢，他和普通的频谱到底有什么区别？ 想象有一块石头，他的质量是m，他的体积是v，根据密度公式，我们很容易算出他的密度是多少，那加入我们取石头上非常非常小的一块，它的质量趋于0，它的体积也趋于0，那么怎么用物理量来表示呢，这时就要引出密度的概念了，无穷小的质量/无穷小的体积得到的常数，就是这一小块的密度了。 img 所以频谱密度也是一样的道理，\\(F\\left( j\\omega \\right) = \\lim_{w\\rightarrow 0} \\frac{F_n\\cdot 2\\pi}{\\omega}\\)。因为各个频率分量的幅度是无穷小的，给他除一个很小的频带宽度\\(\\omega\\)就能得到一个常数。 傅里叶正变换公式 由上文的公式 \\[ F\\left( \\omega \\right) =\\lim_{T\\rightarrow \\infty} \\frac{F_n}{1/T}=\\lim_{T\\rightarrow \\infty} F_n \\cdot T= \\lim_{w\\rightarrow 0} \\frac{F_n\\cdot 2\\pi}{w} \\] 以及 \\[ F_n=\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}{f\\left( t \\right) e^{-jn\\omega t}dt} \\] 将\\(F_n\\)代入\\(F\\left( j\\omega \\right) =\\lim_{T\\rightarrow \\infty} F_n \\cdot T\\)得 \\[ F\\left( \\omega \\right) =\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}{f\\left( t \\right) e^{-jn\\omega t}dt} \\] 因为傅里叶变换的情况是\\(T\\)趋于无穷，\\(\\omega\\)趋于0，\\(n\\omega\\)变成连续的了，所以傅里叶正变换公式就是 \\[ F\\left( \\omega \\right) =\\int_{-\\infty}^{\\infty}{f\\left( t \\right) e^{-j\\omega t}dt} \\] # 傅里叶逆变换公式 先看傅里叶级数的指数形式 \\[ f\\left( t \\right) =\\sum_{n=-\\infty}^{\\infty}{F_ne^{jn\\omega t}} \\] 为了凑出\\(F(\\omega)\\)，我们要这样处理 \\[ f\\left( t \\right) =\\sum_{n=-\\infty}^{\\infty}{F_nTe^{jn\\omega t}\\cdot \\frac{1}{T}} \\] 我们令\\(T\\rightarrow \\infty\\)，则\\(\\omega \\rightarrow 0\\)，取其为\\(d\\omega\\)，我们就可以将上式的\\(\\frac{1}{T}\\)改为\\(\\frac{2\\pi}{T}\\cdot \\frac{1}{2\\pi}\\)，\\(\\omega\\)趋于0，\\(n\\omega\\)变成连续的了，求和符号应变为积分符号，所以\\(f(t)\\)最后为 \\[ f\\left( t \\right) =\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}{F(\\omega )}e^{j\\omega t}d\\omega \\] 这就是傅里叶逆变换。 我们在上面已经说了，连续的频谱基频Ω趋于0，对照着下面这图像 我们可以知道，连续频谱在时域上是非周期的。所以，当我们谈论谱密度时，就已经是默认这个信号在时域上是非周期的，频谱是连续的了。 这里我们需要引入能量信号，他的能量是有限的，所以他一定是一个非周期函数，所以严格地说，他不能用傅立叶级数去计算他的频谱，他只能用傅立叶变换去计算他的频谱密度。 关于周期信号的频谱密度，我参考了这一篇文章：频谱和频谱密度在概念和适用方向上有哪些区分？ - 張無忌的回答 - 知乎 周期功率信号 的功率只集中分布在基频的倍频上，因而，功率在频域是离散分布的，如果严格地套用谱密度的意义，其谱密度应该是一连串冲击函数，这类包含无穷的特殊函数对应用而言是没有意义的。有时为了与非周期信号统一表示，会将集中分布的功率近似平均到相邻倍频的区间内，形式上也就变成频谱密度，但应当了解，这是近似的，并不是周期信号原始的属性。 举个例子，在这幅图中，我们可以将集中分布的功率近似分布到相邻的倍频区间内，他也就变成连续的了。 非周期功率信号 对应的直接就是频谱密度。 还有需要了解的是，对能量信号和功率信号的分析中，虽然有时两者的分析中都称谱密度，但能量信号的谱密度是 能量的谱密度 ，而功率信号的谱密度指的是 功率的谱密度 ，二者在计算上有区别的，相差了一个时间平均，不应混淆。 总结 我们一般在分析信号的时候，要先确定其信号类型，如果是非功率非能量信号，则要用广义函数和分布对其进行分析，但是话说回来，我看了这么多还真没遇到过这样的，如果我以后遇到了再来填坑。确定其信号类型之后，我们要根据其类型再去分析：如果是能量信号，看看是周期信号还是非周期信号(通常是非周期信号)，再对其进行傅立叶变换，假如是功率信号，判断其是周期信号还是非周期信号，要注意只有周期功率信号才有频谱(因为可以做傅立叶级数)，非周期功率信号和能量信号是没有频谱的，只有频谱密度(只能做傅立叶变换)。或者说周期性的功率信号频域是离散的，其他信号频域是连续的。","categories":[{"name":"学习通信原理","slug":"学习通信原理","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"考研","slug":"考研","permalink":"https://mengfanjun020906.github.io/tags/%E8%80%83%E7%A0%94/"}]},{"title":"如何做一个炫酷的Github个人简介（3DContribution）","slug":"如何做一个炫酷的Github个人简介（3DContribution）","date":"2024-01-03T09:08:16.000Z","updated":"2024-02-29T08:22:42.568Z","comments":true,"path":"2024/01/03/如何做一个炫酷的Github个人简介（3DContribution）/","link":"","permalink":"https://mengfanjun020906.github.io/2024/01/03/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E7%82%AB%E9%85%B7%E7%9A%84Github%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B%EF%BC%883DContribution%EF%BC%89/","excerpt":"","text":"前言 最近放假了，毕设目前也不太想做，先搞一点小玩意玩玩，让自己的github看起来好看点。也顺便学学这个action是怎么个事。 3D-Contrib 先给大家看一下效果 我的个人主页：https://github.com/MengFanjun020906/MengFanjun020906 原仓库链接：https://github.com/yoshi389111/github-profile-3d-contrib PS：不要在意我这个少得可怜的contributions 要做这样一个效果，就需要用到github的action，之前一直没用过，今天才知道是干啥用的。 第一步 在你的个人仓库下找到Actions 第二步 点击New workflow 在这里插入图片描述 第三步 创建一个新的文件，名为profile-3d.yml 第四步 文件输入这些信息，替换你自己的名字即可 1234567891011121314151617181920212223name: GitHub-Profile-3D-Contribon: schedule: # 03:00 JST == 18:00 UTC - cron: &quot;0 18 * * *&quot; workflow_dispatch:jobs: build: runs-on: ubuntu-latest name: generate-github-profile-3d-contrib steps: - uses: actions/checkout@v3 - uses: yoshi389111/github-profile-3d-contrib@0.7.1 env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; USERNAME: 你自己的名字 - name: Commit &amp; Push run: | git config user.name github-actions git config user.email github-actions@github.com git add -A . git diff --staged --exit-code || (git commit -m &quot;generated&quot; &amp;&amp; git push) 保存 第五步 在Action下运行这一action 第六步 在你的README.md中添加 1![Personal 3D Metrics](./profile-3d-contrib/profile-night-green.svg) 当然，他会创建一个文件夹，你也可以自己选择。 添加到README中就能看到了。","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://mengfanjun020906.github.io/tags/github/"}]},{"title":"FPGA_Verilog HDL_AC620零基础入门学习——格雷码计数器实验","slug":"FPGA_Verilog HDL_AC620零基础入门学习——格雷码计数器实验","date":"2023-04-26T07:21:46.000Z","updated":"2023-05-22T05:33:26.996Z","comments":true,"path":"2023/04/26/FPGA_Verilog HDL_AC620零基础入门学习——格雷码计数器实验/","link":"","permalink":"https://mengfanjun020906.github.io/2023/04/26/FPGA_Verilog%20HDL_AC620%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%BC%E9%9B%B7%E7%A0%81%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"实验要求 模块功能应包括二进制码计数器的产生、由二进制码产生格雷码、所产生的格雷码再次转换为二进制码等逻辑部分。 该项目由一个功能模块和一个testbench组成。其中功能模块的端口信号如下表所示 在这里插入图片描述 格雷码表 二进制 格雷码 0000 0000 0001 0001 0010 0011 0011 0010 0100 0110 0101 0111 0110 0101 0111 0100 1000 1100 1001 1101 1010 1111 1011 1110 1100 1010 1101 1011 1110 1001 1111 1000 GrayCounter .mac { width:10px; height:10px; border-radius:5px; float:left; margin:10px 0 0 5px; } .b1 { background:#E0443E; margin-left: 10px; } .b2 { background:#DEA123; } .b3 { background:#1AAB29; } .warpper{ background:#121212; border-radius:5px; width:400px; } &lt;div class=&quot;mac b1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mac b2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mac b3&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;using namespace std;int main()&#123; return 0;&#125;// ```// 最后需要三个` csdn编辑器连续输入两行```显示有点问题 ```bashmodule GrayCounter( input clk_50M, input rst_n, output reg[3:0]gray_dout, output reg[3:0]gray_count); always@(posedge clk_50M or negedge rst_n) if(!rst_n) begin gray_dout &lt;= 4&#x27;b0000; gray_count &lt;= 4&#x27;b0000; // 复位计数器end else begin case(gray_dout) 4&#x27;b0000 : begin gray_dout &lt;= 4&#x27;b0001; gray_count &lt;=4&#x27;b0001; end 4&#x27;b0001 : begin gray_dout &lt;= 4&#x27;b0011; gray_count &lt;=4&#x27;b0010; end 4&#x27;b0011 : begin gray_dout &lt;= 4&#x27;b0010; gray_count &lt;=4&#x27;b0011; end 4&#x27;b0010 : begin gray_dout &lt;= 4&#x27;b0110; gray_count &lt;=4&#x27;b0100; end 4&#x27;b0110 : begin gray_dout &lt;= 4&#x27;b0111; gray_count &lt;=4&#x27;b0101; end 4&#x27;b0111 : begin gray_dout &lt;= 4&#x27;b0101; gray_count &lt;=4&#x27;b0110; end 4&#x27;b0101 : begin gray_dout &lt;= 4&#x27;b0100; gray_count &lt;=4&#x27;b0111; end 4&#x27;b0100 : begin gray_dout &lt;= 4&#x27;b1100; gray_count &lt;=4&#x27;b1000; end 4&#x27;b1100 : begin gray_dout &lt;= 4&#x27;b1101; gray_count &lt;=4&#x27;b1001; end 4&#x27;b1101 : begin gray_dout &lt;= 4&#x27;b1111; gray_count &lt;=4&#x27;b1010; end 4&#x27;b1111 : begin gray_dout &lt;= 4&#x27;b1110; gray_count &lt;=4&#x27;b1011; end 4&#x27;b1110 : begin gray_dout &lt;= 4&#x27;b1010; gray_count &lt;=4&#x27;b1100; end 4&#x27;b1010 : begin gray_dout &lt;= 4&#x27;b1011; gray_count &lt;=4&#x27;b1101; end 4&#x27;b1011 : begin gray_dout &lt;= 4&#x27;b1001; gray_count &lt;=4&#x27;b1110; end 4&#x27;b1001 : begin gray_dout &lt;= 4&#x27;b1000; gray_count &lt;=4&#x27;b1111; end 4&#x27;b1000 : begin gray_dout &lt;= 4&#x27;b0000; gray_count &lt;=4&#x27;b1111; end default:begin gray_dout &lt;= 4&#x27;bx; gray_count &lt;= 4&#x27;bx; end endcase endendmodule GrayCounter_tb 123456789101112131415161718192021222324252627`timescale 1 ns/ 1 nsmodule GrayCounter_tb();reg clk_50M;reg rst_n; wire [3:0] gray_dout;wire [3:0] gray_count; GrayCounter i1 ( .clk_50M(clk_50M), .gray_dout(gray_dout), .rst_n(rst_n), .gray_count(gray_count));initial begin rst_n = 0; clk_50M = 0; #5 rst_n = 1; #100 $stop;endalways #5 clk_50M = ~clk_50M;initial $monitor($time,&quot;-&gt; \\t now state of gray is : %b,now state of bin_count is:%b&quot;,gray_dout,gray_count);endmodule 输出结果 在这里插入图片描述 整体波形 在这里插入图片描述 部分波形 在这里插入图片描述","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://mengfanjun020906.github.io/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://mengfanjun020906.github.io/tags/FPGA/"}]},{"title":"学习通信原理之——频谱,功率谱,功率谱密度(MATLAB演示)","slug":"学习通信原理之——频谱:功率谱:功率谱密度(MATLAB演示)","date":"2023-04-04T08:15:23.000Z","updated":"2023-04-04T08:49:08.312Z","comments":true,"path":"2023/04/04/学习通信原理之——频谱:功率谱:功率谱密度(MATLAB演示)/","link":"","permalink":"https://mengfanjun020906.github.io/2023/04/04/%E5%AD%A6%E4%B9%A0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B9%8B%E2%80%94%E2%80%94%E9%A2%91%E8%B0%B1:%E5%8A%9F%E7%8E%87%E8%B0%B1:%E5%8A%9F%E7%8E%87%E8%B0%B1%E5%AF%86%E5%BA%A6(MATLAB%E6%BC%94%E7%A4%BA)/","excerpt":"","text":"前言 最近在复习通信原理，每次到了功率谱这一块就感到困惑，每次都要去查，我觉得不能再这样循环下去了，这次一定要对这三个概念理解透彻，于是去网上找了资料去学习。 学习了b站视频：NO.31 十分钟搞定频谱/功率谱/功率谱密度 在这里记录下自己的一些感悟与理解 介绍 频谱 频谱是指某个信号在频域上的表示，即它在不同频率下的成分及其相对强度。在信号处理中，频谱常用于分析信号的频率内容和频率分布，可以用于音频、视频、无线通信等领域的分析和处理。频谱通常用图形方式表示，其中横轴表示频率，纵轴表示信号在该频率上的强度或功率，可以是线性或对数坐标。 功率谱 功率谱表示单位频带内信号功率随频率的变化情况,单位是W，即它在不同频率下的功率或能量分布情况。与频谱类似，功率谱也是用于分析信号频率内容和频率分布的一种工具，但它考虑的是信号在不同频率下的功率或能量分布，因此可以更直观地描述信号的能量分布情况。通常，功率谱的横坐标是频率，纵坐标是功率或能量密度，可以是线性或对数坐标。功率谱在很多领域都有广泛的应用，比如无线通信、音频信号处理、图像处理等。 功率谱密度 功率谱密度表示单位时间和单位频带内信号能量随频率的分布情况，单位是能量除时间除频带，通常用于描述信号在连续频域上的功率分布情况。与功率谱类似，功率谱密度也是描述信号在不同频率下的功率或能量分布情况，但它考虑的是单位频率范围内的功率或能量分布情况，因此它可以更精确地描述信号的功率分布情况，尤其是对于带宽非常宽的信号而言。功率谱密度通常用于分析连续时间信号或随机信号的频率特性，比如噪声、振动、电磁干扰等。功率谱密度的单位通常是功率或能量密度除以频率单位，例如瓦特/赫兹（W/Hz）或焦耳/赫兹（J/Hz）。 由电路中的功率想到信号功率 \\[ 电路中的功率:P=\\frac{V^2}{R}=I^2R \\] 若 \\[ R=1\\Omega \\] \\[ 电路中的功率:P=V^2=I^2 \\] 如果将V 换成信号的序列s(t)，我们能发现，我们所说的功率谱公式，就是来源上面的公式。 计算信号能量和能量谱密度 那么这个信号自产生到结束的总能量就是 \\[ E=\\int_{-\\infty }^{+\\infty } s(t) ^2 dt=\\int_{-\\infty }^{+\\infty }\\left | S (f) \\right |^2 df \\] E存在，即称为能量信号; 能量谱密度： \\[ G(f)=\\left | s(f) \\right |^2,J/HZ \\] 计算信号功率和功率谱密度 因为功率信号的能量是无限的，所以我们只取-T/2~T/2,来计算其功率 \\[ E_{T}=\\int_{-\\frac{T}{2} }^{\\frac{T}{2} } s_{T}(t)^2 dt=\\int_{-\\infty }^{\\infty }\\left | S_{T}(f)^2 \\right | df \\] \\[ P(f)=\\lim_{T \\to \\infty} \\frac{1}{T}\\left |S(f) \\right |^2 \\] P(f)就是功率谱密度 功率信号的功率P就是： \\[ P=\\lim_{T \\to \\infty} \\int \\left |S(f) \\right |^2df=\\int_{-\\infty }^{\\infty } P(f) df \\] P存在，即称为功率信号 由上面的式子可知： 时域信号傅立叶变换模平方然后除以时间长度（来自能量谱密度）。 根据帕塞瓦尔定理，信号傅立叶变换模平方被定义为能量谱，能量谱密度在时间上平均就得到了功率谱。功率谱密度P(f)在频率轴上积分，T趋向无穷大，就是信号的功率P。 总结： 能量有限、功率为零的信号为能量信号。 能量无限、功率有限的信号为功率信号。 所有周期信号都是功率信号；所有有限数量的脉冲信号都是能量信号。 MATLAB画一个随机信号的频谱 生成随机信号 12345%生成随机信号noiseLevel=2;signal = rand(80000,1);noise = randn(80000,1) * noiseLevel;signal = signal + noise; 在这里插入图片描述 做傅立叶变换并画图 123456789101112131415X = signal;Fs = 2e3;L = length(X);Y = fft(X);%傅立叶变换P2 = abs(Y/L);P1 = P2(1:L/2+1);P1(2:end-1)=2*P1(2:end-1);f = Fs*(0:(L/2))/L;%频谱%subplot(231);plot(f,P1);ylim([0 0.05]);title(&#x27;频谱&#x27;);xlabel(&#x27;f(Hz)&#x27;);ylabel(&#x27;|P1(f)|(单位:mV)&#x27;); 因为没有进行任何的滤波等操作，所以里面的直流分量、噪声等影响因素都存在，这就是一个很完全的原始信号。 ## MATLAB画这个随机信号的功率谱 功率实际上就是能量的平方。 为了便于观察功率谱的变化，我们对横坐标的功率化成了dBm \\[ dBm=10log_{10}\\frac{P}{1mW} \\] 123456%功率谱subplot(232);plot(f,10*log10(P1.^2));%将W转为dBmtitle(&#x27;功率谱&#x27;);xlabel(&#x27;f(Hz)&#x27;);ylabel(&#x27;|P1(f)|^2(单位:dBm)&#x27;); ## MATLAB画这个随机信号的功率谱(另一种方法) 123%第二种方法求功率谱pwelch(signal,[],[],[],Fs,&#x27;power&#x27;);title(&#x27;Welch功率谱&#x27;); ## MATLAB画这个随机信号的功率谱密度 1pwelch(signal,[],[],[],Fs); 功率谱密度纵轴的单位变成了(db/Hz)，表示每一个Hz有多少dB。 跟功率谱图像做对比，可以观察到，幅度较大的频率分量被保留了下来。 pwelch函数含义 pwelch是Matlab中用于计算功率谱密度的函数。它的基本语法是： 1[Pxx,F] = pwelch(x,window,noverlap,nfft,fs) 其中，x是一个向量或矩阵，表示要计算功率谱密度的信号，window是窗函数，noverlap是窗函数之间的重叠部分，nfft是FFT的点数，fs是采样率。函数将返回一个功率谱密度估计值向量Pxx和一个对应的频率向量F。 # 完整代码 1234567891011121314151617181920212223242526272829303132333435363738clearclose allclc%生成随机信号noiseLevel=2;signal = rand(80000,1);noise = randn(80000,1) * noiseLevel;signal = signal + noise;X = signal;Fs = 2e3;L = length(X);Y = fft(X);%傅立叶变换P2 = abs(Y/L);P1 = P2(1:L/2+1);P1(2:end-1)=2*P1(2:end-1);f = Fs*(0:(L/2))/L;%频谱subplot(221);plot(f,P1);ylim([0 0.05]);title(&#x27;频谱&#x27;);xlabel(&#x27;f(Hz)&#x27;);ylabel(&#x27;|P1(f)|(单位:mV)&#x27;);%功率谱subplot(222);plot(f,10*log10(P1.^2));%将W转为dBmtitle(&#x27;功率谱&#x27;);xlabel(&#x27;f(Hz)&#x27;);ylabel(&#x27;|P1(f)|^2(单位:dBm)&#x27;);%第二种方法求功率谱subplot(223);pwelch(signal,[],[],[],Fs,&#x27;power&#x27;);title(&#x27;Welch功率谱&#x27;);%功率谱密度subplot(224);pwelch(signal,[],[],[],Fs); 在这里插入图片描述","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"考研","slug":"MATLAB与数学建模/考研","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%80%83%E7%A0%94/"},{"name":"学习通信原理","slug":"MATLAB与数学建模/考研/学习通信原理","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"校园卡想对你说的话","slug":"Introduction","date":"2023-03-31T07:38:33.000Z","updated":"2023-03-31T07:52:14.422Z","comments":true,"path":"2023/03/31/Introduction/","link":"","permalink":"https://mengfanjun020906.github.io/2023/03/31/Introduction/","excerpt":"","text":"软件与通信学院 学院简介 软件与通信学院的前身可追溯至1985年成立的天津中德现代工业技术培训中心机电部，至今已有35多年的办学历史。学院现有天津市特色化示范性软件学院，以“产学研转创用”为建设目标。先后培养5000余名毕业生，活跃在中国联通、电信、华为、中科软等各类型企业，打造了一大批各类杰出一线工匠人才。学院荣获2016年度天津市五一劳动奖状。 学院师资力量雄厚，拥有一支与企业紧密结合的高水平教师队伍。现有教职员工42人，其中，教授4人，副教授15人，另有双聘教师6人，企业兼职教师20余人，博士生导师1人，硕士生导师6人。 学院设有软件系、物联网系、通信系等3个系，设软件工程、物联网工程、通信工程3个本科专业，软件技术、物联网技术2个高职专业。每年本科生招生近400人，高职招生近200人，全部在校生近1500人。在近三年参加全国各类大学生信息学科竞赛和全国职业院校技能大赛中获奖百余项以上。主要培养学生在软件与通信领域企事业单从事设计、开发、检验、优化维护、管理和技术支持等相关岗位，就业率持续超过98%，以较强的实践动手能力，踏实的敬业精神、灵活的创新意识和较高的综合素质受到用人单位广泛好评。搭建国际学历衔接的“立交桥”，培养国际化技术人才，制定职业教育国际化教学标准，在柬埔寨和尼日利亚建设有鲁班工坊，并于2018年开始招收国际留学生。与德国、日本等发达国家应用型本科院校开展国际化办学合作。 学院现有科研基地和教学实验基地20余个，并和国内外知名企业和研究单位共建了多个科研和实训平台。学院科研实力雄厚，已形成多个在国内外具有影响力的特色研究方向，如：新型传感器与流动参数检测，自动化装备与过程控制，智能系统检测与控制，智能信息处理与应用，机器人控制技术，新能源动力汽车网联技术，宽带信息处理与传输、智能感知理论与系统、隐蔽通信与信息对抗、图像显示与识别技术、音视频信号处理、云计算与大数据等等。 近四年承担科研项目30余项，获天津市科技进步一等奖1项，发表高水平论文100多篇，授权专利50多项，全院承担的科研项目经费超过1000万元，一大批科研成果获得了广泛的推广应用。 欢迎访问天津中德应用技术大学课程共享计划 地址如下：天津中德应用技术大学课程共享计划 想加入我们吗，联系我 此校园卡作者：@LX0102","categories":[],"tags":[]},{"title":"AxMath使用教程+常用符号与公式（持续更新中）","slug":"AxMath使用教程+常用符号与公式（持续更新中）","date":"2023-02-14T02:50:33.000Z","updated":"2023-04-29T14:13:11.454Z","comments":true,"path":"2023/02/14/AxMath使用教程+常用符号与公式（持续更新中）/","link":"","permalink":"https://mengfanjun020906.github.io/2023/02/14/AxMath%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B+%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%85%AC%E5%BC%8F%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/","excerpt":"","text":"前言 这两天学了学Latex，主要是为了以后写毕业论文做铺垫，而且Latex在数学公式这一方面，要比Word方便许多，于是我就下载了一款国产的公式编辑器——AxMath。永久会员不贵，只要36元，而且软件很好用，我选择支持国产。因为我是学通信的，可能整理的一些通信相关的公式和符号较多。 面板介绍 我感觉常用的其实就这俩功能，如果熟练起来的话，基本不需要鼠标操作。没学这些之前一直有一个误区就是觉得Latex要会写代码，其实学了之后才发现，基本不需要自己写，套模板和复制就足够了。 在这里插入图片描述 点击Latex代码转换 这个好处就是可以根据上面写的公式来学习代码是怎么写的 输入公式 渲染 两个$中间夹起来表示渲染Latex 1$$ 要渲染的内容 $$ 基本运算符号 名称 AxMath 渲染后 加 + \\[ + \\] 减 - \\[ - \\] 乘 \\[ \\cdot \\] 除 \\[ \\div \\] 正负 \\[ \\pm \\] ,一般不写 *作为乘号 分数 普通输入 AxMath 渲染后 1/2 \\[ \\frac{1}{2} \\] 1解读：\\frac&#123;分子&#125;&#123;分母&#125; 根号 名称 AxMath 渲染后 根号 \\[ \\sqrt{2} \\] 多次根号 \\[ \\sqrt[3]{2} \\] 123解读： \\sqrt&#123;被开方数&#125; \\sqrt[开几次根]&#123;被开方数&#125; 等式关系 名称 AxMath 渲染后 等于 = \\[ = \\] 不等于 \\[ \\ne \\] 约等于 \\[ \\approx \\] 小于 &lt; \\[ &lt; \\] 大于 &gt; \\[ &gt; \\] 小于等于 \\[ \\leqslant \\] 大于等于 \\[ \\geqslant \\] 换行与空格 普通输入 AxMath 渲染后 \\\\(双反斜杠) \\\\ \\[ \\frac{1}{2} \\\\ \\frac{1}{2}\\] ~(波浪线) ~~~~ \\[ \\frac{1}{2} ~~~~ \\frac{1}{2}\\] 常用三角函数 普通输入 AxMath 渲染后 sin sin \\[ \\sin\\] cos cos \\[ \\cos\\] tan sin \\[ \\tan\\] arcsin arcsin \\[ \\mathrm{arc}\\sin \\] arccos arccos \\[ \\mathrm{arc}\\cos \\] arctan arctan \\[ \\mathrm{arc}\\tan \\] sec sec \\[ \\sec \\] cot cot \\[ \\cot \\] csc csc \\[\\csc \\] 括号 名称 AxMath 渲染后 小括号 () \\[ () \\] 中括号 [] \\[ [] \\] 大括号 {} \\[\\left\\{ \\right\\} \\] 多行小括号 ( \\[ \\left( \\begin{array}{c}1\\\\2\\\\3\\\\\\end{array} \\right) \\] 多行中括号 \\[ \\left[ \\begin{array}{c}1\\\\2\\\\3\\\\\\end{array} \\right] \\] 多行大括号 { \\[ \\left\\{ \\begin{array}{c}1\\\\2\\\\3\\\\\\end{array} \\right\\} \\] 12解读： \\begin&#123;array&#125;&#123;c&#125;，array指一个矩阵，c指一列 绝对值 名称 AxMath 渲染后 绝对值 a \\[ \\mid a \\mid \\] 微分与积分 名称 AxMath 渲染后 微分 \\[ \\frac{\\mathrm{d}y}{\\mathrm{d}x}\\] 积分 _b^a{f( x ) x} \\[ \\int_b^a{f\\left( x \\right) \\mathrm{d}x}\\] f'(x) f( x ) \\[ f\\prime\\left( x \\right) \\] 123解读：\\mathrm&#123;要变成正体的字母&#125; int_积分区间开始^积分区间结束&#123;被积内容&#125; f\\left( x \\right)表示f(x),\\left和\\right表示左小括号和右小括号 求和与累乘 名称 AxMath 渲染后 求和 _{n=1}^{}{f( x )} \\[ \\sum_{n=1}^{\\infty}{f\\left( x \\right)}\\] 累乘 _{n=1}^{}{f( x )} \\[ \\prod_{n=1}^{\\infty}{f\\left( x \\right)}\\] 123解读： \\sum&#123;开始求和&#125;^&#123;结束求和&#125;&#123;函数&#125; \\prod_&#123;开始累乘&#125;^&#123;结束累乘&#125;&#123;函数&#125; 极限 名称 AxMath 渲染后 求极限 _{x } \\[ \\lim_{x \\to 0}\\] 12解读： \\lim_&#123;x \\to 0&#125;x趋于0 计算时等号对齐 每个等号前面加上&amp; 空格 &amp; =公式 &gt; \\begin&#123;aligned&#125; 这里开始 &gt; &amp; ={n} &gt; \\ &gt; &amp; ={n} &gt; \\ &gt; &amp; ={n} &gt; \\ &gt; &amp; ={n} &gt; \\ &gt; &amp; =_{n} &gt; \\ &gt; &amp; = &gt; \\end&#123;aligned&#125; 这里结束 渲染后 \\[ \\begin{aligned} \\text{原式}&amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\sqrt{1+2+...+n}-\\sqrt{1+2+...+\\left( n-1 \\right)} \\right] \\\\ &amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\sqrt{\\frac{n\\left( 1+n \\right)}{2}}-\\sqrt{\\frac{\\left( 1+n-1 \\right) n}{2}} \\right] \\\\ &amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\sqrt{\\frac{n\\left( 1+n \\right)}{2}}-\\sqrt{\\frac{n^2}{2}} \\right] \\\\ &amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\frac{\\frac{n+n^2-n^2}{2}}{\\sqrt{\\frac{n\\left( 1+n \\right)}{2}}+\\sqrt{\\frac{n^2}{2}}} \\right] \\\\ &amp; =\\sqrt{2}\\lim_{n\\rightarrow \\infty} \\left[ \\frac{1}{\\sqrt{1+\\frac{1}{n}}+\\sqrt{1}} \\right] \\\\ &amp; =\\frac{\\sqrt{2}}{2} \\end{aligned} \\] 希腊字母 名称 AxMath 渲染后 Alpha \\[\\alpha \\] Beta \\[\\beta \\] Gamma \\[\\gamma \\] Delat \\[\\delta \\] 举个例子 a_n=_{-}^{}{f( x ) mxx} \\[ a_n=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\cos mx\\mathrm{d}x} \\]","categories":[{"name":"Latex","slug":"Latex","permalink":"https://mengfanjun020906.github.io/categories/Latex/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://mengfanjun020906.github.io/tags/Latex/"}]},{"title":"Git提交本地项目代码到远程Github仓库教程","slug":"Git提交本地项目代码到远程Github仓库教程","date":"2023-02-11T10:57:33.000Z","updated":"2023-03-23T15:18:41.456Z","comments":true,"path":"2023/02/11/Git提交本地项目代码到远程Github仓库教程/","link":"","permalink":"https://mengfanjun020906.github.io/2023/02/11/Git%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8BGithub%E4%BB%93%E5%BA%93%E6%95%99%E7%A8%8B/","excerpt":"","text":"1.在Github创建一个空仓库 2.在本地项目文件夹打开Git Bash 3.初始化git仓库 输入 1git init 4.提交项目文件夹所有文件-放入暂存区 输入 1git add . 提交所有文件 5.提交项目文件夹所有文件-提交文件 输入 1git commit -m &quot;first commit&quot; -m表示message “first commit”表示提交的备注，每次都要写，可以写汉语 6.添加远程连接 输入 1git remote add origin https://github.com/MengFanjun020906/STM32-Key-Control-LED.git 7.推送代码到远程 输入 1git push -u origin master 将项目推送到master分支 8.完成 再到github看你新创建的仓库 已经有本地的文件了","categories":[{"name":"Git","slug":"Git","permalink":"https://mengfanjun020906.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://mengfanjun020906.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://mengfanjun020906.github.io/tags/github/"}]},{"title":"24考研数学每日一题Latex版（带解析）","slug":"24考研数学每日一题(带解析)","date":"2023-01-28T03:49:26.000Z","updated":"2023-03-23T15:28:35.483Z","comments":true,"path":"2023/01/28/24考研数学每日一题(带解析)/","link":"","permalink":"https://mengfanjun020906.github.io/2023/01/28/24%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98(%E5%B8%A6%E8%A7%A3%E6%9E%90)/","excerpt":"","text":"题目来源于武老师的每日一题，答案是自己做的，不太严谨，仅供参考 2022年11月1日 知识点：函数定义域 答案： \\[ \\text{函数定义域是指自变量}x\\text{的取值范围，不可以把}x+1\\text{作为自变量，}x\\text{才是自变量，} \\\\ \\text{同一个}f()\\text{，括号内整体范围相同。由题意得}0\\leqslant x\\leqslant a\\Rightarrow 1\\leqslant x+1\\leqslant a+1\\text{，所以}f\\left( x \\right) \\text{定义域为}\\left[ 1,a+1 \\right] \\] 2022年11月2日 知识点：函数定义域 答案： \\[ f\\left[ \\varphi \\left( x \\right) \\right] =1-x^2,f\\left( x \\right) ={e^x}^{^2}\\Longrightarrow e^{\\varphi ^2\\left( x \\right)}=1-x,\\text{两边同时求}\\ln ,\\varphi ^2\\left( x \\right) =\\ln \\left( 1-x \\right) \\\\ \\text{由题意得}\\varphi \\left( x \\right) \\ge 0,\\text{两边开根号},\\varphi \\left( x \\right) =\\sqrt{\\ln \\left( 1-x \\right)},\\text{负半边不要了，只留正的。定义域：}\\ln \\left( 1-x \\right) \\ge 0\\Rightarrow 1-x\\ge 1\\Rightarrow x\\le 0 \\] 2022年11月3日 知识点：复合函数 答案： \\[ g\\left( x \\right) =\\begin{cases} 2-x, x\\le 0\\\\ x+2,x\\ge 0\\\\ \\end{cases},f\\left( x \\right) =\\begin{cases} x^2, x&lt;0\\\\ -x,x\\ge 0\\\\ \\end{cases},f\\left( x \\right) \\text{是}g\\left( x \\right) \\text{的复合函数} \\\\ x^2,x&lt;0\\text{但是}x^2&gt;0,-x,x\\ge 0\\text{但是}-x&lt;0,\\text{所以}g\\left[ f\\left( x \\right) \\right] =\\begin{cases} 2+x^{}, x\\ge 0\\\\ x^2+2,x&lt;0\\\\ \\end{cases},\\text{注意}x\\text{的取值，与}f\\left( x \\right) \\text{的取值是一致的} \\] 2022年11月4日 知识点：反函数 答案： \\[ \\text{把}f\\left( x \\right) \\text{分段拆开来看},\\text{当}x&lt;-1,y=1-2x^2\\Rightarrow x=\\pm \\sqrt{\\frac{1-y}{2}},\\text{因为}x&lt;-1,x=-\\sqrt{\\frac{1-y}{2}},x=-1\\text{时},y=-1,\\text{所以}x=-\\sqrt{\\frac{1-y}{2}},y&lt;-1\\text{。} \\\\ \\text{当}-1\\le x\\le 2\\text{时},y=x^3\\Rightarrow x=\\sqrt[3]{y},\\text{当}x=-1\\text{时},y=-1,\\text{当}x=2\\text{时},y=8\\text{所以}x=\\sqrt[3]{y},-1\\le y\\le 8\\text{。} \\\\ \\text{当}x&gt;2\\text{时},y=12x-16\\Rightarrow x=\\frac{y+16}{12},x=2,y=8,\\text{所以}x=\\frac{y+16}{12},y&gt;8\\text{。} \\\\ \\text{把}y\\text{换成}x,g\\left( x \\right) =\\left\\{ \\begin{array}{c} -\\sqrt{\\frac{1-x}{2}},x&lt;-1\\\\ \\sqrt[3]{x},-1\\le x\\le 8\\\\ \\frac{x+16}{12},x&gt;8\\\\ \\end{array} \\right. \\] 2022年11月5日 知识点：函数奇偶性 重点 答案： \\[ \\text{设}h\\left( x \\right) \\text{为奇函数，}g\\left( x \\right) \\text{为偶函数可以使}f\\left( x \\right) =h\\left( x \\right) +g\\left( x \\right) \\text{成立，}h\\left( -x \\right) =-h\\left( x \\right) ,g\\left( -x \\right) =g\\left( x \\right) \\\\ f\\left( -x \\right) =h\\left( -x \\right) +g\\left( -x \\right) =-h\\left( x \\right) +g\\left( x \\right) ,\\left\\{ \\begin{array}{c} f\\left( x \\right) =h\\left( x \\right) +g\\left( x \\right)\\\\ f\\left( -x \\right) =-h\\left( x \\right) +g\\left( x \\right)\\\\ \\end{array}\\Rightarrow g\\left( x \\right) =\\frac{1}{2}\\left[ f\\left( x \\right) +f\\left( -x \\right) \\right] \\left( x\\text{与}-x\\text{互换等式结果一样，偶函数} \\right) ,h\\left( x \\right) =\\frac{1}{2}\\left[ f\\left( x \\right) -f\\left( -x \\right) \\right] \\left( x\\text{与}-x\\text{互换等式结果一样，奇函数} \\right) \\right. \\] 2022年11月6日 知识点：函数基本性质 答案： \\[ f\\left( -x \\right) =-x\\tan \\left( -x \\right) \\cdot e^{\\sin -x}=x\\tan x\\cdot e^{-\\sin x},f\\left( x \\right) \\ne f\\left( x \\right) ,A\\text{错} \\\\ e^{\\sin x}\\text{为周期函数，}\\tan x\\text{为周期函数，}x\\text{单调递增，相乘后不是周期函数，}C\\text{错} \\\\ x,\\tan x\\text{在}\\left( -\\frac{\\pi}{2},\\frac{\\pi}{2} \\right) \\text{上单调递增，}e^{\\sin x}\\text{为周期函数，则}f\\left( x \\right) \\text{不是单调函数，}D\\text{错，证明出}B\\text{正确} \\] 2022年11月7日 知识点：函数的有界性 答案： \\[ \\lim_{x\\rightarrow -1} f\\left( x \\right) =\\frac{-\\sin 3}{-1\\cdot -2\\cdot 9}=\\frac{\\sin 3}{18},\\lim_{x\\rightarrow 0^-} f\\left( x \\right) =\\frac{\\sin 2}{-4},A\\text{正确} \\\\ \\lim_{x\\rightarrow 0^+} f\\left( x \\right) =\\frac{\\sin 2}{4},\\lim_{x\\rightarrow 1^-} f\\left( x \\right) =\\frac{1}{x-1}\\cdot -\\sin 1=-\\infty ,B\\text{错} \\\\ \\lim_{x\\rightarrow 1^+} f\\left( x \\right) =\\frac{1}{x-1}\\cdot -\\sin 1=+\\infty ,\\lim_{x\\rightarrow 2^-} f\\left( x \\right) =\\frac{1}{x-2}=-\\infty ,C\\text{错} \\\\ \\lim_{x\\rightarrow 2^+} f\\left( x \\right) =\\frac{1}{x-2}=+\\infty \\text{，}\\lim_{x\\rightarrow 3} f\\left( x \\right) =\\frac{\\sin 1}{2},D\\text{错} \\] 2022年11月8日 知识点：极限的计算 \\[ \\begin{aligned} \\text{原式}&amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\sqrt{1+2+...+n}-\\sqrt{1+2+...+\\left( n-1 \\right)} \\right] \\\\ &amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\sqrt{\\frac{n\\left( 1+n \\right)}{2}}-\\sqrt{\\frac{\\left( 1+n-1 \\right) n}{2}} \\right] \\\\ &amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\sqrt{\\frac{n\\left( 1+n \\right)}{2}}-\\sqrt{\\frac{n^2}{2}} \\right] \\\\ &amp; =\\lim_{n\\rightarrow \\infty} \\left[ \\frac{\\frac{n+n^2-n^2}{2}}{\\sqrt{\\frac{n\\left( 1+n \\right)}{2}}+\\sqrt{\\frac{n^2}{2}}} \\right] \\\\ &amp; =\\sqrt{2}\\lim_{n\\rightarrow \\infty} \\left[ \\frac{1}{\\sqrt{1+\\frac{1}{n}}+\\sqrt{1}} \\right] \\\\ &amp; =\\frac{\\sqrt{2}}{2} \\end{aligned} \\] 2022年11月9日 知识点：极限的计算 注意根号下x的平方，在x&lt;0时，得到的值是负值 答案： 法一(直接法)： \\[ \\begin{aligned} \\text{原式}&amp; =\\lim_{x\\rightarrow -\\infty} \\frac{\\left( -x \\right) \\left[ \\sqrt{4+\\frac{1}{x}-\\frac{1}{x^2}}-1-\\frac{1}{x} \\right]}{\\left( -x \\right) \\sqrt{1+\\frac{\\sin x}{x^2}}} \\\\ &amp; =\\lim_{x\\rightarrow -\\infty} \\frac{\\sqrt{4+\\frac{1}{x}-\\frac{1}{x^2}}-1-\\frac{1}{x}}{\\sqrt{1+\\frac{\\sin x}{x^2}}}\\left( x&lt;0,\\sqrt{x^2}&lt;0 \\right) \\\\ &amp; =1 \\end{aligned} \\] 法二(抓大头)： \\[ \\begin{aligned} \\text{原式}&amp; =\\lim_{x\\rightarrow -\\infty} \\frac{\\sqrt{4x^2}+x}{\\sqrt{x^2}} \\\\ &amp; =\\lim_{x\\rightarrow -\\infty} \\frac{-2x+x}{-x} \\\\ &amp; =1 \\end{aligned} \\] 2022年11月10日 知识点：判别左右极限 答案： \\[ \\begin{aligned} \\text{原式}&amp; =\\lim_{x\\rightarrow 0^+} \\left( \\frac{2+e^{\\frac{1}{x}}}{1+e^{\\frac{4}{x}}}+\\frac{\\sin x}{\\left| x \\right|} \\right) \\\\ &amp; =\\lim_{x\\rightarrow 0^+} \\left( 0+1 \\right) \\,\\, \\left( e^{\\frac{4}{x}}\\text{比}e^{\\frac{1}{x}}\\text{增长快} \\right) \\\\ &amp; =1 \\\\ \\text{原式}&amp; =\\lim_{x\\rightarrow 0^-} \\left( \\frac{2+e^{\\frac{1}{x}}}{1+e^{\\frac{4}{x}}}+\\frac{\\sin x}{\\left| x \\right|} \\right) \\\\ &amp; =\\lim_{x\\rightarrow 0^-} \\left( \\frac{2+0}{1+0}+\\frac{\\sin x}{-x} \\right) \\\\ &amp; =\\left( 2-1 \\right) \\\\ &amp; =1 \\\\ \\lim_{x\\rightarrow 0^+} \\text{左}&amp;=\\lim_{x\\rightarrow 0^-} \\text{右}=1 \\end{aligned} \\] 2022年11月11日 知识点：四种方法计算极限 答案： 法一（直接法）： \\[ \\begin{aligned} \\text{法一：原式}&amp;=\\lim_{x\\rightarrow \\infty} \\left( \\frac{x^2+x-x^2+x}{\\sqrt{x^2+x}+\\sqrt{x^2-x}} \\right) \\\\ &amp;=\\lim_{x\\rightarrow \\infty} \\left( \\frac{2x}{\\sqrt{x^2+x}+\\sqrt{x^2-x}} \\right) \\\\ &amp;=\\lim_{x\\rightarrow \\infty} \\left( \\frac{2}{\\sqrt{1+\\frac{1}{x}}+\\sqrt{1-\\frac{1}{x}}} \\right) \\\\ &amp;=1 \\end{aligned} \\] 法二（拉格朗日）： \\[ \\text{法二：设}f\\left( x \\right) =\\sqrt{x} \\\\ \\text{根据拉格朗日中值定理，}f\\left( x^2+x \\right) -f\\left( x^2-x \\right) =f\\prime\\left( \\xi \\right) \\left( x^2+x-x^2+x \\right) =2xf\\prime\\left( \\xi \\right) \\text{，}\\xi \\text{介于}x^2+x\\text{与}x^2-x\\text{之间，}\\xi \\sim x^2,f\\prime\\left( \\xi \\right) =\\frac{1}{2\\sqrt{\\xi}} \\\\ \\text{原式}=\\lim_{x\\rightarrow \\infty} 2xf\\prime\\left( \\xi \\right) =\\lim_{x\\rightarrow \\infty} \\frac{x}{\\sqrt{\\xi}}=1 \\] 法三（常见等价无穷小）： \\[ \\begin{aligned} \\text{法三：原式}&amp;=\\lim_{x\\rightarrow \\infty} \\sqrt{x^2-x}\\left[ \\sqrt{1+\\frac{2x}{x^2-x}}-1 \\right] \\\\ &amp;=\\lim_{x\\rightarrow \\infty} \\sqrt{x^2-x}\\cdot \\frac{1}{x}\\cdot \\frac{2x}{x^2-x} \\\\ &amp;=1 \\end{aligned} \\] 法四（等价无穷小相减，减项不等价的话，可以用等价无穷小减）： \\[ \\begin{aligned} \\text{法四：原式}&amp;=\\lim_{x\\rightarrow \\infty} x\\left( \\sqrt{1+\\frac{1}{x}}-\\sqrt{1-\\frac{1}{x}} \\right) \\\\ &amp;=\\lim_{x\\rightarrow \\infty} x\\left( \\left( \\sqrt{1+\\frac{1}{x}}-1 \\right) -\\left( \\sqrt{1-\\frac{1}{x}}-1 \\right) \\right) \\\\ &amp;=\\lim_{x\\rightarrow \\infty} x\\left( \\frac{1}{2x}+\\frac{1}{2x} \\right) \\\\ &amp;=1 \\end{aligned} \\] 2022年11月12日 知识点：三种方法计算极限 答案： 法一（直接法）： \\[ \\begin{aligned} \\text{法一：原式}&amp;=\\lim_{x\\rightarrow 0} \\frac{1+\\tan x-1-\\sin x}{x\\left( 1-\\cos \\right) \\left( \\sqrt{1+\\tan x}+\\sqrt{1+\\sin x} \\right)} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\tan x-\\sin x}{\\frac{1}{2}x^3\\cdot 2} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\tan x-\\sin x}{x^3} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{x+\\frac{x^3}{3}-\\left( x-\\frac{x^3}{6} \\right) +o\\left( x \\right)}{x^3} \\\\ &amp;=\\frac{1}{2} \\end{aligned} \\] 法二（拉格朗日中值定理）： \\[ \\text{法二：设}f\\left( x \\right) =\\sqrt{x}\\text{，根据拉格朗日中值定理，}f\\left( 1+\\tan x \\right) -f\\left( 1+\\sin x \\right) =f\\prime\\left( \\xi \\right) \\left( \\tan x-\\sin x \\right) \\\\ \\text{原式}=\\lim_{x\\rightarrow 0} \\frac{f\\prime\\left( \\xi \\right) \\left( \\tan x-\\sin x \\right)}{\\frac{1}{2}x^3} \\\\ \\xi \\text{在}1+\\tan x\\text{与}1+\\sin x\\text{之间，}x\\text{趋于}0\\text{，}1+\\tan x\\text{与}1+\\sin x\\text{都趋于}0\\text{，根据夹逼定理，}\\xi \\sim 1 \\\\ \\begin{aligned} \\text{原式}&amp;=\\lim_{x\\rightarrow 0} \\frac{\\frac{1}{2}\\left( \\tan x-\\sin x \\right)}{\\frac{1}{2}x^3} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\tan x-\\sin x}{x^3} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{x+\\frac{x^3}{3}-\\left( x-\\frac{x^3}{6} \\right) +o\\left( x \\right)}{x^3} \\\\ &amp;=\\frac{1}{2} \\end{aligned} \\] 法三（等价无穷小）： \\[ \\begin{aligned} \\text{法三：原式}&amp;=\\lim_{x\\rightarrow 0} \\frac{\\sqrt{1+\\tan x}-\\sqrt{1+\\sin x}}{\\frac{1}{2}x^3} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\sqrt{\\tan x+1}-1-\\left( \\sqrt{1+\\sin x}-1 \\right)}{\\frac{1}{2}x^3} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\frac{1}{2}\\tan x-\\frac{1}{2}\\sin x}{\\frac{1}{2}x^3} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\tan x-\\sin x}{x^3} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{x+\\frac{x^3}{3}-\\left( x-\\frac{x^3}{6} \\right) +o\\left( x \\right)}{x^3} \\\\ &amp;=\\frac{1}{2} \\end{aligned} \\] 2022年11月13日 知识点：求极限确定参数 答案： 法一（直接法)： \\[ \\begin{aligned} 原式&amp;=\\lim_{x \\to 0 } \\frac{e^{x^{2}}-1-(cos2x-1) }{ax^{b}} \\\\ &amp;=\\lim_{x \\to 0 } \\frac{x^{2}+2x^{2} }{ax^{b}} \\\\ &amp;= \\lim_{x \\to 0 } \\frac{3x^{2} }{ax^{b}}=1 \\\\ 所以a&amp;=3,b=2 \\end{aligned} \\] 法二（泰勒公式）： \\[ \\begin{aligned} 原式&amp;=\\lim_{x \\to 0 } \\frac{(1+x^{2} )-(1-2x^{2} ) }{ax^{b}} \\\\ &amp;=\\lim_{x \\to 0 } \\frac{3x^{2} }{ax^{b}}=1 \\\\ 所以a&amp;=3,b=2 \\end{aligned} \\] 2022年11月14日 知识点：等价无穷小 答案： \\[ x\\rightarrow 0,\\varphi \\left( x \\right) =0,A\\text{错，若要满足}ABCD\\text{，}\\varphi \\left( x \\right) \\text{不能为}0 \\\\ \\text{可以认为极端情况}\\varphi \\left( x \\right) \\equiv 0\\text{，都错，假如加上条件}\\varphi \\left( x \\right) \\ne 0\\text{则都对} \\\\ \\text{书上的条件是}\\lim_{\\varDelta \\rightarrow 0} \\frac{\\sin \\varDelta}{\\varDelta}=1\\text{，做这种题要注意}\\varphi \\left( x \\right) \\text{的取值} \\] 2022年11月15日 知识点：求极限 答案： \\[ \\begin{aligned} \\text{原式}&amp;=\\lim_{x\\rightarrow 0} \\frac{x+\\frac{x^3}{6}-\\left( x-\\frac{x^3}{3} \\right)}{x-\\frac{x^3}{6}-\\left( x+\\frac{x^3}{3} \\right)} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\frac{x^3}{2}}{-\\frac{x^3}{2}} \\\\ &amp;=-1 \\end{aligned} \\] 2022年11月16日 知识点：求极限 答案： 法一（直接法)： \\[ \\begin{aligned} \\text{原式}&amp;=\\lim_{x\\rightarrow 0} \\frac{\\ln \\frac{x}{\\ln \\left( 1+x \\right)}+1-1}{x} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\frac{x}{\\ln \\left( 1+x \\right)}-1}{x} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\frac{x-\\ln \\left( 1+x \\right)}{\\ln \\left( 1+x \\right)}}{x} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{x-\\ln \\left( 1+x \\right)}{x\\ln \\left( 1+x \\right)} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{x-\\left( x-\\frac{x^2}{2} \\right)}{x^2} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{\\frac{x^2}{2}}{x^2} \\\\ &amp;=\\frac{1}{2} \\end{aligned} \\] 法二（拉格朗日中值定理）： \\[ \\text{原式}=\\lim_{x\\rightarrow 0} \\frac{\\ln x-\\ln \\left( \\ln \\left( 1+x \\right) \\right)}{x},\\text{设}f\\left( x \\right) =\\ln x,\\text{由拉格朗日中值定理得}f\\left( x \\right) -f\\left( \\ln \\left( 1+x \\right) \\right) =f\\prime\\left( \\xi \\right) \\left( x-\\ln \\left( 1+x \\right) \\right) \\\\ \\frac{\\xi}{x}\\text{介于}\\frac{x}{x}\\text{与}\\frac{\\ln \\left( x+1 \\right)}{x}\\text{之间，}x\\text{趋于}0,\\frac{x}{x}\\rightarrow 1,\\frac{\\ln \\left( 1+x \\right)}{x}\\rightarrow 1\\text{，}\\frac{\\xi}{x}\\rightarrow 1,\\text{原式}=\\lim_{x\\rightarrow 0} \\frac{f\\prime\\left( \\xi \\right) \\left( x-\\ln \\left( 1+x \\right) \\right)}{x}=\\lim_{x\\rightarrow 0} \\frac{\\frac{x^2}{2}}{\\xi x}=\\frac{1}{2}\\lim_{x\\rightarrow 0} \\frac{x}{\\xi}=\\frac{1}{x} \\] 2022年11月17日 知识点：小心经错标零 答案： \\[ \\begin{aligned} \\text{原式}&amp;=\\lim_{x\\rightarrow \\infty} \\frac{e^x}{ { e^x }^{^2\\ln \\left( 1+\\frac{1}{x} \\right) } } \\\\ &amp;=\\lim_{x\\rightarrow \\infty} e^{x-x^2\\ln \\left( 1+\\frac{1}{x} \\right)} \\\\ &amp;=\\lim_{x\\rightarrow \\infty} e^{x^2\\left( \\frac{1}{x}-\\ln \\left( 1+\\frac{1}{x} \\right) \\right)} \\\\ &amp;=e^{\\frac{1}{2}} \\end{aligned} \\] \\[ \\text{有二级结论}x-\\ln \\left( 1+x \\right) \\sim \\frac{1}{2}x^2 \\] 2022年11月18日 知识点：求极限 答案： \\[ \\begin{aligned} \\text{设}f\\left( x \\right) &amp;=\\cos x,f\\left( x \\right) -f\\left( \\sin x \\right) =f\\prime\\left( \\xi \\right) \\left( x-\\sin x \\right) ,\\xi \\text{介于}x\\text{与}\\sin x\\text{之间},\\text{所以}\\xi \\rightarrow 0 \\\\ \\text{原式}&amp;=\\lim_{x\\rightarrow 0} \\frac{f\\prime\\left( \\xi \\right) \\left( x-\\sin x \\right)}{x^4} \\\\ &amp;=\\lim_{x\\rightarrow 0} \\frac{-\\sin \\xi \\left( x-\\sin x \\right)}{x^4} \\\\ &amp;=-\\lim_{x\\rightarrow 0} \\frac{x-\\sin x}{x^3} \\\\ &amp;=-\\lim_{x\\rightarrow 0} \\frac{\\frac{1}{6}x^3}{x^3} \\\\ &amp;=-\\frac{1}{6} \\end{aligned} \\] 2022年11月19日 知识点：求极限（偶数年真题） \\[ \\begin{aligned} 设f(x)&amp;=arctanx,f(x+1)-f(x)=f\\prime (\\xi )(x+1-x),f\\prime (\\xi )=\\frac{1}{1+\\xi^2} , \\xi 介于x与x+1之间，x\\rightarrow \\infty ,\\xi \\rightarrow \\infty \\\\ 原式&amp;=\\lim_{x \\to\\infty }x^2[f\\prime (\\xi )] \\\\ &amp;=\\lim_{x \\to\\infty }\\frac{x^2}{1+\\xi ^2} \\\\ &amp;=1 \\end{aligned} \\] 每天更新一道题","categories":[{"name":"考研数学","slug":"考研数学","permalink":"https://mengfanjun020906.github.io/categories/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"考研","slug":"考研","permalink":"https://mengfanjun020906.github.io/tags/%E8%80%83%E7%A0%94/"}]},{"title":"Arduino Uno零基础入门学习笔记——定时器时钟","slug":"Arduino Uno零基础入门学习笔记——定时器时钟","date":"2022-12-20T05:53:20.000Z","updated":"2023-03-24T11:52:10.501Z","comments":true,"path":"2022/12/20/Arduino Uno零基础入门学习笔记——定时器时钟/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/20/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%92%9F/","excerpt":"","text":"一、电路连接 LCD1602IIC LCD1602IIC引脚 Arduino引脚 VCC 5V GND GND SDA A4 SCL A5 我这里的LCD1602是IIC的，所以只需要4根线 这里是定时器时钟，所以不需要在接别的外设 二、代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;MsTimer2.h&gt;#include &lt;Wire.h&gt;#include &lt;LiquidCrystal_I2C.h&gt;unsigned char hour,hour_h,hour_l,minit,minit_h,minit_l,sec,sec_h,sec_l;LiquidCrystal_I2C lcd(0x27,16,2); //配置LCD地址及行列void flashInter()&#123;sec++;if(sec == 60) &#123;minit++;sec = 0; &#125;if(minit == 60)&#123; hour++; minit=0; if(hour == 24) hour = 0;&#125;&#125;void setup()&#123; hour = 22; minit = 59; sec = 55; lcd.init(); //初始化LCD lcd.backlight(); //打开背光lcd.setCursor(2,0); lcd.print(&quot;the time is&quot;);lcd.setCursor(6,1); lcd.print(&quot;:&quot;); lcd.setCursor(9,1); lcd.print(&quot;:&quot;);MsTimer2::set(1000,flashInter); MsTimer2::start(); Serial.begin(9600);&#125;void loop()&#123;hour_h = hour/10;hour_l = hour%10;minit_h = minit/10;minit_l = minit%10;sec_h = sec/10;sec_l = sec%10;lcd.setCursor(4,1);lcd.print(hour_h);lcd.print(hour_l);lcd.setCursor(7,1);lcd.print(minit_h);lcd.print(minit_l);lcd.setCursor(10,1);lcd.print(sec_h);lcd.print(sec_l);Serial.println(sec);&#125; 三、效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——智能时钟(可以显示温湿度)【LCD1602+DS1302+温湿度传感器+红外接收器+LED+蜂鸣器】","slug":"Arduino Uno零基础入门学习笔记——智能时钟(可以显示温湿度)【LCD1602+DS1302+温湿度传感器+红外接收器+LED+蜂鸣器】","date":"2022-12-19T08:53:48.000Z","updated":"2023-03-24T01:15:04.738Z","comments":true,"path":"2022/12/19/Arduino Uno零基础入门学习笔记——智能时钟(可以显示温湿度)【LCD1602+DS1302+温湿度传感器+红外接收器+LED+蜂鸣器】/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/19/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%99%BA%E8%83%BD%E6%97%B6%E9%92%9F(%E5%8F%AF%E4%BB%A5%E6%98%BE%E7%A4%BA%E6%B8%A9%E6%B9%BF%E5%BA%A6)%E3%80%90LCD1602+DS1302+%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8+%E7%BA%A2%E5%A4%96%E6%8E%A5%E6%94%B6%E5%99%A8+LED+%E8%9C%82%E9%B8%A3%E5%99%A8%E3%80%91/","excerpt":"","text":"一、电路连接 需要以下几个外设 LCD1602(IIC驱动) DS1302 1-WIRE温湿度检测器 红外接收器 遥控器 两个LED(一红一蓝) 蜂鸣器 LCD1602IIC LCD1602IIC引脚 Arduino引脚 VCC 5V GND GND SDA A4 SCL A5 我这里的LCD1602是IIC的，所以只需要4根线 ## 1-WIRE温湿度检测器 传感器引脚 Arduino引脚 - GND S 8 + 5V 中间的线是要接5V的 红外接收器 红外接收器引脚 Arduino引脚 - GND + 5V S 11 ## DS1302 DS1302引脚 Arduino引脚 VCC 5V GND GND RST A0(14) DAT A1(15) SCK A2(16) ## 蜂鸣器 蜂鸣器引脚 Arduino引脚 - GND + 5V I/O 5 ## LED LED引脚 Arduino引脚 红色LED 6 蓝色LED 7 二、程序 这里需要下载4个库： dht11 LiquidCrystal_I2C IRremote DS1302 我把他们都传到我的Github里面了：SmartClock 程序里面的红外遥控器是按任何一个按键都可以切换模式，因为我这个遥控器的解码有点问题，可能是这个库的时序问题，大家可以自己个性化自己的按键，改一下就能用了 ## 功能简介 LCD1602屏默认显示温度和湿度，在按下遥控器任何一个按键时，LCD1602屏显示时间，再按下显示温度和湿度。温度湿度还有时间数据都会在串口打印出来，方便调试。在温度高于一定阈值之后，亮红灯，在湿度低于一定阈值后，亮蓝灯。时钟到设定的时间后，蜂鸣器叫10声。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;dht11.h&gt; //引用dht11库文件，使得下面可以调用相关参数#include &lt;Wire.h&gt; #include &lt;LiquidCrystal_I2C.h&gt; //引用I2C库#include &lt;DS1302.h&gt;#include&lt;IRremote.h&gt;#define dht11Pin 8 //定义温湿度针脚号为8号引脚#define ledBlue 6 //定义湿度阈值灯为6号引脚#define ledRed 7 //定义温度阈值灯为7号引脚#define beep 5 //定义蜂鸣器为5号引脚dht11 dht; //实例化一个对象char buf1[50];char buf2[50];LiquidCrystal_I2C lcd(0x27,16,2); //这里是0x27DS1302 rtc(14, 15, 16); //对应DS1302的RST,DAT,CLKint RECV_PIN = 11; //红外线接收器OUTPUT端接在pin 11int Keynum=1;IRrecv irrecv(RECV_PIN); // 定义IRrecv 对象来接收红外线信号decode_results results; //解码结果放在decode_results构造的对象results里void initRTCTime(void)//初始化RTC时钟&#123; rtc.writeProtect(false); //关闭写保护 rtc.halt(false); //清除时钟停止标志 Time t(2022, 12, 19, 16, 25, 50, 4); //新建时间对象 最后参数位星期数据，周日为1，周一为2以此类推 rtc.time(t);//向DS1302设置时间数据&#125;void printTime()//打印时间数据&#123; Time tim = rtc.time(); //从DS1302获取时间数据 snprintf(buf1, sizeof(buf1), &quot;%04d-%02d-%02d &quot;, tim.yr, tim.mon, tim.date ); snprintf(buf2, sizeof(buf2), &quot;%02d:%02d:%02d&quot;, tim.hr, tim.min, tim.sec); Serial.println(buf1); Serial.println(buf2);&#125;void setup() //初始化函数，只执行一次&#123; Serial.begin(9600); //设置波特率参数 pinMode(dht11Pin, OUTPUT); //通过定义将Arduino开发板上dht11Pin引脚(8号口)的工作模式转化为输出模式 pinMode(ledBlue, OUTPUT); pinMode(ledRed, OUTPUT); pinMode(beep, OUTPUT); lcd.init(); // 初始化LCD lcd.backlight(); //设置LCD背景等亮 initRTCTime(); irrecv.enableIRIn(); // 启动红外解码 delay(2000);&#125;void loop() //loop函数，重复循环执行&#123; if (irrecv.decode(&amp;results)!=0) &#123; delay(500); Keynum++; delay(500); lcd.clear(); if(Keynum&gt;=3) &#123; Keynum=1; &#125; irrecv.resume(); &#125; switch(Keynum) &#123; case 1: SerialTem();ther();TemJudge();alarm();break; case 2: printTime();TemJudge(); Time tim = rtc.time(); //从DS1302获取时间数据 lcd.setCursor(0,0); lcd.print(buf1); lcd.setCursor(0,1); lcd.print(buf2); alarm(); break; default: break; &#125; &#125;void ther()//温湿度计&#123; int tol = dht.read(dht11Pin); //将读取到的值赋给tol int temp = (float)dht.temperature; //将温度值赋值给temp int humi = (float)dht.humidity; //将湿度值赋给humi lcd.setCursor(0,0); lcd.print(&quot;Tem:&quot;); lcd.setCursor(4,0); lcd.print(temp); lcd.setCursor(6,0); lcd.print(&quot;C&quot;); lcd.setCursor(0,1); lcd.print(&quot;Hum:&quot;); lcd.setCursor(4,1); lcd.print(humi); lcd.setCursor(6,1); lcd.print(&quot;%&quot;);&#125;void TemJudge()&#123; int tol = dht.read(dht11Pin); //将读取到的值赋给tol int temp = (float)dht.temperature; //将温度值赋值给temp int humi = (float)dht.humidity; //将湿度值赋给humi if(temp&gt;=20)//假如温度高于20度亮红灯 &#123; digitalWrite(ledBlue,HIGH); &#125; else digitalWrite(ledBlue,LOW); if(humi&gt;=34)//假如湿度高于34%亮蓝灯 &#123; digitalWrite(ledRed,HIGH); &#125; else digitalWrite(ledRed,LOW);&#125;void alarm()&#123; digitalWrite(beep,HIGH); int alarm_hr=16;//设置闹钟小时 int alarm_min=26;//设置闹钟分钟 int alarm_sec=0;//设置闹钟秒 Time tim = rtc.time(); //从DS1302获取时间数据 snprintf(buf2, sizeof(buf2), &quot;%02d:%02d:%02d&quot;, tim.hr, tim.min, tim.sec); if((tim.hr==alarm_hr)&amp;&amp;(tim.min==alarm_min)&amp;&amp;(tim.sec==alarm_sec)) &#123; for(int i=0;i&lt;20;i++) &#123; digitalWrite(beep,LOW); delay(100); digitalWrite(beep,HIGH); delay(100); &#125; &#125;&#125;void SerialTem()//串口打印温度湿度&#123; int tol = dht.read(dht11Pin); //将读取到的值赋给tol int temp = (float)dht.temperature; //将温度值赋值给temp int humi = (float)dht.humidity; //将湿度值赋给humi Serial.print(&quot;Temperature:&quot;); //在串口打印出Tempeature: Serial.print(temp); //在串口打印温度结果 Serial.println(&quot;.C&quot;); //在串口打印出℃ Serial.print(&quot;Humidity:&quot;); //在串口打印出Humidity: Serial.print(humi); //在串口打印出湿度结果 Serial.println(&quot;%&quot;); //在串口打印出% &#125; # 三、效果","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——在LCD1602屏上显示温度和湿度","slug":"Arduino Uno零基础入门学习笔记——在LCD1602屏上显示温度和湿度","date":"2022-12-19T06:38:54.000Z","updated":"2023-03-24T11:53:14.390Z","comments":true,"path":"2022/12/19/Arduino Uno零基础入门学习笔记——在LCD1602屏上显示温度和湿度/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/19/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9C%A8LCD1602%E5%B1%8F%E4%B8%8A%E6%98%BE%E7%A4%BA%E6%B8%A9%E5%BA%A6%E5%92%8C%E6%B9%BF%E5%BA%A6/","excerpt":"","text":"一、电路连接 LCD1602IIC LCD1602IIC引脚 Arduino引脚 VCC 5V GND GND SDA A4 SCL A5 我这里的LCD1602是IIC的，所以只需要4根线 ## 1-WIRE 传感器引脚 Arduino引脚 - GND S 8 + 5V 中间的线是要接5V的 二、程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;dht11.h&gt; //引用dht11库文件，使得下面可以调用相关参数#include &lt;Wire.h&gt; #include &lt;LiquidCrystal_I2C.h&gt; //引用I2C库#define dht11Pin 8 //定义温湿度针脚号为8号引脚dht11 dht; //实例化一个对象LiquidCrystal_I2C lcd(0x27,16,2); //这里是0x27void setup() //初始化函数，只执行一次&#123; Serial.begin(9600); //设置波特率参数 pinMode(dht11Pin, OUTPUT); //通过定义将Arduino开发板上dht11Pin引脚(8号口)的工作模式转化为输出模式 lcd.init(); // 初始化LCD lcd.backlight(); //设置LCD背景等亮 lcd.setCursor(0,0); lcd.print(&quot; Thermometer &quot;); delay(2000); lcd.clear();&#125;void loop() //loop函数，重复循环执行&#123; SerialTem(); ther(); delay(1000); //延时1秒&#125;void ther()//温湿度计&#123; int tol = dht.read(dht11Pin); //将读取到的值赋给tol int temp = (float)dht.temperature; //将温度值赋值给temp int humi = (float)dht.humidity; //将湿度值赋给humi lcd.setCursor(0,0); lcd.print(&quot;Tem:&quot;); lcd.setCursor(4,0); lcd.print(temp); lcd.setCursor(6,0); lcd.print(&quot;C&quot;); lcd.setCursor(0,1); lcd.print(&quot;Hum:&quot;); lcd.setCursor(4,1); lcd.print(humi); lcd.setCursor(6,1); lcd.print(&quot;%&quot;);&#125;void SerialTem()//串口打印温度湿度&#123; int tol = dht.read(dht11Pin); //将读取到的值赋给tol int temp = (float)dht.temperature; //将温度值赋值给temp int humi = (float)dht.humidity; //将湿度值赋给humi Serial.print(&quot;Temperature:&quot;); //在串口打印出Tempeature: Serial.print(temp); //在串口打印温度结果 Serial.println(&quot;.C&quot;); //在串口打印出℃ Serial.print(&quot;Humidity:&quot;); //在串口打印出Humidity: Serial.print(humi); //在串口打印出湿度结果 Serial.println(&quot;%&quot;); //在串口打印出% &#125; 三、效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino UNO新手零基础入门学习博客汇总","slug":"Arduino UNO新手零基础入门学习博客汇总","date":"2022-12-17T09:26:27.000Z","updated":"2023-03-24T11:44:05.967Z","comments":true,"path":"2022/12/17/Arduino UNO新手零基础入门学习博客汇总/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/17/Arduino%20UNO%E6%96%B0%E6%89%8B%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/","excerpt":"","text":"写在开头 最近在上Arduino的课，可以说Arduino对新手来说非常友好了，因为相比于51和32，Arduino的库函数下载就好，不需要自己去写，就很方便 我的硬件设备 Arduino实验盒里面 博客汇总 博客内容大多数以实际案例为主，基本都是电路+代码+演示效果的结构 &gt; 1.Arduino Uno零基础入门学习笔记——第一个程序 &gt; 2.Arduino Uno零基础入门学习笔记——变量与函数 &gt; 3.Arduino Uno零基础入门学习笔记——点亮一个LED &gt; 4.Arduino Uno零基础入门学习笔记——按键开关 &gt; 5.Arduino Uno零基础入门学习笔记——流水灯 &gt; 6.Arduino Uno零基础入门学习笔记——模拟输出 &gt; 7.Arduino Uno零基础入门学习笔记——红绿灯 &gt; 8.Arduino Uno零基础入门学习笔记——PWM控制LED &gt; 9.Arduino Uno零基础入门学习笔记——智能门锁(无舵机) &gt; 10.Arduino Uno零基础入门学习笔记——SOS摩斯密码LED+蜂鸣器 &gt; 11.Arduino Uno零基础入门学习笔记——三针脚声音传感器 &gt; 12.Arduino Uno零基础入门学习笔记——霍尔传感器MH Sensor &gt; 13.Arduino Uno零基础入门学习笔记——LCD1602屏+PIR运动检测器 &gt; 14.Arduino Uno零基础入门学习笔记——LCD1602屏+DS1302时钟 &gt; 15.Arduino Uno零基础入门学习笔记——8229BSF触摸键盘 在更新博客后，这一篇汇总博客会同步更新","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——8229BSF触摸键盘","slug":"Arduino Uno零基础入门学习笔记——8229BSF触摸键盘","date":"2022-12-17T07:36:34.000Z","updated":"2023-03-24T01:11:37.637Z","comments":true,"path":"2022/12/17/Arduino Uno零基础入门学习笔记——8229BSF触摸键盘/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/17/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%948229BSF%E8%A7%A6%E6%91%B8%E9%94%AE%E7%9B%98/","excerpt":"","text":"一、电路连接 学校发的Arduino实验盒里还有个矩阵键盘，一开始看到了SDA和SCL感觉是IIC驱动的，但是去Arduino官方论坛看了看，发现好像那个是SDO？，他并不是IIC驱动的，后来从Github上找了一个能用的库 矩阵键盘 矩阵键盘引脚 Arduino引脚 V 5V G GND SDO 9 SCL 8 二、代码 先要下载一个TTP229的库 TTP229 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;TTP229.h&quot; TTP229 ttp229(8,9);uint8_t TouchPadKeyValue = 0; void setup()&#123; Serial.begin(115200);&#125; void loop()&#123; TouchPadKeyValue = ttp229.ReadKey16(); if (TouchPadKeyValue == 1) &#123; Serial.println(&quot;1&quot;); &#125; else if (TouchPadKeyValue == 2) &#123; Serial.println(&quot;2&quot;); &#125; else if (TouchPadKeyValue == 3) &#123; Serial.println(&quot;3&quot;); &#125; else if (TouchPadKeyValue == 4) &#123; Serial.println(&quot;A&quot;); &#125; else if (TouchPadKeyValue == 5) &#123; Serial.println(&quot;4&quot;); &#125; else if (TouchPadKeyValue == 6) &#123; Serial.println(&quot;5&quot;); &#125; else if (TouchPadKeyValue == 7) &#123; Serial.println(&quot;6&quot;); &#125; else if (TouchPadKeyValue == 8) &#123; Serial.println(&quot;B&quot;); &#125; else if (TouchPadKeyValue == 9) &#123; Serial.println(&quot;7&quot;); &#125; else if (TouchPadKeyValue == 10) &#123; Serial.println(&quot;8&quot;); &#125; else if (TouchPadKeyValue == 11) &#123; Serial.println(&quot;9&quot;); &#125; else if (TouchPadKeyValue == 12) &#123; Serial.println(&quot;C&quot;); &#125; else if (TouchPadKeyValue == 13) &#123; Serial.println(&quot;*&quot;); &#125; else if (TouchPadKeyValue == 14) &#123; Serial.println(&quot;0&quot;); &#125; else if (TouchPadKeyValue == 15) &#123; Serial.println(&quot;#&quot;); &#125; else if (TouchPadKeyValue == 16) &#123; Serial.println(&quot;D&quot;); &#125; else if (false) &#123; &#125; &#125; 三、效果 可能是这个触摸的原因，误触率实在太高了，根本就没法使用","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——LCD1602屏+DS1302时钟","slug":"Arduino Uno零基础入门学习笔记——LCD1602屏+DS1302时钟","date":"2022-12-15T09:31:50.000Z","updated":"2023-03-24T11:54:47.257Z","comments":true,"path":"2022/12/15/Arduino Uno零基础入门学习笔记——LCD1602屏+DS1302时钟/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/15/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94LCD1602%E5%B1%8F+DS1302%E6%97%B6%E9%92%9F/","excerpt":"","text":"我是在这篇文章的基础上进行修改的，那篇文章只进行了串口的打印，并没有在LCD1602上显示 # 一、电路连接 ## LCD1602IIC LCD1602IIC引脚 Arduino引脚 VCC 5V GND GND SDA A4 SCL A5 我这里的LCD1602是IIC的，所以只需要4根线 ## DS1302 DS1302引脚 Arduino引脚 VCC 5V GND GND RST A0(14) DAT A1(15) SCK A2(16) 二、代码 记得提前安装DS1302的库 DS1302 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;DS1302.h&gt;#include &lt;Wire.h&gt; #include &lt;LiquidCrystal_I2C.h&gt; //引用I2C库 char buf1[50];char buf2[50];//设置LCD1602设备地址，这里的地址是0x27，一般是0x20，或者0x27，具体看模块手册LiquidCrystal_I2C lcd(0x27,16,2); //这里是0x27DS1302 rtc(14, 15, 16); //对应DS1302的RST,DAT,CLKvoid initRTCTime(void)//初始化RTC时钟&#123; rtc.writeProtect(false); //关闭写保护 rtc.halt(false); //清除时钟停止标志 Time t(2022, 12, 15, 17, 21, 50, 4); //新建时间对象 最后参数位星期数据，周日为1，周一为2以此类推 rtc.time(t);//向DS1302设置时间数据&#125;void printTime()//打印时间数据&#123; Time tim = rtc.time(); //从DS1302获取时间数据 snprintf(buf1, sizeof(buf1), &quot;%04d-%02d-%02d &quot;, tim.yr, tim.mon, tim.date ); snprintf(buf2, sizeof(buf2), &quot;%02d:%02d:%02d&quot;, tim.hr, tim.min, tim.sec); Serial.println(buf1); Serial.println(buf2);&#125;void setup() &#123; Serial.begin(9600); //新模块上电需要设置一次当前时间， //下载完成后需屏蔽此函数再次下载，否则每次上电都会初始化时间数据 initRTCTime(); lcd.init(); // 初始化LCD lcd.backlight(); //设置LCD背景等亮 lcd.setCursor(0,0); lcd.print(&quot; Clock &quot;); delay(2000); lcd.clear();&#125;void loop() &#123; printTime(); delay(1000); Time tim = rtc.time(); //从DS1302获取时间数据 lcd.setCursor(0,0); lcd.print(buf1); lcd.setCursor(0,1); lcd.print(buf2);&#125; 三、效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——LCD1602屏+PIR运动检测器","slug":"Arduino Uno零基础入门学习笔记——LCD1602屏+PIR运动检测器","date":"2022-12-15T09:01:15.000Z","updated":"2023-03-24T11:54:56.921Z","comments":true,"path":"2022/12/15/Arduino Uno零基础入门学习笔记——LCD1602屏+PIR运动检测器/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/15/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94LCD1602%E5%B1%8F+PIR%E8%BF%90%E5%8A%A8%E6%A3%80%E6%B5%8B%E5%99%A8/","excerpt":"","text":"一、电路连接 PIR运动检测器 PIR运动检测器引脚 Arduino引脚 VCC 5V GND GND OUT A0(14) 在这里插入图片描述 LCD1602IIC LCD1602IIC引脚 Arduino引脚 VCC 5V GND GND SDA A4 SCL A5 我这里的LCD1602是IIC的，所以只需要4根线 在这里插入图片描述 LED LED引脚 Arduino引脚 正极 7 阴极 GND 二、代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;Wire.h&gt; #include &lt;LiquidCrystal_I2C.h&gt; //引用I2C库 //设置LCD1602设备地址，这里的地址是0x27，一般是0x20，或者0x27，具体看模块手册LiquidCrystal_I2C lcd(0x27,16,2); //这里是0x27#define PIR_sensor 14#define ledpin 7void setup() &#123; pinMode(PIR_sensor, INPUT); lcd.init(); // 初始化LCD lcd.backlight(); //设置LCD背景等亮 lcd.setCursor(0,0); lcd.print(&quot; Automatic &quot;); lcd.setCursor(0,1); lcd.print(&quot; Lights opener &quot;); delay(3000); lcd.clear();&#125;void loop() &#123; if(digitalRead(PIR_sensor)) &#123; lcd.setCursor(0,0); lcd.print(&quot;Movement Detected&quot;); lcd.setCursor(0, 1); lcd.print(&quot; Lights On &quot;); digitalWrite(ledpin, HIGH); delay(1000); lcd.clear(); lcd.print(&quot; Lights Off &quot;); digitalWrite(ledpin, LOW); delay(1000); &#125; else &#123; lcd.setCursor(0,0); lcd.print(&quot; No Movement &quot;); lcd.setCursor(0,1); lcd.print(&quot; Lights Off &quot;); digitalWrite(ledpin, LOW); &#125;&#125; 三、效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——霍尔传感器MH Sensor","slug":"Arduino Uno零基础入门学习笔记——霍尔传感器MH Sensor","date":"2022-12-15T06:34:33.000Z","updated":"2023-03-24T11:52:23.643Z","comments":true,"path":"2022/12/15/Arduino Uno零基础入门学习笔记——霍尔传感器MH Sensor/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/15/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9C%8D%E5%B0%94%E4%BC%A0%E6%84%9F%E5%99%A8MH%20Sensor/","excerpt":"","text":"一、电路接线 霍尔传感器引脚 Arduino引脚 VCC 5V GND GND D0 7 A0 A0 二、程序 12345678910111213141516#define Moisture A0#define D0 7void setup() &#123; pinMode(Moisture,INPUT); pinMode(D0,INPUT); Serial.begin(9600); &#125; void loop() &#123; Serial.print(&quot;Moisture=&quot;);//湿度 Serial.print(analogRead(Moisture)); Serial.print(&quot;|D0=&quot;); Serial.println(digitalRead(D0)); delay(1000);&#125; 三、效果 在这里插入图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——三针脚声音传感器","slug":"Arduino Uno零基础入门学习笔记——三针脚声音传感器","date":"2022-12-15T06:10:27.000Z","updated":"2023-03-24T11:53:05.079Z","comments":true,"path":"2022/12/15/Arduino Uno零基础入门学习笔记——三针脚声音传感器/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/15/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%B8%89%E9%92%88%E8%84%9A%E5%A3%B0%E9%9F%B3%E4%BC%A0%E6%84%9F%E5%99%A8/","excerpt":"","text":"一、电路接线 声音传感器 声音传感器引脚 Arduino引脚 VCC 5V GND GND OUT 6 LED LED引脚 Arduino引脚 正极 8 GND GND 二、代码 1234567891011121314151617181920212223int val;int ledpin=8;int voicepin=6;void setup() &#123; Serial.begin(9600); pinMode(voicepin,INPUT); pinMode(ledpin,OUTPUT);&#125; void loop()&#123; val = digitalRead(voicepin); Serial.println(val); delay(500); digitalWrite(ledpin,HIGH); if (val == LOW) // no voice &#123; digitalWrite(ledpin,LOW); // clear led &#125; else &#123; digitalWrite(ledpin,HIGH); // set led &#125;&#125; 如果没声音LED不亮 如果有声音LED亮","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"AArduino Uno零基础入门学习笔记——SOS摩斯密码LED+蜂鸣器","slug":"Arduino Uno零基础入门学习笔记——SOS摩斯密码LED+蜂鸣器","date":"2022-12-14T11:30:38.000Z","updated":"2023-03-24T11:55:07.319Z","comments":true,"path":"2022/12/14/Arduino Uno零基础入门学习笔记——SOS摩斯密码LED+蜂鸣器/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/14/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SOS%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81LED+%E8%9C%82%E9%B8%A3%E5%99%A8/","excerpt":"","text":"一、电路图 在这里插入图片描述 二、程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344int led=5;int beep=8;void setup() &#123; pinMode(beep,OUTPUT); pinMode(led,OUTPUT);&#125;void loop() &#123; sos();&#125;void sos()&#123; for(int a=0;a&lt;3;a++) &#123; digitalWrite(beep,LOW); digitalWrite(led,HIGH); delay(200); digitalWrite(beep,HIGH); digitalWrite(led,LOW); delay(200); &#125; delay(2000); for(int b=0;b&lt;3;b++) &#123; digitalWrite(beep,LOW); digitalWrite(led,HIGH); delay(1000); digitalWrite(beep,HIGH); digitalWrite(led,LOW); delay(1000); &#125; for(int b=0;b&lt;3;b++) &#123; digitalWrite(beep,LOW); digitalWrite(led,HIGH); delay(200); digitalWrite(beep,HIGH); digitalWrite(led,LOW); delay(200); &#125; delay(2000);&#125; 三、效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——智能门锁(无舵机)","slug":"Arduino Uno零基础入门学习笔记——智能门锁(无舵机)","date":"2022-12-14T07:44:56.000Z","updated":"2023-03-24T11:53:26.450Z","comments":true,"path":"2022/12/14/Arduino Uno零基础入门学习笔记——智能门锁(无舵机)/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/14/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81(%E6%97%A0%E8%88%B5%E6%9C%BA)/","excerpt":"","text":"一、电路接线 RFID-RC522 RC522引脚号 Arduino板引脚号 3V3 3.3V GND GND MISO 12 MOSI 13 SCK 13 SDA 10 蜂鸣器 蜂鸣器引脚号 Arduino板引脚号 VCC 5V GND GND I/O 8 LED LED引脚号 Arduino板引脚号 LedRed 5 LedGreen 6 二、代码 源代码来源：DIY打造智能门禁锁RFIDRC522原理与应用 功能：假如卡可以进入，则绿灯闪烁，蜂鸣器叫两声 假如卡不可以进入，则红灯闪烁，蜂鸣器长鸣 记得安装RFID的库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;SPI.h&gt; #include &lt;RFID.h&gt;RFID rfid(10, 9); unsigned char status; unsigned char str[MAX_LEN]; String accessGranted [2] = &#123;&quot;143043708&quot;, &quot;123035296&quot;&#125;; //序列号位置int accessGrantedSize = 2; //几个卡号 boolean locked = true;int redLEDPin = 5;int greenLEDPin = 6;int pinBeep= 8;void setup() &#123; Serial.begin(9600); //串口开启波特率9600 SPI.begin(); //通过SPI与读卡器连接 rfid.init(); //RFID定义 pinMode(redLEDPin, OUTPUT); //LED闪烁表示开启 pinMode(greenLEDPin, OUTPUT); pinMode(pinBeep, OUTPUT); digitalWrite(pinBeep, HIGH); digitalWrite(redLEDPin, HIGH); delay(200); digitalWrite(greenLEDPin, HIGH); delay(200); digitalWrite(redLEDPin, LOW); delay(200); digitalWrite(greenLEDPin, LOW); Serial.println(&quot;Please put the card to the reader&quot;);&#125; void loop() &#123; if (rfid.findCard(PICC_REQIDL, str) == MI_OK) //等待卡被放到读卡器上 Serial.println(&quot;Card found&quot;); String temp = &quot;&quot;; //储存一个值到temp中 if (rfid.anticoll(str) == MI_OK) //读取卡的串口号 &#123; Serial.print(&quot;The card&#x27;s ID number is : &quot;); for (int i = 0; i &lt; 4; i++) //记录下temp值 &#123; temp = temp + (0x0F &amp; (str[i] &gt;&gt; 4)); //保留前四位 temp = temp + (0x0F &amp; str[i]); //保留后四位 &#125; Serial.println (temp); checkAccess (temp); //检查此卡能否接入 &#125; rfid.selectTag(str); //锁卡防止冗余读卡 rfid.halt();&#125;void checkAccess (String temp) //检查卡能否被读写的函数&#123; boolean granted = false; for (int i=0; i &lt;= (accessGrantedSize-1); i++) //在已储存的卡号中检测此卡能否接入 &#123; if(accessGranted[i] == temp) //如果卡号允许被接入则开锁 &#123; Serial.println (&quot;Access Granted&quot;); granted = true; //蜂鸣器叫两下 for(int i=0;i&lt;2;i++) &#123; digitalWrite(pinBeep,LOW); delay(100); digitalWrite(pinBeep,HIGH); delay(100); &#125; //绿灯闪烁 digitalWrite(greenLEDPin, HIGH); delay(200); digitalWrite(greenLEDPin, LOW); delay(200); digitalWrite(greenLEDPin, HIGH); delay(200); digitalWrite(greenLEDPin, LOW); delay(200); &#125; &#125; if (granted == false) &#123; Serial.println (&quot;Access Denied&quot;); //蜂鸣器长鸣 digitalWrite(pinBeep,LOW); delay(1000); digitalWrite(pinBeep,HIGH); delay(100); //红灯闪烁 digitalWrite(redLEDPin, HIGH); delay(200); digitalWrite(redLEDPin, LOW); delay(200); digitalWrite(redLEDPin, HIGH); delay(200); digitalWrite(redLEDPin, LOW); delay(200); &#125;&#125; # 三、效果 我有两张卡，一张可以接入，一张不可以接入","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——PWM控制LED","slug":"Arduino Uno零基础入门学习笔记——PWM控制LED","date":"2022-12-14T01:58:26.000Z","updated":"2023-03-24T05:58:23.534Z","comments":true,"path":"2022/12/14/Arduino Uno零基础入门学习笔记——PWM控制LED/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/14/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94PWM%E6%8E%A7%E5%88%B6LED/","excerpt":"","text":"一、电路图 # 二、程序 123456789101112131415161718192021void setup() &#123; pinMode(9,OUTPUT); Serial.begin(9600);&#125;void loop() &#123;//由暗到明 for(int i=0;i&lt;=255;i++) &#123; analogWrite(9,i); Serial.println(i); &#125; //由明到暗 for(int i=255;i&gt;=0;i--) &#123; analogWrite(9,i); Serial.println(i); &#125; &#125; 三、效果 在这里插入图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——红绿灯","slug":"Arduino Uno零基础入门学习笔记——红绿灯","date":"2022-12-13T10:46:31.000Z","updated":"2023-03-24T11:52:18.424Z","comments":true,"path":"2022/12/13/Arduino Uno零基础入门学习笔记——红绿灯/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/13/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BA%A2%E7%BB%BF%E7%81%AF/","excerpt":"","text":"一、电路图 在这里插入图片描述 二、代码 管脚号 功能 D2 红灯 D3 绿灯 D4 黄灯 1234567891011121314151617181920212223242526void setup() &#123; pinMode(2,OUTPUT); pinMode(3,OUTPUT); pinMode(4,OUTPUT);&#125;void loop() &#123; digitalWrite(2,HIGH); digitalWrite(3,LOW); digitalWrite(4,LOW); delay(3000); for(int i=0;i&lt;7;i++) &#123; digitalWrite(2,LOW); digitalWrite(3,LOW); digitalWrite(4,HIGH); delay(200); digitalWrite(2,LOW); digitalWrite(3,LOW); digitalWrite(4,LOW); delay(200); &#125; digitalWrite(2,LOW); digitalWrite(3,HIGH); digitalWrite(4,LOW); delay(4000);&#125; 改良了一下 12345678910111213141516171819202122232425262728293031323334353637383940#define red 1#define yellow 2#define green 3void setup() &#123; pinMode(2,OUTPUT); pinMode(3,OUTPUT); pinMode(4,OUTPUT);&#125;void loop() &#123; trafficLights(red); trafficLights(yellow); trafficLights(green);&#125;void trafficLights(int light)&#123; switch(light)&#123; case 1: digitalWrite(2,HIGH); digitalWrite(3,LOW); digitalWrite(4,LOW); delay(4000); case 2: for(int i=0;i&lt;7;i++) &#123; digitalWrite(2,LOW); digitalWrite(3,LOW); digitalWrite(4,HIGH); delay(200); digitalWrite(2,LOW); digitalWrite(3,LOW); digitalWrite(4,LOW); delay(200); &#125; case 3: digitalWrite(2,LOW); digitalWrite(3,HIGH); digitalWrite(4,LOW); delay(4000); break; &#125;&#125; 三、实现效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——模拟输出","slug":"Arduino Uno零基础入门学习笔记——模拟输出","date":"2022-12-13T08:26:52.000Z","updated":"2023-03-24T11:52:38.401Z","comments":true,"path":"2022/12/13/Arduino Uno零基础入门学习笔记——模拟输出/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/13/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%87%BA/","excerpt":"","text":"一、电路图 在这里插入图片描述 二、程序 1234567891011121314151617181920212223242526272829boolean pushButton1;boolean pushButton2;int ledpin=9;int brightness=128;void setup() &#123; // put your setup code here, to run once: pinMode(2,INPUT_PULLUP); pinMode(8,INPUT_PULLUP); pinMode(ledpin,OUTPUT); Serial.begin(9600);&#125;void loop() &#123; // put your main code here, to run repeatedly: pushButton1=digitalRead(2);//变暗按键 pushButton2=digitalRead(8);//变亮按键 if(!pushButton1 &amp;&amp; brightness &gt; 0) &#123; brightness--; &#125; if(!pushButton2 &amp;&amp; brightness &lt; 255) &#123; brightness++; &#125; analogWrite(ledpin,brightness); Serial.println(brightness); delay(10); &#125; 三、结果 按下按键，灯的亮度发生了变化","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——流水灯","slug":"Arduino Uno零基础入门学习笔记——流水灯","date":"2022-12-13T07:30:54.000Z","updated":"2023-03-24T11:52:30.953Z","comments":true,"path":"2022/12/13/Arduino Uno零基础入门学习笔记——流水灯/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/13/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%81%E6%B0%B4%E7%81%AF/","excerpt":"","text":"一、电路图 在这里插入图片描述 二、程序 123456789101112131415161718192021222324int base=2;int num=6;int i=0;void setup() &#123; for(i=base;i&lt;base+num;i++) &#123; pinMode(i,OUTPUT); &#125;&#125;void loop() &#123; for(i=base;i&lt;base+num;i++) &#123; digitalWrite(i,LOW); delay(200); &#125; for(i=base;i&lt;base+num;i++) &#123; digitalWrite(i,HIGH); delay(200); &#125;&#125; 三、效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——按键开关","slug":"Arduino Uno零基础入门学习笔记——按键开关","date":"2022-12-13T01:18:39.000Z","updated":"2023-03-24T11:50:32.037Z","comments":true,"path":"2022/12/13/Arduino Uno零基础入门学习笔记——按键开关/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/13/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8C%89%E9%94%AE%E5%BC%80%E5%85%B3/","excerpt":"","text":"一、按键介绍 按键相连不同侧，同侧不相连 按键是一种数字输入，可以识别两种状态 HIGH LOW 二、搭建电路 上拉电阻为10K 三、代码 123456789101112131415void setup() &#123; // initialize serial communication at 9600 bits per second: Serial.begin(9600);//串口通信初始，波特率为9600,Serial.begin()表示用的是Serial库里面的begin函数 // make the pushbutton&#x27;s pin an input: pinMode(pushButton, INPUT);&#125;// the loop routine runs over and over again forever:void loop() &#123; // read the input pin: int buttonState = digitalRead(pushButton)//读取引脚2的状态，digitalRead()可以读取引脚是HIGH还是LOW // print out the state of the button: Serial.println(buttonState);//打印串口数据，HIGH为1 LOW为0 delay(1); // delay in between reads for stability&#125;","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——点亮一个LED","slug":"Arduino Uno零基础入门学习笔记——点亮一个LED","date":"2022-12-12T08:11:05.000Z","updated":"2023-03-24T12:17:29.604Z","comments":true,"path":"2022/12/12/Arduino Uno零基础入门学习笔记——点亮一个LED/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/12/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%82%B9%E4%BA%AE%E4%B8%80%E4%B8%AALED/","excerpt":"","text":"文中的部分图片来源视频教程：【太极创客】零基础入门学用Arduino 第一部分 合辑 一、认识LED LED=Lighting Emitting Diode 长的那一边是正极，短的那一边是负极 工作时，LED产生2V的压降 二、接线 在Fritzing中接好线 Arduino的引脚输出5V，而LED需要2V，所以电阻要分压3V 三、使用面包板搭建LED电路 在这里插入图片描述 四、代码 12345678910111213// the setup function runs once when you press reset or power the boardvoid setup() &#123; // initialize digital pin 5 as an output. pinMode(5, OUTPUT);&#125;// the loop function runs over and over again forevervoid loop() &#123; digitalWrite(5, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(5, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second&#125; 五、效果 请添加图片描述","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"Arduino Uno零基础入门学习笔记——变量与函数","slug":"Arduino Uno零基础入门学习笔记——变量与函数","date":"2022-12-12T07:29:03.000Z","updated":"2023-03-24T11:51:50.311Z","comments":true,"path":"2022/12/12/Arduino Uno零基础入门学习笔记——变量与函数/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/12/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0/","excerpt":"","text":"一、创建变量 1int currentTemperature; 整数型变量 变量名字 分号 使用驼峰命名法对进行命名 有些程序员喜欢全部小写，有些程序员喜欢用下划线，所以如果要写一个my name的变量，他们常用的写法会有myname、my_name、MyName或者myName。这样的命名规则不适合所有程序员阅读，而利用驼峰命名法来表示，可以增加程序可读性。 例如，下面是分别用骆驼式命名法和下划线法命名的同一个函数： printEmployeePaychecks(); print_employee_paychecks(); 第一个函数名使用了骆驼式命名法——函数名中的每一个逻辑断点都有一个大写字母来标记；第二个函数名使用了下划线法----函数名中的每一个逻辑断点都有一个下划线来标记。 骆驼式命名法在许多新的函数库和Microsoft Windows这样的环境中使用得相当多。另一方面，下划线法是c出现后开始流行起来的，在许多旧的程序和UNIX这样的环境中，它的使用非常普遍。 # 二、函数 一些常用的函数例如delay()已经在系统中写好，只需上官方网站查看 Arduino函数 三、delay的例子 123456789101112int ledPin = 13; // LED 连接13脚void setup() &#123; pinMode(ledPin, OUTPUT); // 设置ledpin为输出模式&#125;void loop() &#123; digitalWrite(ledPin, HIGH); // 打开led delay(1000); // 等1s digitalWrite(ledPin, LOW); // 关闭led delay(1000); // 等1s&#125; 分析函数 1pinMode(); 可以将引脚配制成以下三种模式 输出(OUTPUT)模式 输入(INPUT)模式 输入上拉(INPUT_PULLUP)模式(Arduino1.0.1以后才有) 1digitalWrite(); 写一个高或低的值到数字引脚。 如果引脚已配置为带pinMode()的OUTPUT，其电压将被设置为相应的值:5V(或3.3V板上的3.3V)为HIGH, 0V(地)为LOW。 如果引脚配置为INPUT, digitalWrite()将启用(HIGH)或禁用(LOW)输入引脚的内部上拉。建议将pinMode()设置为INPUT_PULLUP，使能内部上拉电阻。有关更多信息，请参阅数字引脚教程。 如果你没有将pinMode()设置为OUTPUT，并且将一个LED连接到一个引脚，当调用digitalWrite(HIGH)时，LED可能会显示为暗。如果没有显式设置pinMode()， digitalWrite()将启用内部的上拉电阻，这就像一个大的限流电阻。 总结 可以看出Arduino对于有c语言基础的同学是真的简单，只需要认真读官方文档就好","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"第七届NVIDIA Sky Hackathon项目报告书","slug":"第七届NVIDIA Sky Hackathon项目报告书","date":"2022-12-12T06:51:16.000Z","updated":"2023-04-04T08:50:59.428Z","comments":true,"path":"2022/12/12/第七届NVIDIA Sky Hackathon项目报告书/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/12/%E7%AC%AC%E4%B8%83%E5%B1%8ANVIDIA%20Sky%20Hackathon%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A%E4%B9%A6/","excerpt":"","text":"系列文章目录 数据集收集和标注情况 1.1ASR语音数据集收集和标注情况 1.2CV图像数据集收集和标注情况 进行模型的训练 2.1进行ASR模型的训练 2.2进行CV模型的训练 在Jetson平台进行部署和推理 3.1部署和推理ASR模型 3.2部署和推理CV模型 优化UI界面 1. 数据集收集和标注情况 1.1ASR语音数据集收集和标注情况 首先收集语音数据集，包含以下语音： | 请检测出果皮 | | ---------------------- | | 请检测出瓶子 | | 请检测出纸箱 | | 请检测出纸箱和果皮 | | 请检测出果皮和纸箱 | | 请检测出纸箱果皮和瓶子 | | 请检测出果皮纸箱和瓶子 | | 请检测出果皮瓶子和纸箱 | | 请检测出纸箱瓶子和果皮 | | 请检测出瓶子果皮和纸箱 | | 请检测出果皮和瓶子 | | 请检测出瓶子纸箱和果皮 | | 请检测出瓶子和果皮 | | 请检测出纸箱和瓶子 | | 请检测出瓶子和纸箱 | 数据集类型以及数量 | 数据集类型 | 语音数量 | | ---------- | ------------------ | | 测试集 | 111条男声+75条女声 | | 训练集 | 221条（男+女） | 通过librosa计算语音时长 12asr_result = quartznet.transcribe(paths2audio_files=[&quot;xxx&quot;]) # 调用transcribe函数测试预训练模型识别效果 print(asr_result) 制作好训练集的json文件和测试集的json文件 1.2CV图像数据集收集和标注情况 收集箱子图片200+，瓶子图片100+，香蕉皮图片100+ 比赛方提供了2636张图片的数据集，但是因为训练效果并不好，所以我们对数据集进行了清洗，并加入了我们自己的图片。 最后完整的数据集共2276张图片和标签。 我们使用labelimg进行图像标注，但是因为labelimg只能标注为Pascal VOC格式，所以我们需要将其手动转换为KITTI格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# -*- coding: utf-8 -*-import sysfrom os import listdirfrom os.path import isfile, isdir, join, dirname, splitext, basenameimport xml.etree.ElementTree as ETpath=&quot;&quot;class XMLReader: def __init__(self, path): file = open(path, &#x27;r&#x27;) self.path = path self.content = file.read() self.root = ET.fromstring(self.content) self.template = &quot;&#123;name&#125; 0.00 0 0.0 &#123;xmin&#125;.00 &#123;ymin&#125;.00 &#123;xmax&#125;.00 &#123;ymax&#125;.00 0.0 0.0 0.0 0.0 0.0 0.0 0.0&quot; def get_filename(self): return splitext(basename(self.path))[0] def get_dir(self): return dirname(self.path) def get_objects(self): objects = [] for object in self.root.findall(&quot;object&quot;): objects.append(&#123; &quot;name&quot; : object.find(&quot;name&quot;).text, &quot;xmin&quot; : object.find(&quot;bndbox&quot;).find(&quot;xmin&quot;).text, &quot;ymin&quot; : object.find(&quot;bndbox&quot;).find(&quot;ymin&quot;).text, &quot;xmax&quot; : object.find(&quot;bndbox&quot;).find(&quot;xmax&quot;).text, &quot;ymax&quot; : object.find(&quot;bndbox&quot;).find(&quot;ymax&quot;).text &#125;) return objects def fill_template(self, object): return self.template.format(**object) def export_kitti(self): objects = self.get_objects() #Skip empty if len(objects) == 0: return False file = open(join(self.get_dir(), self.get_filename()) + &quot;.txt&quot;, &#x27;w&#x27;) for object in objects[:-1]: file.write(self.fill_template(object) + &quot;\\n&quot;) # Write last without &#x27;\\n&#x27; file.write(self.fill_template(objects[-1])) file.close() return Truedef process_file(path): xml_reader = XMLReader(path) return xml_reader.export_kitti()def get_directory_xml_files(dir): return [join(dir, f) for f in listdir(dir) if isfile(join(dir, f)) and splitext(f)[1].lower() == &quot;.xml&quot;]def check_argv(argv): return len(argv) &gt; 1def main(): if not check_argv(sys.argv): print(&quot;Wrong arguments. You should specify xml files or directory with xml files&quot;) # remove script name args = sys.argv[1:] processed_file_count = 0 for path in args: files = [] if isfile(path): files.append(path) elif isdir(path): files += get_directory_xml_files(path) for file in files: if process_file(file): processed_file_count += 1 print(&quot;Finished. &#123;0&#125; Files are processed&quot;.format(processed_file_count))if __name__ == &quot;__main__&quot;: main() 2.进行模型的训练 2.1进行ASR模型的训练 导入相关包和yaml文件后进行训练，在yaml文件中修改batch_size和数据集路径等 训练150轮后查看训练结果，并保存nemo模型 2.2进行CV模型的训练 在CV模型的训练中，最主要的是完成数据集的加载以及模型训练时参数的设置 123456789101112training_config &#123; batch_size_per_gpu: 8 num_epochs: 80 enable_qat: false learning_rate &#123; soft_start_annealing_schedule &#123; min_learning_rate: 5e-5 max_learning_rate: 2e-3 soft_start: 0.15 annealing: 0.8 &#125; &#125; 我们修改了学习率为0.002，并且有80个epochs，最后将训练的模型进行剪枝 最后用tao converter转换为bin的形式 注意！！！ 这里要在节点上转换，不能在本地转换 3.在Jetson平台进行部署和推理 3.1部署和推理ASR模型 将本地保存好的nemo模型上传到节点 修改app.py的模型路径 1nemo_asr.models.EncDecCTCModel.restore_from(&quot;/home/nvidia/7th_ASR/7th_asr_model_best.nemo&quot;) 启动flask服务后进入前端的界面 点击加载模型 选择文件-&gt;上传语音 输入正确答案后识别 可以得到正确率和错字率 3.2部署和推理CV模型 需要在garbage_detection.py文件中修改自己模型的路径和名字 将训练好的模型通过flask部署到节点上，并且进行测试 上传图片并进行识别，可以得到识别结果 4. 优化UI界面 这一部分来自于我们团队中设计前端的同学 Css样式设计流程： 第一步：去除浏览器默认边界和覆盖浏览器默认字体，设置box类型 第二步： 设计body样式为display:flex(弹性布局)，justify-conten:center(水平居中),align-items:center(垂直居中) Background: #fff(背景为纯黑), min-height:100vh(元素会被撑开与屏幕高度一致) 第三步：设计比赛标题样式以及队名样式 第四步：设计div标签统一样式: 使用text-decoration:none(取消文本原样式)、position:relative(依据父级定位) 、padding:10px 8px(设计边界距离)、color : #21ebff(统一字体背景色)、font-size:20px(统一字体大小)、 第五步：给div设计边框，设计阴影效果，实现鼠标悬停触发特效。给button与input设计统一样式，微调位置，实现界面整洁和工整。 第六步：利用浏览器调试工具，进一步，美化界面，调试按钮、上传等功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322&lt;html&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;head&gt; &lt;script src=&quot;https://unpkg.com/vue@3&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/style.css&quot;&gt; &lt;style&gt; .image img&#123; max-height: 600px; &#125; * &#123; margin: 0; padding: 0; font-family: &#x27;微软雅黑&#x27;, sans-serif; box-sizing: border-box; &#125; body &#123; display: flex; justify-content: center; align-items: center; background: #000; min-height: 100vh; &#125; div &#123; position: relative; padding: 10px 30px; margin: 0 45px; color: #21ebff; text-decoration: none; font-size: 20px; /* text-transform: uppercase; */ transition: 0.5s; overflow: hidden; /* -webkit-box-reflect: below 1px linear-gradient(transparent, #0003); */ &#125; /* div:hover &#123; box-shadow: 0 0 33px #21ebff; &#125; */ div:hover &#123; /* background: #21ebff; */ /* color: #0d7377; */ color: #21ebff; /* box-shadow: 0 0 33px #21ebff; */ box-shadow: 0 0 33px #0d7377; &#125; div::before &#123; top: 0; left: 0; width: 10px; height: 10px; border-top: 2px solid #21ebff; border-left: 2px solid #21ebff; transition: 0.5s; transition-delay: 0.5s; &#125; div:hover::before &#123; width: 100%; height: 100%; transition-delay: 0s; &#125; div::after &#123; right: 0; bottom: 0; width: 10px; height: 10px; border-bottom: 2px solid #21ebff; border-right: 2px solid #21ebff; transition: 0.5s; transition-delay: 0.5s; &#125; div:hover::after &#123; width: 100%; height: 100%; transition-delay: 0s; &#125; button &#123; color: black; font-family: &#x27;微软雅黑&#x27;, sans-serif; font-size: 18px; &#125; input &#123; color: #0d7377; font-family: &#x27;微软雅黑&#x27;, sans-serif; font-size: 16px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body id=&quot;app&quot;&gt; &lt;div class=&quot;loading&quot; v-if=&quot;loading!=&#x27;&#x27;&quot;&gt; &lt;div class=&quot;pad&quot;&gt;%%loading%%&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;h2&gt;7th Sky Hackathon&lt;/h2&gt; &lt;div class=&quot;loaded&quot;&gt; &lt;!-- ASR --&gt; &lt;fieldset class=&quot;asr&quot;&gt; &lt;legend&gt;ASR&lt;/legend&gt; &lt;button @click=&quot;loadModel()&quot; v-if=&quot;!modelLoaded&quot; style=&quot;display:block;margin:0 auto&quot;&gt;加载模型&lt;/button&gt; &lt;div v-if=&quot;modelLoaded&quot; class=&quot;modelLoaded&quot;&gt;模型加载成功&lt;/div&gt; &lt;div class=&quot;field file&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; ref=&quot;file&quot; @change=&quot;handleFileUpload($event)&quot; /&gt; &lt;button @click=&quot;submitFile(&#x27;asr&#x27;)&quot;&gt;上传语音&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;note&quot;&gt;仅支持 .wav 和单声道格式&lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label&gt;请输入正确答案: &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;defaultText&quot; v-model=&quot;defaultText&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;field&quot; v-if=&quot;asrStatus==&#x27;uploaded&#x27; || asrStatus==&#x27;identified&#x27;&quot;&gt; &lt;div class=&quot;audio&quot;&gt;&lt;audio controls :src=&quot;audioOriginal&quot;&gt;&lt;/audio&gt;&lt;/div&gt; &lt;div class=&quot;action&quot;&gt;&lt;button @click=&quot;identifyAudio()&quot;&gt;识别语音&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field result asr&quot; v-if=&quot;asrStatus==&#x27;identified&#x27;&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in asrResult&quot;&gt;%%key%%: %%value%%&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;!-- /ASR --&gt; &lt;!-- CV --&gt; &lt;fieldset class=&quot;cv&quot;&gt; &lt;legend&gt;CV&lt;/legend&gt; &lt;div class=&quot;field&quot;&gt; &lt;div class=&quot;item action&quot;&gt;&lt;button @click=&quot;getFps()&quot; class=&quot;inline&quot;&gt;获取 FPS&lt;/button&gt;&lt;/div&gt; &lt;div class=&quot;item result&quot;&gt;FPS: %%cvFps%%&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;button @click=&quot;getMap()&quot; class=&quot;inline&quot;&gt;获取 mAP&lt;/button&gt;&lt;/div&gt; &lt;div class=&quot;item result&quot;&gt;mAP: %%cvMap%%&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field file&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; ref=&quot;file&quot; @change=&quot;handleFileUpload($event)&quot; /&gt; &lt;button @click=&quot;submitFile(&#x27;cv&#x27;)&quot;&gt;上传图片&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;div class=&quot;image original&quot; v-if=&quot;imageOriginal!=&#x27;&#x27;&quot;&gt; &lt;div class=&quot;label&quot;&gt;原图&lt;/div&gt; &lt;image :src=&quot;imageOriginal&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;image result cv&quot; v-if=&quot;imageResult!=&#x27;&#x27;&quot;&gt; &lt;div class=&quot;label&quot;&gt;结果图&lt;/div&gt; &lt;image :src=&quot;imageResult&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;action&quot; v-if=&quot;imageOriginal!=&#x27;&#x27;&quot;&gt; &lt;button @click=&quot;identifyImage()&quot;&gt;识别图片&lt;/button&gt;&lt;br&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;!-- /CV --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const &#123; createApp &#125; = Vue createApp(&#123; data() &#123; return &#123; file: &#x27;&#x27;, defaultText: &#x27;请检测瓶子&#x27;, modelLoaded: false, imageOriginal: &#x27;&#x27;, imageResult: &#x27;&#x27;, audioOriginal: &#x27;&#x27;, error: &#x27;&#x27;, asrResult: &#123;&#125;, cvMap: &#x27;&#x27;, cvFps: &#x27;&#x27;, loading: &#x27;&#x27;, asrStatus: &#x27;pending&#x27;, cvStatus: &#x27;pending&#x27; &#125; &#125;, // Avoid conflict with Flask delimiters compilerOptions: &#123; delimiters: [&quot;%%&quot;, &quot;%%&quot;] &#125;, methods: &#123; async loadModel() &#123; if (this.loading != &#x27;&#x27;) return showError(&#x27;在运行中，无法执行&#x27;) this.loading = &#x27;加载模型中，请耐心等待...&#x27; this.modelLoaded = false try &#123; var &#123; data, status &#125; = await axios.get(&#x27;/asr/load&#x27;) if (status == 200) &#123; this.modelLoaded = true &#125; &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = &#x27;&#x27; &#125;, async submitFile(fileType) &#123; let formData = new FormData() formData.append(&#x27;file&#x27;, this.file) statusType = fileType + &#x27;Status&#x27; this.loading = &#x27;上传中...&#x27; try &#123; var &#123; data, status &#125; = await axios.post(&#x27;/&#x27; + fileType + &#x27;/upload&#x27;, formData, &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27; &#125; &#125;) if (status == 200) &#123; this[statusType] = &#x27;uploaded&#x27; if (fileType == &#x27;cv&#x27;) &#123; this.imageOriginal = data &#125; else &#123; this.audioOriginal = data &#125; &#125; &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = &#x27;&#x27; &#125;, handleFileUpload(event) &#123; this.file = event.target.files[0]; &#125;, async identifyAudio(event) &#123; // if (this.loading != &#x27;&#x27;) return showError(&#x27;在运行中，无法执行&#x27;) this.loading = &#x27;识别中...&#x27; try &#123; let formData = new FormData() formData.append(&#x27;defaultText&#x27;, this.defaultText) console.log(&#x27;t&#x27;, this.defaultText) var result = await axios.post(&#x27;/asr/identify&#x27;, formData) this[&#x27;asrStatus&#x27;] = &#x27;identified&#x27; this.asrResult = result.data &#125; catch (err) &#123; if (err.response.status == 500) this.modelLoaded = false showError(err.response.data) &#125; this.loading = &#x27;&#x27; &#125;, async identifyImage(event) &#123; if (this.loading != &#x27;&#x27;) return showError(&#x27;在运行中，无法执行&#x27;) this.loading = &#x27;识别中...&#x27; this.cvStatus = &#x27;pending&#x27; try &#123; var &#123; data &#125; = await axios.get(&#x27;/api/detect/image&#x27;) this.imageResult = data[&#x27;detection_result_image_path&#x27;] &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = &#x27;&#x27; &#125;, async getFps(event) &#123; if (this.loading != &#x27;&#x27;) return showError(&#x27;在运行中，无法执行&#x27;) this.loading = &#x27;获取 FPS...&#x27; try &#123; var &#123; data &#125; = await axios.get(&#x27;/api/detect/fps&#x27;) this.cvFps = data[&#x27;detection_FPS&#x27;] &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = &#x27;&#x27; &#125;, async getMap(event) &#123; // 接口路径: /api/detect/map // 方式: GET if (this.loading != &#x27;&#x27;) return showError(&#x27;在运行中，无法执行&#x27;) this.loading = &#x27;获取 mAP...&#x27; try &#123; var &#123; data &#125; = await axios.get(&#x27;/api/detect/map&#x27;) this.cvMap = data[&#x27;detection_mAP&#x27;] &#125; catch (err) &#123; showError(err.response.data) &#125; this.loading = &#x27;&#x27; &#125; &#125; &#125;).mount(&#x27;#app&#x27;) function showError(msg) &#123; alert(msg || &#x27;错误&#x27;) &#125;&lt;/script&gt;&lt;/html&gt; 总结 在这次比赛中，我们完整的做了一个深度学习的项目，从制作数据集开始，到训练神经网络，到最后部署到用户端，完整的实现了从0到1的过程。感觉这次比赛考察的能力非常多，从最开始的配置环境开始，就给我们出了一道难题，要从最基础的Linux操作学起，安装好双系统，再去配置环境，再去运行程序，从程序中的一条条error，去搜索，搜不到就去问，解决问题才有意义，从debug中一点一点前进，才能进步。 感觉最大的遗憾就是没有更彻底的自动化整个流程，因为没有接触过python，所以在制作语音数据集的时候，都是让队员复制过去的，没想到去写一个json，在制作cv数据集时也没想到用爬虫去找数据。","categories":[{"name":"The 7th Sky Hackathon","slug":"The-7th-Sky-Hackathon","permalink":"https://mengfanjun020906.github.io/categories/The-7th-Sky-Hackathon/"}],"tags":[{"name":"Nvidia","slug":"Nvidia","permalink":"https://mengfanjun020906.github.io/tags/Nvidia/"},{"name":"人工智能","slug":"人工智能","permalink":"https://mengfanjun020906.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"大数据","slug":"大数据","permalink":"https://mengfanjun020906.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"数字信号处理用汉宁窗/矩形窗/布莱克曼窗设计线性相位带通滤波器MATLAB实现——实例","slug":"数字信号处理用汉宁窗_矩形窗_布莱克曼窗设计线性相位带通滤波器MATLAB实现——实例","date":"2022-12-08T13:37:53.000Z","updated":"2023-03-24T05:34:21.770Z","comments":true,"path":"2022/12/08/数字信号处理用汉宁窗_矩形窗_布莱克曼窗设计线性相位带通滤波器MATLAB实现——实例/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/08/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%94%A8%E6%B1%89%E5%AE%81%E7%AA%97_%E7%9F%A9%E5%BD%A2%E7%AA%97_%E5%B8%83%E8%8E%B1%E5%85%8B%E6%9B%BC%E7%AA%97%E8%AE%BE%E8%AE%A1%E7%BA%BF%E6%80%A7%E7%9B%B8%E4%BD%8D%E5%B8%A6%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8MATLAB%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"汉宁窗 在这里插入图片描述 123456789101112clearclose allclcN=45;wn=[0.3,0.5];%截止频率window=hanning(N+1); %计算长度为N的汉宁窗b=fir1(N,wn,window); %N是阶数,wn是截止频率[H,w]=freqz(b); subplot(2,1,1);plot(w/pi,20*log10(abs(H)));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;幅频响应&#x27;); subplot(2,1,2);plot(w/pi,angle(H));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;相位&#x27;);title(&#x27;相位响应&#x27;); 在这里插入图片描述 后面的矩形窗和布莱克曼窗的原理同理，matlab已经给我们准备好了函数直接去调用 12345678910111213141516171819202122clearclose allclc%矩形窗N=15% N=input(&#x27;请输入 N 的值\\n&#x27;);wn=[0.3,0.5];% b=fir1(N,wn,boxcar(N+1)); % [H,w]=freqz(b,1,512); % subplot(2,1,1);plot(w/pi,20*log10(abs(H)));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;幅频响应&#x27;); % subplot(2,1,2);plot(w/pi,angle(H));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;相位&#x27;);title(&#x27;相频响应&#x27;);%布莱克曼窗：（N=15 时）% N=input(&#x27;请输入 N 的值\\n&#x27;);wn=[0.3,0.5]; window=blackman(N+1); b=fir1(N,wn,window); [H,w]=freqz(b); subplot(2,1,1);plot(w/pi,20*log10(abs(H)));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;幅频响应&#x27;); subplot(2,1,2);plot(w/pi,angle(H));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;相位&#x27;);title(&#x27;相频响应&#x27;); 布莱克曼窗 # 矩形窗","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"数字信号处理用脉冲响应不变法和双线性变换法设计巴特沃斯滤波器MATLAB实现——实例","slug":"数字信号处理用脉冲响应不变法和双线性变换法设计巴特沃斯滤波器MATLAB实现——实例","date":"2022-12-08T06:57:19.000Z","updated":"2023-03-24T05:41:44.809Z","comments":true,"path":"2022/12/08/数字信号处理用脉冲响应不变法和双线性变换法设计巴特沃斯滤波器MATLAB实现——实例/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/08/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%94%A8%E8%84%89%E5%86%B2%E5%93%8D%E5%BA%94%E4%B8%8D%E5%8F%98%E6%B3%95%E5%92%8C%E5%8F%8C%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%B7%B4%E7%89%B9%E6%B2%83%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%99%A8MATLAB%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"符号含义 # 例题 脉冲响应不变法 123456789101112131415161718clearclose allclcfs=1000;%采样频率fc=200;%通带截止频率fr=300;%阻带截止频率T=0.001; %采样周期%%%%%%%脉冲响应不变法wp1=2*pi*fc;%通带截止频率wr1=2*pi*fr;%阻带截止频率[N1,wn1]=buttord(wp1,wr1,1,25,&#x27;s&#x27;); %[滤波器的阶数,截止频率]=buttord(通带截止频率,阻带截止频率,通带波纹,阻带衰减,滤波器类型s-带阻)[B1,A1]=butter(N1,wn1,&#x27;s&#x27;); %[传递函数系数B1是分子的 A1是分母的]=butter(滤波器的阶数,截止频率,滤波器类型s-带阻)[num1,den1]=impinvar(B1,A1,fs); %利用脉冲响应不变法将模拟滤波器转数字滤波器[数字滤波器传递函数num1/den1]=impinvar(模拟的分子系数B1,模拟的分母系数A1,采样频率)[h1,w]=freqz(num1,den1); %[频率响应,角频率]=freqz(数字滤波器传递函数num1/den1) 双线性变换法 双线性变换法要对通带截止频率和阻带截止频率做一个预畸变处理 12345678%%%%%%%双线性变换法wp2=2*fs*tan(2*pi*fc/(2*fs)); %做预畸变处理后的通带截止频率wr2=2*fs*tan(2*pi*fr/(2*fs)); %做预畸变处理后的阻带截止频率[N2,wn2]=buttord(wp2,wr2,1,25,&#x27;s&#x27;); %[滤波器的阶数,截止频率]=buttord(通带截止频率,阻带截止频率,通带波纹,阻带衰减,滤波器类型s-带阻)[B2,A2]=butter(N2,wn2,&#x27;s&#x27;); %[传递函数系数B2是分子的 A2是分母的]=butter(滤波器的阶数,截止频率,滤波器类型s-带阻)[num2,den2]=bilinear(B2,A2,fs); %利用双线性的方法将模拟滤波器转数字滤波器[数字滤波器传递函数num2/den2]=impinvar(模拟的分子系数B2,模拟的分母系数A2,采样频率)[h2,w]=freqz(num2,den2); %[频率响应,角频率]=freqz(数字滤波器传递函数num2/den2)f=w/(2*pi)*fs; %将角频率转换为频率 画图 12345plot(f,20*log10(abs(h1)),&#x27;-.&#x27;,f,20*log10(abs(h2)),&#x27;-&#x27;); %画脉冲响应不变法和双线性变换法的图axis([0,500,-80,10]);% 设置当前坐标轴x轴和y轴的限制范围grid; %切换改变主网格线的可见性xlabel(&#x27;频率/Hz&#x27;);ylabel(&#x27;幅度/dB&#x27;);title(&#x27;巴特沃思数字低通滤波器&#x27;); legend(&#x27;脉冲响应不变法&#x27;,&#x27;双线性变换法&#x27;); 在这里插入图片描述 完整代码 123456789101112131415161718192021222324252627282930313233clearclose allclcfs=1000;%采样频率fc=200;%通带截止频率fr=300;%阻带截止频率T=0.001; %采样周期%%%%%%%脉冲响应不变法wp1=2*pi*fc;%通带截止频率wr1=2*pi*fr;%阻带截止频率[N1,wn1]=buttord(wp1,wr1,1,25,&#x27;s&#x27;); %[滤波器的阶数,截止频率]=buttord(通带截止频率,阻带截止频率,通带波纹,阻带衰减,滤波器类型s-带阻)[B1,A1]=butter(N1,wn1,&#x27;s&#x27;); %[传递函数系数B1是分子的 A1是分母的]=butter(滤波器的阶数,截止频率,滤波器类型s-带阻)[num1,den1]=impinvar(B1,A1,fs); %利用脉冲响应不变法将模拟滤波器转数字滤波器[数字滤波器传递函数num1/den1]=impinvar(模拟的分子系数B1,模拟的分母系数A1,采样频率)[h1,w]=freqz(num1,den1); %[频率响应,角频率]=freqz(数字滤波器传递函数num1/den1)%%%%%%%双线性变换法wp2=2*fs*tan(2*pi*fc/(2*fs)); %做预畸变处理后的通带截止频率wr2=2*fs*tan(2*pi*fr/(2*fs)); %做预畸变处理后的阻带截止频率[N2,wn2]=buttord(wp2,wr2,1,25,&#x27;s&#x27;); %[滤波器的阶数,截止频率]=buttord(通带截止频率,阻带截止频率,通带波纹,阻带衰减,滤波器类型s-带阻)[B2,A2]=butter(N2,wn2,&#x27;s&#x27;); %[传递函数系数B2是分子的 A2是分母的]=butter(滤波器的阶数,截止频率,滤波器类型s-带阻)[num2,den2]=bilinear(B2,A2,fs); %利用双线性的方法将模拟滤波器转数字滤波器[数字滤波器传递函数num2/den2]=impinvar(模拟的分子系数B2,模拟的分母系数A2,采样频率)[h2,w]=freqz(num2,den2); %[频率响应,角频率]=freqz(数字滤波器传递函数num2/den2)f=w/(2*pi)*fs; %将角频率转换为频率plot(f,20*log10(abs(h1)),&#x27;-.&#x27;,f,20*log10(abs(h2)),&#x27;-&#x27;); %画脉冲响应不变法和双线性变换法的图axis([0,500,-80,10]);% 设置当前坐标轴x轴和y轴的限制范围grid; %切换改变主网格线的可见性xlabel(&#x27;频率/Hz&#x27;);ylabel(&#x27;幅度/dB&#x27;);title(&#x27;巴特沃思数字低通滤波器&#x27;); legend(&#x27;脉冲响应不变法&#x27;,&#x27;双线性变换法&#x27;);","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"给自己的hexo博客个性化Volantis主题","slug":"给自己的hexo博客个性化Volantis主题","date":"2022-12-06T13:18:58.000Z","updated":"2023-03-24T01:07:47.567Z","comments":true,"path":"2022/12/06/给自己的hexo博客个性化Volantis主题/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/06/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96Volantis%E4%B8%BB%E9%A2%98/","excerpt":"","text":"准备工作 首先要有自己的hexo博客，并且已经部署到 github上面了，这样我们接下来才能顺利的换主题 先推荐我自己的个人博客 我的博客 一、搭建一个大致框架 我在这里非常推荐去读官方的文档，里面写的非常清楚， 官方文档 但是因为鄙人实在愚钝，对着官方文档都配置的漏洞百出，所以打算自己记录下配置的过程。 首先在你搭建hexo的文件下新建一个yml文件，起名叫 _config.volantis.yml 就放在_config.yml的文件旁边就行。 然后在_config.yml中把theme改成volantis 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: volantis 注意，yml的冒号后面一定要打一个空格，要不然程序就会报错 配置完这些，在本地启动后，应该就可以看到示例博客了 二、在_config.yml的一些基础配置 代码如下（示例）： 12345678# Sitetitle: #标题subtitle: &#x27;#副标题&#x27;description: &#x27;#简介&#x27;keywords: #关键字author: #作者language: entimezone: &#x27;&#x27; 12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: #你部署的地址，我的就是github.iopermalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 三、在_config.volantis.yml的进阶配置 之前从来没做类似的东西，我在这里也是摸着石头过河，以我自己的网站为例子，尽可能给大家说的详细一点 1.首先我们要创建页面 因为我自己需要的页面不多 除去博客和归档是主题自带的，我自己创建了4个页面 分别是分类、标签、友链、关于 所以我们需要 1234hexo new “categories”hexo new “tags”hexo new “friends”hexo new “about” 另外手动创建一个_data文件夹，在里面创建friends.yml 都创建完后，目录应该是这样的 2.自定义导航栏 在_config.volantis.yml中放入导航栏，这里就以我的为例 1234567891011121314151617181920212223242526272829############################### Navigation Bar ############################### &gt; start# 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fa-solid fa-rss url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 友链 icon: fa-solid fa-link url: friends/ - name: 关于 icon: fa-solid fa-info-circle url: about/ search: Search... # Search bar placeholder############################### Navigation Bar ############################### &gt; end 对应好各个页面的url名字即可 ## 3.自定义友链页面设置 1234pages: # 友链页面配置 friends: layout_scheme: simple # simple: 简单布局, traditional: 传统布局 我这里用的是简单布局 还有在_data下的friends.yml文件 123456789- group: # 分组标题 description: # 分组描述 items: - title: e # 名称 avatar: # 头像 url: # 链接 screenshot: # 截图 keywords: # 关键词 description: # 描述 4.自定义页脚 12345678910111213site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [aplayer, social, license, info, copyright] social: - icon: fas fa-rss url: atom.xml - icon: fas fa-envelope url: mailto:#你的邮箱 - icon: fab fa-github url: #你的github地址 copyright: &#x27;[Copyright © 2017-2022 #版权](/)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; 5.自定义封面 我这里用的是 1234567891011121314151617181920212223############################### Cover ############################### &gt; startcover: height_scheme: full # full, half layout_scheme: search # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点)，个人感觉搜索更简洁 display: home: true archive: true others: true # can be written in front-matter &#x27;cover: true&#x27; background: #封面背景，需要上传url # background: https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &#x27;#你的标题&#x27; subtitle: &#x27;&#x27; search: 搜一下 # search bar placeholder 搜索栏里面显示的东西 features: - name: 主页 icon: # url: / - name: 标签 icon: # url: tags/############################### Cover ############################### &gt; end ## 6.自定义侧边栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124############################### Sidebar ############################### &gt; startsidebar: position: right # left right 侧边栏的位置 # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, webinfo, lastupdate]#侧边栏的组成部分 # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: #你的头像url # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png shape: rectangle # circle, rectangle url: /about/ title: #名字 subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - icon: fa-solid fa-envelope url: mailto:#你的邮箱 - icon: fab fa-github url: #你的github地址 # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] sticky: true header: icon: fa-solid fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # music music: class: music display: [desktop, mobile] # [desktop, mobile] pjaxReload: false # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fa-solid fa-folder-open title: 文章分类 url: /blog/categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fa-solid fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fa-solid fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2022/12/04&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; visitcounter: siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # --------------------------------------- # lastupdate widget lastupdate: class: lastupdate display: [desktop, mobile] header: icon: fa-solid fa-clock WISTERIA title: 最近更新 text: class: text display: [desktop] # [desktop, mobile] header: icon: fab fa-github title: 点个赞吧 url: https://github.com/xaoxuu/ content: - &#x27;您的赞对我来说很重要，如果您喜欢本主题，希望能够给下面的项目点个赞来支持一下。&#x27;############################### Sidebar ############################### &gt; end 我们在侧边栏里开启了5个功能，分别是博客主人的介绍、类别汇总、热门标签汇总、站点信息、最近更新，具体是什么样子，大家可以去我的博客看看，感觉描述的不是很清楚 ## 7.利用不蒜子添加访问人数 我之前先设置了侧边栏，然后访问人数一直找不到在哪里开启，后来发现这个在官方文档的进阶配置，为了顺序通顺，就在设置完侧边栏后进行配置 123456analytics: busuanzi: https://gcore.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js leancloud: # 请使用自己的 id &amp; key 以防止数据丢失 app_id: # 应用 APP_ID app_key: # 应用 APP_KEY custom_api_server: # 国际版一般不需要写，除非自定义了 API Server 这样就可以看到访问人数了 ## 8.添加阅读时长和字数 先安装如下插件 1npm i --save hexo-wordcount 再打开插件 1234plugins: # 文章字数统计、阅读时长，开启需要安装插件: npm i --save hexo-wordcount wordcount: enable: true 9.添加音乐播放器 我这里用的是网易云的歌单 12345678910111213141516171819plugins: # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS aplayer: enable: true # Required server: netease # netease, tencent, kugou, xiami, baidu歌曲的网站 type: playlist # song, playlist, album, search, artist 歌曲或者歌单、专辑等 id: 993524571 # song id / playlist id / album id / search keyword歌曲或者歌单的id # Optional fixed: true # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: true # audio autoplay是否自动播放 order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true autoHide: true # hide automaticaly是否要隐藏 10.自定义文章布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175 ############################### Article Layout ############################### &gt; start# 文章布局article: # 文章列表页面的文章卡片布局方案 preview: scheme: lanscape # landscape # pin icon for post pin_icon: volantis-static/media/twemoji/assets/svg/1f4cc.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # hide excerpt hide_excerpt: false # show split line or not line_style: solid # hidden, solid, dashed, dotted # show author author: true # true, false # show readmore button readmore: auto # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, wordcount, counter] #启用评论数量需在此添加 # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags, share] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fa-solid fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fa-solid fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: https://gcore.jsdelivr.net/gh/MHG-LAB/cron@gh-pages/bing/bing.jpg # ---------------- # 版权声明组件 (for layout: post) copyright: enable: false permalink: &#x27;本文永久链接是：&#x27; content: - &#x27;博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27; - permalink # 自定义版权组件：精细到文章的版权声明 custom: false # 开启后替代上方内容的版权显示 customData: default: type1 # 默认授权声明 ############################# # 你可以在文章的 front-matter 覆盖默认版权声明 # 配置示例（均可选）： # copyright: # type: type3 # 当前文章版权声明类型 # author: 张三 # 本文作者 # ref: # 原文出处 # title: # 原文出处 - 标题 # url: # 原文出处 - 链接 ############################# rules: type1: text: &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh#&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; desc: 署名-非商业性使用-相同方式共享 4.0 国际。 type2: text: 禁止转载引用 desc: 除非获得原作者的单独授权，任何第三方不得转载！ type3: text: 原作许可协议 desc: 本文转载自他站，转载或引用本文时，请遵守原作许可协议！ type4: text: 来自互联网 desc: 本文来自互联网，未知来源，侵权请联系删除。 type5: text: 允许规范转载 desc: 转载请保留本文转载地址，著作权归作者所有！ type6: text: 允许付费转载 desc: 您可以联系作者通过付费方式获得授权。 # 还能自行添加更多 # ---------------- # 打赏组件 (for layout: post) donate: enable: false images: - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # meta library meta_library: # 默认文章作者（可在 _data/author.yaml 中增加其他作者，并在 front-matter 中设置） # https://volantis.js.org/advanced-settings/#多人协同 author: avatar: #文章作者的头像 # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/apple-touch-icon.png name: #作者名字 url: / # 文章创建日期 date: icon: fa-solid fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fa-solid fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fa-solid fa-folder-open # 文章浏览计数 counter: icon: fa-solid fa-eye unit: &#x27;次浏览&#x27; # waline 文章评论数量 walinecount: icon: fa-solid fa-comment-dots desc: &#x27;条评论&#x27; # 条评论 # artalk 文章评论数量 artalkcount: icon: fa-solid fa-comment-dots desc: &#x27;条评论&#x27; # 条评论 # 文章字数和阅读时长 wordcount: icon_wordcount: fa-solid fa-keyboard icon_duration: fa-solid fa-hourglass-half # 文章标签 tags: icon: fa-solid fa-hashtag # 分享 share: - id: qq img: volantis-static/media/org.volantis/logo/128/qq.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png - id: qzone img: volantis-static/media/org.volantis/logo/128/qzone.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png - id: weibo img: volantis-static/media/org.volantis/logo/128/weibo.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png - id: # qrcode # 当id为qrcode时需要安装插件 npm i hexo-helper-qrcode img: # volantis-static/media/org.volantis/logo/128/wechat.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png - id: # telegram img: # volantis-static/media/org.volantis/logo/128/telegram.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.png############################### Article Layout ############################### &gt; endcustom_css: fontfamily: logofont: fontfamily: &#x27;&quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;Varela Round&#x27; url: volantis-static/media/fonts/VarelaRound/VarelaRound-Regular.ttf # https://gcore.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;UbuntuMono, &quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf # https://gcore.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &#x27;Menlo, UbuntuMono, Monaco&#x27; name: &#x27;Monaco&#x27; url: volantis-static/media/fonts/Monaco/Monaco.ttf # https://gcore.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf weight: normal style: normal 11.自定义主题颜色 我这里其实没做什么修改，主要是将代码块改的更好看了点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596color_scheme: # ------------ # 通用颜色 common: # 主题色 theme: &#x27;#44D7B6&#x27; # 链接色 link: &#x27;#2196f3&#x27; # 按钮色 button: &#x27;#44D7B6&#x27; # 鼠标放到交互元素上时的色 hover: &#x27;#ff5722&#x27; # 主题色块内部的文字颜色 inner: &#x27;#fff&#x27; # 选中区域文字的背景颜色 selection: &#x27;alpha(#2196f3, 0.2)&#x27; # ------------ # 亮色主题（默认） light: # 网站背景色 site_bg: &#x27;#f4f4f4&#x27; # 网站背景上的文字 site_inner: &#x27;#fff&#x27; # 网站页脚文字 site_footer: &#x27;#fff&#x27; # 卡片背景色 card: &#x27;#fff&#x27; # 卡片上的普通文字 text: &#x27;#444&#x27; # 区块和代码块背景色 block: &#x27;#f6f6f6&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#f6f6f6&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#444&#x27; h2: &#x27;#444&#x27; h3: &#x27;#444&#x27; h4: &#x27;#444&#x27; h5: &#x27;#444&#x27; h6: &#x27;#444&#x27; p: &#x27;#444&#x27; # 列表文字 list: &#x27;#666&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #000, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # ------------ # 暗色主题 dark: # 网站背景色 site_bg: &#x27;#222&#x27; # 网站背景上的文字 site_inner: &#x27;#eee&#x27; # 网站页脚文字 site_footer: &#x27;#aaa&#x27; # 卡片背景色 card: &#x27;#444&#x27; # 卡片上的普通文字 text: &#x27;#eee&#x27; # 区块和代码块背景色 block: &#x27;#3a3a3a&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#343a3c&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#eee&#x27; h2: &#x27;#eee&#x27; h3: &#x27;#ddd&#x27; h4: &#x27;#ddd&#x27; h5: &#x27;#ddd&#x27; h6: &#x27;#ddd&#x27; p: &#x27;#bbb&#x27; # 列表文字 list: &#x27;#aaa&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #fff, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # 夜间图片亮度 brightness: 70% body: effect: [blur] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true ## 12.添加评论系统 首先要去github创建一个公共仓库，我们就叫他comments 然后打开comments的discussion功能，在仓库的setting中，找到Features 把这里打还是那个勾，我们才能用giscus 将你创建好的comments仓库复制到这里 your_github/comments 我选择的是这个模式 这两个东西我们在配置中都会用到 将你从giscus获得的id放进配置中 12345678910111213141516171819202122############################### Comments ############################### &gt; startcomments: service: giscus # giscus # https://giscus.app # https://github.com/laymonage/giscus giscus: # 以下配置按照 yml 格式增删填写即可 repo: #库的名字 repo-id: #库id，标红框的第一个 category: Announcements category-id: #目录id，标红框的第二个 mapping: &quot;pathname&quot; reactions-enabled: &quot;1&quot; emit-metadata: &quot;0&quot; lang: &quot;zh-CN&quot; theme: light: &quot;light&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/light.css dark: &quot;dark&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/dark.css############################### Comments ############################### &gt; end 13.开启站内搜索功能 需要安装插件 1npm i -S hexo-generator-json-content 123search: enable: true service: hexo 14.进阶功能 背景的视差功能 12345678parallax: enable: true position: fixed # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 10000 # Duration (ms) fade: 1500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - #你的背景url 15.给文章添加封面 在你的文章的markdown格式的文件中头部添加以下内容 123456789---title: 标题headimg: 封面的urldate: 日期tags:- 标签categories:- 分类--- 就可以看到封面了，注意不是cover # 四、贼好用的图床网站 薄荷图床 麦克图床 总结 这个主题的开发者实在是太良心了，这么好看的主题配置起来还很简单，官方文档写的也很全，直接五星好评！ 我的_config.volantis.yml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546############################### Navigation Bar ############################### &gt; start# 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fa-solid fa-rss url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 友链 icon: fa-solid fa-link url: friends/ - name: 关于 icon: fa-solid fa-info-circle url: about/ search: Search... # Search bar placeholder############################### Navigation Bar ############################### &gt; endpages: # 友链页面配置 friends: layout_scheme: simple # simple: 简单布局, traditional: 传统布局site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [aplayer, social, license, info, copyright] social: - icon: fas fa-rss url: atom.xml - icon: fas fa-envelope url: mailto:mengfanjun_020906@outlook.com - icon: fab fa-github url: https://github.com/MengFanjun020906 copyright: &#x27;[Copyright © 2017-2022 孟凡钧](/)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27;############################### Cover ############################### &gt; startcover: height_scheme: full # full, half layout_scheme: search # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) display: home: true archive: true others: true # can be written in front-matter &#x27;cover: true&#x27; background: https://alpha.glilmu.com/i/2022/12/05/he1uuk.jpg # background: https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &#x27;MengFanjun的博客&#x27; subtitle: &#x27;&#x27; search: 搜一下 # search bar placeholder features: - name: 主页 icon: # url: / - name: 标签 icon: # url: tags/############################### Cover ############################### &gt; end############################### Sidebar ############################### &gt; startsidebar: position: right # left right # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, webinfo, lastupdate] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://beta.glilmu.com/i/2022/12/05/1xv9ka.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png shape: rectangle # circle, rectangle url: /about/ title: MengFanjun subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - icon: fa-solid fa-envelope url: mailto:mengfanjun_020906@outlook.com - icon: fab fa-github url: https://github.com/MengFanjun020906 # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] sticky: true header: icon: fa-solid fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # music music: class: music display: [desktop, mobile] # [desktop, mobile] pjaxReload: false # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fa-solid fa-folder-open title: 文章分类 url: /blog/categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fa-solid fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fa-solid fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2022/12/04&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; visitcounter: siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # --------------------------------------- # lastupdate widget lastupdate: class: lastupdate display: [desktop, mobile] header: icon: fa-solid fa-clock WISTERIA title: 最近更新 text: class: text display: [desktop] # [desktop, mobile] header: icon: fab fa-github title: 点个赞吧 url: https://github.com/xaoxuu/ content: - &#x27;您的赞对我来说很重要，如果您喜欢本主题，希望能够给下面的项目点个赞来支持一下。&#x27;############################### Sidebar ############################### &gt; end############################### Comments ############################### &gt; startcomments: service: giscus # giscus # https://giscus.app # https://github.com/laymonage/giscus giscus: # 以下配置按照 yml 格式增删填写即可 repo: MengFanjun020906/comments repo-id: R_kgDOIjrvJg category: Announcements category-id: DIC_kwDOIjrvJs4CS6YN mapping: &quot;pathname&quot; reactions-enabled: &quot;1&quot; emit-metadata: &quot;0&quot; lang: &quot;zh-CN&quot; theme: light: &quot;light&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/light.css dark: &quot;dark&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/dark.css############################### Comments ############################### &gt; endsearch: enable: true service: hexoplugins: # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS aplayer: enable: true # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 993524571 # song id / playlist id / album id / search keyword # Optional fixed: true # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: true # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true autoHide: true # hide automaticaly wordcount: enable: true parallax: enable: true position: fixed # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 10000 # Duration (ms) fade: 1500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - https://alpha.glilmu.com/i/2022/12/05/he1uuk.jpg ############################### Article Layout ############################### &gt; start# 文章布局article: # 文章列表页面的文章卡片布局方案 preview: scheme: lanscape # landscape # pin icon for post pin_icon: volantis-static/media/twemoji/assets/svg/1f4cc.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # hide excerpt hide_excerpt: false # show split line or not line_style: solid # hidden, solid, dashed, dotted # show author author: true # true, false # show readmore button readmore: auto # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, wordcount, counter] #启用评论数量需在此添加 # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags, share] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fa-solid fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fa-solid fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: https://gcore.jsdelivr.net/gh/MHG-LAB/cron@gh-pages/bing/bing.jpg # ---------------- # 版权声明组件 (for layout: post) copyright: enable: false permalink: &#x27;本文永久链接是：&#x27; content: - &#x27;博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27; - permalink # 自定义版权组件：精细到文章的版权声明 custom: false # 开启后替代上方内容的版权显示 customData: default: type1 # 默认授权声明 ############################# # 你可以在文章的 front-matter 覆盖默认版权声明 # 配置示例（均可选）： # copyright: # type: type3 # 当前文章版权声明类型 # author: 张三 # 本文作者 # ref: # 原文出处 # title: # 原文出处 - 标题 # url: # 原文出处 - 链接 ############################# rules: type1: text: &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh#&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; desc: 署名-非商业性使用-相同方式共享 4.0 国际。 type2: text: 禁止转载引用 desc: 除非获得原作者的单独授权，任何第三方不得转载！ type3: text: 原作许可协议 desc: 本文转载自他站，转载或引用本文时，请遵守原作许可协议！ type4: text: 来自互联网 desc: 本文来自互联网，未知来源，侵权请联系删除。 type5: text: 允许规范转载 desc: 转载请保留本文转载地址，著作权归作者所有！ type6: text: 允许付费转载 desc: 您可以联系作者通过付费方式获得授权。 # 还能自行添加更多 # ---------------- # 打赏组件 (for layout: post) donate: enable: false images: - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # meta library meta_library: # 默认文章作者（可在 _data/author.yaml 中增加其他作者，并在 front-matter 中设置） # https://volantis.js.org/advanced-settings/#多人协同 author: avatar: https://beta.glilmu.com/i/2022/12/05/1xv9ka.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/apple-touch-icon.png name: MengFanjun url: / # 文章创建日期 date: icon: fa-solid fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fa-solid fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fa-solid fa-folder-open # 文章浏览计数 counter: icon: fa-solid fa-eye unit: &#x27;次浏览&#x27; # waline 文章评论数量 walinecount: icon: fa-solid fa-comment-dots desc: &#x27;条评论&#x27; # 条评论 # artalk 文章评论数量 artalkcount: icon: fa-solid fa-comment-dots desc: &#x27;条评论&#x27; # 条评论 # 文章字数和阅读时长 wordcount: icon_wordcount: fa-solid fa-keyboard icon_duration: fa-solid fa-hourglass-half # 文章标签 tags: icon: fa-solid fa-hashtag # 分享 share: - id: qq img: volantis-static/media/org.volantis/logo/128/qq.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png - id: qzone img: volantis-static/media/org.volantis/logo/128/qzone.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png - id: weibo img: volantis-static/media/org.volantis/logo/128/weibo.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png - id: # qrcode # 当id为qrcode时需要安装插件 npm i hexo-helper-qrcode img: # volantis-static/media/org.volantis/logo/128/wechat.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png - id: # telegram img: # volantis-static/media/org.volantis/logo/128/telegram.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.png############################### Article Layout ############################### &gt; endcustom_css: fontfamily: logofont: fontfamily: &#x27;&quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;Varela Round&#x27; url: volantis-static/media/fonts/VarelaRound/VarelaRound-Regular.ttf # https://gcore.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;UbuntuMono, &quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf # https://gcore.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &#x27;Menlo, UbuntuMono, Monaco&#x27; name: &#x27;Monaco&#x27; url: volantis-static/media/fonts/Monaco/Monaco.ttf # https://gcore.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf weight: normal style: normalcolor_scheme: # ------------ # 通用颜色 common: # 主题色 theme: &#x27;#44D7B6&#x27; # 链接色 link: &#x27;#2196f3&#x27; # 按钮色 button: &#x27;#44D7B6&#x27; # 鼠标放到交互元素上时的色 hover: &#x27;#ff5722&#x27; # 主题色块内部的文字颜色 inner: &#x27;#fff&#x27; # 选中区域文字的背景颜色 selection: &#x27;alpha(#2196f3, 0.2)&#x27; # ------------ # 亮色主题（默认） light: # 网站背景色 site_bg: &#x27;#f4f4f4&#x27; # 网站背景上的文字 site_inner: &#x27;#fff&#x27; # 网站页脚文字 site_footer: &#x27;#fff&#x27; # 卡片背景色 card: &#x27;#fff&#x27; # 卡片上的普通文字 text: &#x27;#444&#x27; # 区块和代码块背景色 block: &#x27;#f6f6f6&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#f6f6f6&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#444&#x27; h2: &#x27;#444&#x27; h3: &#x27;#444&#x27; h4: &#x27;#444&#x27; h5: &#x27;#444&#x27; h6: &#x27;#444&#x27; p: &#x27;#444&#x27; # 列表文字 list: &#x27;#666&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #000, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # ------------ # 暗色主题 dark: # 网站背景色 site_bg: &#x27;#222&#x27; # 网站背景上的文字 site_inner: &#x27;#eee&#x27; # 网站页脚文字 site_footer: &#x27;#aaa&#x27; # 卡片背景色 card: &#x27;#444&#x27; # 卡片上的普通文字 text: &#x27;#eee&#x27; # 区块和代码块背景色 block: &#x27;#3a3a3a&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#343a3c&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#eee&#x27; h2: &#x27;#eee&#x27; h3: &#x27;#ddd&#x27; h4: &#x27;#ddd&#x27; h5: &#x27;#ddd&#x27; h6: &#x27;#ddd&#x27; p: &#x27;#bbb&#x27; # 列表文字 list: &#x27;#aaa&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #fff, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # 夜间图片亮度 brightness: 70% body: effect: [blur] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true analytics: busuanzi: https://gcore.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js leancloud: # 请使用自己的 id &amp; key 以防止数据丢失 app_id: # 应用 APP_ID app_key: # 应用 APP_KEY custom_api_server: # 国际版一般不需要写，除非自定义了 API Server","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://mengfanjun020906.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"html","slug":"html","permalink":"https://mengfanjun020906.github.io/tags/html/"}]},{"title":"数字信号处理MATLAB作业四（题目+解答代码）","slug":"数字信号处理MATLAB作业四（题目+解答代码）","date":"2022-12-06T08:36:04.000Z","updated":"2023-03-24T05:52:34.649Z","comments":true,"path":"2022/12/06/数字信号处理MATLAB作业四（题目+解答代码）/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86MATLAB%E4%BD%9C%E4%B8%9A%E5%9B%9B%EF%BC%88%E9%A2%98%E7%9B%AE+%E8%A7%A3%E7%AD%94%E4%BB%A3%E7%A0%81%EF%BC%89/","excerpt":"","text":"1234567891011121314151617181920clearclose allclcfs=1000;fc=200;fr=300;T=0.001; wp1=2*pi*fc;wr1=2*pi*fr; [N1,wn1]=buttord(wp1,wr1,1,25,&#x27;s&#x27;); [B1,A1]=butter(N1,wn1,&#x27;s&#x27;); [num1,den1]=impinvar(B1,A1,fs); [h1,w]=freqz(num1,den1); wp2=2*fs*tan(2*pi*fc/(2*fs)); wr2=2*fs*tan(2*pi*fr/(2*fs)); [N2,wn2]=buttord(wp2,wr2,1,25,&#x27;s&#x27;); [B2,A2]=butter(N2,wn2,&#x27;s&#x27;); [num2,den2]=bilinear(B2,A2,fs); [h2,w]=freqz(num2,den2); f=w/(2*pi)*fs; plot(f,20*log10(abs(h1)),&#x27;-.&#x27;,f,20*log10(abs(h2)),&#x27;-&#x27;); axis([0,500,-80,10]);grid; xlabel(&#x27;频率/Hz&#x27;);ylabel(&#x27;幅度/dB&#x27;);title(&#x27;巴特沃思数字低通滤波器&#x27;); legend(&#x27;脉冲响应不变法&#x27;,&#x27;双线性变换法&#x27;); 在这里插入图片描述 1234567891011121314151617181920212223clearclose allclcwc=2*pi*1200;wr=2*pi*2000;rp=0.5;rs=40;fs=8000;w1=2*fs*tan(wc/(2*fs)); w2=2*fs*tan(wr/(2*fs)); [Nb,wn]=buttord(w1,w2,rp,rs,&#x27;s&#x27;);[B,A]=butter(Nb,wn,&#x27;s&#x27;); [num1,den1]=bilinear(B,A,fs); [h1,w]=freqz(num1,den1); [Nc,wn]=cheb1ord(w1,w2,rp,rs,&#x27;s&#x27;);[B,A]=cheby1(Nc,rp,wn,&#x27;s&#x27;); [num2,den2]=bilinear(B,A,fs); [h2,w]=freqz(num2,den2); [Ne,wn]=ellipord(w1,w2,rp,rs,&#x27;s&#x27;);[B,A]=ellip(Ne,rp,rs,wn,&#x27;low&#x27;,&#x27;s&#x27;); [num3,den3]=bilinear(B,A,fs); [h3,w]=freqz(num3,den3); f=w/pi*4000; plot(f,20*log10(abs(h1)),&#x27;-&#x27;,f,20*log10(abs(h2)),&#x27;--&#x27;,f,20*log10(abs(h3)),&#x27;-.&#x27; ); axis([0,3000,-100,10]);grid; xlabel(&#x27;频率/Hz&#x27;); ylabel(&#x27;幅度/dB&#x27;); title(&#x27;三种数字低通滤波器&#x27;); legend(&#x27;巴特沃思数字低通滤波器&#x27;,&#x27;切比雪夫数字低通滤波器&#x27;,&#x27;椭圆数字低通滤波器&#x27;); 12345678910111213141516171819202122232425clearclose allclcwc=[2*pi*2000,2*pi*3000];wr=[2*pi*1500,2*pi*6000];rp=3;rs=20;fs=30000; [N,wn]=buttord(wc,wr,rp,rs,&#x27;s&#x27;); [B,A]=butter(N,wn,&#x27;s&#x27;); [num1,den1]=impinvar(B,A,fs); [h1,w]=freqz(num1,den1); w1=2*fs*tan(2*pi*2000/(2*fs)); w2=2*fs*tan(2*pi*3000/(2*fs)); wr1=2*fs*tan(2*pi*1500/(2*fs)); wr2=2*fs*tan(2*pi*6000/(2*fs)); [N,wn]=buttord([w1,w2],[wr1,wr2],rp,rs,&#x27;s&#x27;); [B,A]=butter(N,wn,&#x27;s&#x27;); [num2,den2]=bilinear(B,A,fs); [h2,w]=freqz(num2,den2); f=w/pi*15000; plot(f,20*log10(abs(h1)),&#x27;-.&#x27;,f,20*log10(abs(h2)),&#x27;-&#x27;); axis([500,7000,-30,10]);grid; xlabel(&#x27;频率/Hz&#x27;);ylabel(&#x27;幅度/dB&#x27;); title(&#x27;巴特沃思数字低通滤波器&#x27;); legend(&#x27;脉冲响应不变法&#x27;,&#x27;双线性变换法&#x27;); 12345678910clearclose allclcN=15;wn=[0.3,0.5];window=hanning(N+1); b=fir1(N,wn,window); [H,w]=freqz(b); subplot(2,1,1);plot(w/pi,20*log10(abs(H)));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;幅频响应&#x27;); subplot(2,1,2);plot(w/pi,angle(H));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;相位&#x27;);title(&#x27;相位响应&#x27;); 12345678910clearclose allclcN=45;wn=[0.3,0.5];window=hanning(N+1); b=fir1(N,wn,window); [H,w]=freqz(b); subplot(2,1,1);plot(w/pi,20*log10(abs(H)));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;幅频响应&#x27;); subplot(2,1,2);plot(w/pi,angle(H));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;相位&#x27;);title(&#x27;相位响应&#x27;); 在这里插入图片描述 1234567891011clearclose allclc%矩形窗N=15N=input(&#x27;请输入 N 的值\\n&#x27;);wn=[0.3,0.5];b=fir1(N,wn,boxcar(N+1)); [H,w]=freqz(b,1,512); subplot(2,1,1);plot(w/pi,20*log10(abs(H)));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;幅频响应&#x27;); subplot(2,1,2);plot(w/pi,angle(H));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;相位&#x27;);title(&#x27;相频响应&#x27;); 在这里插入图片描述 12345678910111213clearclose allclc%布莱克曼窗：（N=15 时）N=input(&#x27;请输入 N 的值\\n&#x27;);wn=[0.3,0.5]; window=blackman(N+1); b=fir1(N,wn,window); [H,w]=freqz(b); subplot(2,1,1);plot(w/pi,20*log10(abs(H)));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;幅频响应&#x27;); subplot(2,1,2);plot(w/pi,angle(H));grid; xlabel(&#x27;归一化频率&#x27;);ylabel(&#x27;相位&#x27;);title(&#x27;相频响应&#x27;); 在这里插入图片描述","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"Pytorch深度学习和目标检测实战笔记","slug":"Pytorch深度学习和目标检测实战笔记","date":"2022-12-05T05:31:43.506Z","updated":"2023-03-24T11:58:57.549Z","comments":true,"path":"2022/12/05/Pytorch深度学习和目标检测实战笔记/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/05/Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"原视频链接：PyTorch深度学习目标检测入门实战系列【土堆 x 布尔艺数】 下载VOC数据集 下载地址：http://host.robots.ox.ac.uk/pascal/VOC/ 数据集里面都有什么 在这里插入图片描述 Annotations 标注文件夹(包含xml文件，图片的各种信息) ImageSets 图片集合(主要关注Main文件夹的内容) JPEGImages 数据集包含的图片 SegmentationClass 语义分割图片 SegmentationObject 实例分割图片 #### 需要关注的是ImageSets 打开ImageSets-Main-aeroplane_train.txt 可以看到32和33为1，在JPEGImages中，32号的图片 打开Annotations 打开Annotations-000032.xml 123456789101112&lt;object&gt; &lt;name&gt;aeroplane&lt;/name&gt;&lt;图片类别名字&gt; &lt;pose&gt;Frontal&lt;/pose&gt;&lt;拍摄物体的角度，可以看出是在前面拍的&gt; &lt;truncated&gt;0&lt;/truncated&gt;&lt;有无被截断，0是无&gt; &lt;difficult&gt;0&lt;/difficult&gt;&lt;识别出来是否困难，0代表不困难&gt; &lt;bndbox&gt; &lt;xmin&gt;104&lt;/xmin&gt;&lt;物体在图片上横坐标最小值&gt; &lt;ymin&gt;78&lt;/ymin&gt;&lt;物体在图片上纵坐标最小值&gt; &lt;xmax&gt;375&lt;/xmax&gt;&lt;物体在图片上横坐标最大值&gt; &lt;ymax&gt;183&lt;/ymax&gt;&lt;物体在图片上纵坐标最大值&gt; &lt;/bndbox&gt;&lt;/object&gt; 下载COCO数据集 官网：https://cocodataset.org/#home 解读Annotations 从第一行开始扫描，是46格像素，到第三行才出现白色的像素，一行一行的扫描 \"counts\":[147,3,1......] 未完待续","categories":[{"name":"Pytorch学习","slug":"Pytorch学习","permalink":"https://mengfanjun020906.github.io/categories/Pytorch%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"神经网络","slug":"神经网络","permalink":"https://mengfanjun020906.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"学习通信原理之——什么是傅立叶级数","slug":"学习通信原理之——什么是傅立叶级数","date":"2022-12-05T05:01:29.033Z","updated":"2023-03-24T12:03:16.280Z","comments":true,"path":"2022/12/05/学习通信原理之——什么是傅立叶级数/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/05/%E5%AD%A6%E4%B9%A0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B9%8B%E2%80%94%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AF%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0/","excerpt":"","text":"要学习通信，一定绕不开的就是傅里叶级数和傅里叶变换，之前学信号与系统的时候没有好好学，这里看了B站的网课，豁然开朗，所以特地来写一篇学习笔记，来激励自己，也算是检验自己学习成果了。 B站网课链接：https://www.bilibili.com/video/BV1Et411R78v?share_source=copy_web Part 1 三角函数的正交性 首先要介绍的就是三角函数系：集合： \\[ \\left\\{ 1,\\sin x.\\cos x,sin2x,\\cos 2x,......\\sin nx,\\cos nx \\right\\} n=0,1,2,3,...... \\] 此处为什么没有0呢，因为 \\[ \\sin \\left( 0\\cdot x \\right) =0 \\\\ \\cos \\left( 0\\cdot x \\right) =0 \\] 所以省略了0 三角函数的正交性（就是垂直）： \\[ \\int_{-\\pi}^{\\pi}{\\sin \\left( nx \\right) \\cos \\left( mx \\right) \\mathrm{d}x}\\left( n\\ne m \\right)=0 \\\\ \\int_{-\\pi}^{\\pi}{\\cos \\left( nx \\right) \\cos \\left( mx \\right) \\mathrm{d}x}\\left( n\\ne m \\right)=0 \\] 那么该如何证明呢？ 证明过程： 因为 \\[ \\cos \\left( nx \\right) \\cdot \\cos \\left( mx \\right) =\\frac{1}{2}\\left[ \\cos \\left( n-m \\right) x+\\cos \\left( n+m \\right) x \\right] \\] \\[ \\begin{aligned} \\int_{-\\pi}^{\\pi}{\\cos \\left( nx \\right) \\cos \\left( mx \\right) \\mathrm{d}x}\\left( n\\ne m \\right) &amp; =\\frac{1}{2}\\left[ \\int_{-\\pi}^{\\pi}{\\cos \\left( n-m \\right) x\\mathrm{d}x+\\int_{-\\pi}^{\\pi}{\\cos \\left( n+m \\right) x\\mathrm{d}x}} \\right] \\\\ &amp;=\\frac{1}{2}\\left[ \\frac{\\sin \\left( n-m \\right) x}{\\left( n-m \\right)}\\mid_{-\\pi}^{\\pi}+\\frac{\\sin \\left( n+m \\right) x}{\\left( n+m \\right)}\\mid_{-\\pi}^{\\pi} \\right] \\\\ &amp;=0 \\end {aligned} \\] \\[ IF\\,\\,\\left( m=n \\right) \\int_{-\\pi}^{\\pi}{\\cos \\left( nx \\right) \\cos \\left( mx \\right) \\mathrm{d}x}=\\frac{1}{2}\\left[ \\int_{-\\pi}^{\\pi}{1\\mathrm{d}x+}\\int_{-\\pi}^{\\pi}{\\cos \\left( 2nx \\right) \\mathrm{d}x} \\right] =\\frac{1}{2}\\int_{-\\pi}^{\\pi}{1\\mathrm{d}x=\\pi} \\] 上式 \\[ \\cos \\left( 2nx \\right) =\\cos \\left( 0\\cdot x \\right) \\cdot \\cos \\left( 2nx \\right) =0 \\] 则最后只剩前一项 证明完毕 Part 2 周期为\"2π\"的函数展开为傅里叶级数 \\[ T=2\\pi \\,\\, ~~~~~~~~~f\\left( x \\right) =f\\left( x+2\\pi \\right) \\] 这是傅里叶级数展开的一种写法 \\[ f\\left( x \\right) =\\sum_{n=0}^{\\infty}{\\left( a_n\\cos nx+b_n\\sin nx \\right)} \\] 但我们可以看到，大部分书中都是这么写的 \\[ f\\left( x \\right) =\\frac{a_0}{2}+\\sum_{n=0}^{\\infty}{\\left( a_n\\cos nx+b_n\\sin nx \\right)} \\] 看到了两式的a0不一样，为什么呢？ 1.开始计算a0 首先式子两边进行积分 \\[ f\\left( x \\right) =\\sum_{n=0}^{\\infty}{\\left( a_n\\cos nx+b_n\\sin nx \\right)} \\] 得到 \\[ \\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\mathrm{d}x=}\\int_{-\\pi}^{\\pi}{a_0\\mathrm{d}x}+\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( a_n\\cos nx \\right)}\\mathrm{d}x}+\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( b_n\\sin nx \\right)}\\mathrm{d}x} \\] 我们可以将an和bn提出到积分符号前，得到 \\[ \\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\mathrm{d}x=}\\int_{-\\pi}^{\\pi}{a_0\\mathrm{d}x}+a_n\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( \\cos nx \\right)}\\mathrm{d}x}+b_n\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( \\sin nx \\right)}\\mathrm{d}x} \\] 接下来，我们可以将cosnx和sinnx视作1cosnx和1sinnx，利用三角函数的正交性将这两项化为0 我们可以得到 \\[ \\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\mathrm{d}x=}a_0\\int_{-\\pi}^{\\pi}{1\\mathrm{d}x=2\\pi a_0} \\] 最后，我们将a0可以解出， \\[ a_0=\\frac{1}{2\\pi}\\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\mathrm{d}x} \\] 与前式对照 \\[ f\\left( x \\right) =\\frac{a_0}{2}+\\sum_{n=0}^{\\infty}{\\left( a_n\\cos nx+b_n\\sin nx \\right)} \\] 为什么那里的a0有1/2呢，其实就是为了看着方便，将a0变为 \\[ a_0=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\mathrm{d}x} \\] 现在就感觉有点蒙蔽了，你这个a0带入到式子中是除以2了，那a0的原本的值就变化了，这里要强调一点，我们之前算出来的a0，一直都是 \\[ a_0=\\frac{1}{2\\pi}\\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\mathrm{d}x} \\] 这里只是为了看起来方便，就加上了1/2，所以，一句话总结 此a0非彼a0 2.计算an 先两边同乘cosmx 两边再进行积分 可以得到如下式子 \\[ \\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\cos mx\\mathrm{d}x=}\\int_{-\\pi}^{\\pi}{\\frac{a_0}{2}\\cos mx\\mathrm{d}x}+\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( a_n\\cos nx\\cos mx \\right)}\\mathrm{d}x}+\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( b_n\\sin nx\\cos mx \\right)}\\mathrm{d}x} \\] 同理，根据三角函数的正交性，我们可以得到 \\[ \\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\cos mx\\mathrm{d}x=}\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( a_n\\cos nx\\cos mx \\right)}\\mathrm{d}x} \\] 当m=n时，整个式子就变成了 \\[ \\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\cos mx\\mathrm{d}x=}\\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infty}{\\left( a_n\\cos ^2nx \\right)}\\mathrm{d}x} \\] 根据三角函数呀的正交性，可以将式子化为 \\[ \\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\cos mx\\mathrm{d}x=}a_n\\pi \\] 所以，计算出an \\[ a_n=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{f\\left( x \\right) \\cos mx\\mathrm{d}x} \\] 后面有时间一定回来填坑","categories":[{"name":"通信原理","slug":"通信原理","permalink":"https://mengfanjun020906.github.io/categories/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"我参加第七届NVIDIA Sky Hackathon——训练ASR模型","slug":"我参加第七届NVIDIA Sky Hackathon——训练ASR模型","date":"2022-12-02T02:39:21.000Z","updated":"2023-03-24T05:53:40.877Z","comments":true,"path":"2022/12/02/我参加第七届NVIDIA Sky Hackathon——训练ASR模型/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/02/%E6%88%91%E5%8F%82%E5%8A%A0%E7%AC%AC%E4%B8%83%E5%B1%8ANVIDIA%20Sky%20Hackathon%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83ASR%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"如何从0开始训练自己的ASR模型 第一步 获取NGC密钥 第二步 配置Ubuntu22.04的运行环境 第三步 开始训练ASR模型 前言 Sky Hackathon由NVIDIA发起并主办，项目旨在帮助在校学生、深度学习开发者在NVIDIA Jetson边缘高性能计算产品上部署和优化人工智能应用。在经验丰富的GPU导师指导下，通过黑客松竞赛的方式学习业界所需的深度学习相关应用开发及其并行计算技能，激发学生们的学习兴趣与创新力。 NVIDIA工程师将亲自为参赛队伍带来他们对最新的深度学习与边缘计算方面的理解、行业的趋势与最新的技术应用及最新开发工具实战技能知识，在训练营中对参赛队伍进行指导。 Sky Hackathon为参加者提供了一个难得的学习并实操的机会，学习嵌入式深度学习开发所需的动手技能， 通过使用NVIDIA最新的编程模型、库和工具以加速和优化他们的AI应用程序。 相关网站：第七届NVIDIA SKy Hackathon 比赛文件资料链接： https://pan.baidu.com/s/1UADeDey1OsTvEOPE5f_2CA?pwd=a647 提取码: a647 一、获取NGC密钥 进入NGC网站：NVIDIA NGC 点击注册 登陆之后点击右上角set up 点击Get API Key 点击Generate API Key 这里就是你的API Key了 二、配置Ubuntu22.04的运行环境 1.安装 NVIDIA 驱动 460 以上版本 代码如下： 1234sudo apt-get install software-properties-common sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get install nvidia-driver-460 sudo reboot # 重启之后才会生效，重启后执行 nvidia-smi 检查驱动 2.安装 docker 与 nvidia-docker2 代码如下(安装 docker)： 123456sudo apt-get install -y ca-certificates curl gnupg lsb-release curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/dockerarchive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs)stable&quot; | ¥ $ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null sudo apt-get updatesudo apt-get install -y docker-ce docker-ce-cli containerd.io# 测试安装 sudo docker run hello-world 代码如下(安装 nvidia-docker2)： 123456curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -distribution=$(. /etc/os-release;echo $ID$VERSION_ID)curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-docker2 sudo systemctl restart docker # 测试安装 sudo docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi 如果出现以下信息，表示 docker 与 nvidia-docker2 都安装完成 &gt;代码如下(登录 NGC：只要登录一次就行)： 1sudo docker login -u &#x27;$oauthtoken&#x27; --password-stdin nvcr.io &lt;&lt;&lt; &#x27;申请的密钥&#x27; 3.安装 MiniConda3 与 Jupyter 开发环境 代码如下(安装 MiniConda)： 123456789# 用国内清华源 export DL_SITE=https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda # 用原厂的源 export DL_SITE=https://repo.anaconda.com/miniconda # 下载安装包wget -c $DL_SITE/Miniconda3-py38_4.10.3-Linux-x86_64.sh # 执行安装，全部按照预设路径与”yes”选项 bash Miniconda3-py38_4.10.3-Linux-x86_64.sh # 启动 Conda source ~/.bashrc 代码如下(安装 Jupyter Lab)： 123pip install jupyter jupyterlab # 设置登录密码export PW=’你自己要设置的密码‘python3 -c &quot;from notebook.auth.security import set_password; set_password(&#x27;$PW&#x27;,&#x27;$HOME/.jupyter/jupyter_notebook_config.json&#x27;)&quot; 4.安装 NeMo 1.4.0 通过 pip 安装 GPU 版本 Pytorch 参考链接 https://pytorch.org/get-started/previous-versions/ 例如 Pytorch1.12.1 版本则安装指令如下： 1pip install torch==1.12.1+cu113 torchvision==0.13.1+cu113 torchaudio==0.12.1 --extra-indexurl https://download.pytorch.org/whl/cu113 代码如下(安装 NeMo)： 1234567sudo apt-get update &amp;&amp; sudo apt-get install -y libsndfile1 ffmpeg pip install Cython pip install --user pytest-runner pip install rosa numpy==1.19.4 pip install torchmetrics==0.6.0 pip install nemo_toolkit[all]==1.4.0 pip install ASR-metrics 代码如下(检测NeMo)： 123pythonimport nemoimport nemo.collections.asr as nemo_asr 若没有报错表示安装成功（warning 不用理会） 5.安装 TAO 模型训练优化工具：用 Python 与 Virtualenv 代码如下(安装 virtualenv 虚拟环境：这是确保 TAO 有独立的 Python 执行环境，为配合 Nemo 工 具使用 Python 3.8 的 MiniConda 安装，因此这里的 virtualenv 也绑定在 MiniConda 的 Python3 上)： 12345678910pip install virtualenv virtualenvwrapper # 创建目录用来存放虚拟环境 mkdir $HOME/.virtualenvs # 在~/.bashrc 中添加行： export WORKON_HOME=$HOME/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=$HOME/miniconda3/bin/python3 source $HOME/miniconda3/bin/virtualenvwrapper.sh # 保存并退出 source ~/.bashrc # 创建名为”tao”的 Virtualenv mkvirtualenv tao -p $HOME/miniconda3/bin/python3 代码如下(安装 TAO 模型训练工具)： 1234567# 确认在 ”tao” 的 Virtualenv 环境下，如果不在的话就执行以下指令 workon tao # 安装 nvidia-pyindex 与 nvidia-tao pip3 install nvidia-pyindex pip3 install nvidia-tao # 检查安装 tao info 代码如下(启动 TAO 模型训练工具 Jupyter 交互界面)： 1234# 启动名为 “tao” 的 virtualenv workon tao # 进入工作目录并启动 Jupyter Lab cd ~/hackathon &amp;&amp; jupyter lab --ip 0.0.0.0 --port 8888 --allow-root 输入您先前设置的密码就能进去，进入 Jupyter Lab 之后是以~/hackathon 为根目录 代码如下(启动Jupyter)： 1jupyter lab --ip 0.0.0.0 --port 8888 --allow-root 代码如下(进入Jupyter)： 在ubuntu的终端输入ip address 12345678910111213141516171819202122232425262728293031323334353637381: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: enp8s0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether b4:a9:fc:6c:6b:5e brd ff:ff:ff:ff:ff:ff3: wlp0s20f3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 40:ec:99:20:b5:61 brd ff:ff:ff:ff:ff:ff inet 10.20.113.129/22 brd 10.20.115.255 scope global wlp0s20f3 valid_lft forever preferred_lft forever inet 192.168.1.206/24 brd 192.168.1.255 scope global dynamic noprefixroute wlp0s20f3 valid_lft 79725sec preferred_lft 79725sec inet6 2409:8a02:6068:880:4691:5ea5:dbf9:3151/64 scope global temporary dynamic valid_lft 259087sec preferred_lft 79410sec inet6 2409:8a02:6068:880:ff41:1037:c6e5:bd3b/64 scope global dynamic mngtmpaddr noprefixroute valid_lft 259087sec preferred_lft 259087sec inet6 fe80::f0ce:78ab:12c0:d59e/64 scope link noprefixroute valid_lft forever preferred_lft forever4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:10:5d:d6:56 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:10ff:fe5d:d656/64 scope link valid_lft forever preferred_lft forever22: vethd32e2b1@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether f6:73:02:10:2c:98 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::f473:2ff:fe10:2c98/64 scope link valid_lft forever preferred_lft forever30: veth442d3b9@if29: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether 1e:66:e8:63:24:11 brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::1c66:e8ff:fe63:2411/64 scope link valid_lft forever preferred_lft forever34: veth7c78114@if33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether 9a:a2:4d:ac:13:0a brd ff:ff:ff:ff:ff:ff link-netnsid 2 inet6 fe80::98a2:4dff:feac:130a/64 scope link valid_lft forever preferred_lft forever 我这里的ip是192.168.1.206 在浏览器里面输入 1192.168.1.206:8888 就能进入Jupyter Lab了 三、开始训练ASR模型 1.制作数据集 数据集格式——json文件格式 12345&#123;&quot;audio_filepath&quot;:&quot;your_path&quot;,&quot;duration&quot;:time,&quot;text&quot;:&quot;your_text&quot;&#125; 利用librosa获取其语音 注意：音频为单声道，wav格式，采样率建议44100HZ 1234# 导入librosa音频工具包获取音频时长,用于制作语音数据集import librosa time = librosa.get_duration(filename=&quot;你音频的路径&quot;)print(time) 最后数据集文件结构 ├── Datasets │├── audio.wav 所有的语音文件(wav单声道格式) │├── xxx.json 制作好的json文件 2.对其进行训练 导入基本包 123456import nemonemo.__version__import torchtorch.__version__torch.cuda.is_available()import nemo.collections.asr as nemo_asr 加载数据清单 123#将制作好的json格式的数据清单加载进来train_manifest = &quot;your_path/xxx.json&quot;test_manifest = &quot;your_path/xxx.json&quot; 加载quartznet文件 1234567891011# 使用YAML读取quartznet模型配置文件try: from ruamel.yaml import YAMLexcept ModuleNotFoundError: from ruamel_yaml import YAMLconfig_path =&quot;/root/config/quartznet_15x5_zh.yaml&quot;yaml = YAML(typ=&#x27;safe&#x27;)with open(config_path) as f: params = yaml.load(f)print(params) 将数据清单传给配置文件 12params[&#x27;model&#x27;][&#x27;train_ds&#x27;][&#x27;manifest_filepath&#x27;]=train_manifestparams[&#x27;model&#x27;][&#x27;validation_ds&#x27;][&#x27;manifest_filepath&#x27;]=test_manifest 使用迁移学习的方法训练模型 12345quartznet.setup_training_data(train_data_config=params[&#x27;model&#x27;][&#x27;train_ds&#x27;])quartznet.setup_validation_data(val_data_config=params[&#x27;model&#x27;][&#x27;validation_ds&#x27;])import pytorch_lightning as pl trainer = pl.Trainer(gpus=1,max_epochs=200)trainer.fit(quartznet)#调用‘fit’方法开始训练 保存训练好的模型 1quartznet.save_to(&quot;7th_asr_model.nemo&quot;)# 将训练好的模型保存为.nemo格式 将训练好的模型进行重载 1try_model_1 = nemo_asr.models.EncDecCTCModel.restore_from(&quot;7th_asr_model.nemo&quot;)#对模型进行重新加载 预测语音 12asr_result = try_model_1.transcribe(paths2audio_files=[&quot;your_wav_path&quot;])print(asr_result) 计算其正确率 12345from ASR_metrics import utils as metricss1 = &quot;请检测出纸箱果皮和瓶子&quot;#指定正确答案s2 = &quot; &quot;.join(asr_result)#识别结果print(&quot;字错率:&#123;&#125;&quot;.format(metrics.calculate_cer(s1,s2)))#计算字错率cerprint(&quot;准确率:&#123;&#125;&quot;.format(1-metrics.calculate_cer(s1,s2)))#计算准确率accuracy 总结 以上就是第七届NVIDIA Sky Hackathon的配置环境和训练ASR模型的部分，在制作时要注意json文件的格式，还有音频的格式，这些细小的部分都可能成为bug的发生地","categories":[{"name":"The 7th Sky Hackathon","slug":"The-7th-Sky-Hackathon","permalink":"https://mengfanjun020906.github.io/categories/The-7th-Sky-Hackathon/"}],"tags":[{"name":"Nvidia","slug":"Nvidia","permalink":"https://mengfanjun020906.github.io/tags/Nvidia/"},{"name":"人工智能","slug":"人工智能","permalink":"https://mengfanjun020906.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"大数据","slug":"大数据","permalink":"https://mengfanjun020906.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"我参加第七届NVIDIA Sky Hackathon——训练CV模型","slug":"我参加第七届NVIDIA Sky Hackathon——训练CV模型","date":"2022-12-02T02:39:21.000Z","updated":"2023-03-24T06:07:43.841Z","comments":true,"path":"2022/12/02/我参加第七届NVIDIA Sky Hackathon——训练CV模型/","link":"","permalink":"https://mengfanjun020906.github.io/2022/12/02/%E6%88%91%E5%8F%82%E5%8A%A0%E7%AC%AC%E4%B8%83%E5%B1%8ANVIDIA%20Sky%20Hackathon%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83CV%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"如何从0开始训练自己的CV模型 第一步 配置基本环境(在上一篇已经配置了我参加第七届NVIDIA Sky Hackathon——训练ASR模型 ) 第二步 利用labelimg制作图像数据集 第三步 开始训练resnet18模型 前言 Sky Hackathon由NVIDIA发起并主办，项目旨在帮助在校学生、深度学习开发者在NVIDIA Jetson边缘高性能计算产品上部署和优化人工智能应用。在经验丰富的GPU导师指导下，通过黑客松竞赛的方式学习业界所需的深度学习相关应用开发及其并行计算技能，激发学生们的学习兴趣与创新力。 NVIDIA工程师将亲自为参赛队伍带来他们对最新的深度学习与边缘计算方面的理解、行业的趋势与最新的技术应用及最新开发工具实战技能知识，在训练营中对参赛队伍进行指导。 Sky Hackathon为参加者提供了一个难得的学习并实操的机会，学习嵌入式深度学习开发所需的动手技能， 通过使用NVIDIA最新的编程模型、库和工具以加速和优化他们的AI应用程序。 例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。 相关网站：第七届NVIDIA SKy Hackathon 比赛文件资料链接： https://pan.baidu.com/s/1UADeDey1OsTvEOPE5f_2CA?pwd=a647 提取码: a647 一、利用labelimg制作图像数据集 1.安装labelimg 1pip install labelimg -i https://pypi.tuna.tsinghua.edu.cn/simple 2.开始数据标注 打开你的图像目录 选择Pascal VOC格式进行标注 保存后会生成xml格式文件 1234567891011121314151617181920212223242526&lt;annotation&gt; &lt;folder&gt;JPEGImages&lt;/folder&gt; &lt;filename&gt;cardboard2.jpg&lt;/filename&gt; &lt;path&gt;/your_path&lt;/path&gt; &lt;source&gt; &lt;database&gt;Unknown&lt;/database&gt; &lt;/source&gt; &lt;size&gt; &lt;width&gt;167&lt;/width&gt; &lt;height&gt;127&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;name&gt;cardboard&lt;/name&gt; &lt;pose&gt;Unspecified&lt;/pose&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;36&lt;/xmin&gt; &lt;ymin&gt;5&lt;/ymin&gt; &lt;xmax&gt;131&lt;/xmax&gt; &lt;ymax&gt;119&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt;&lt;/annotation&gt; 3.将VOC格式数据集转为KITTI数据集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# -*- coding: utf-8 -*-import sysfrom os import listdirfrom os.path import isfile, isdir, join, dirname, splitext, basenameimport xml.etree.ElementTree as ETpath=&quot;&quot;class XMLReader: def __init__(self, path): file = open(path, &#x27;r&#x27;) self.path = path self.content = file.read() self.root = ET.fromstring(self.content) self.template = &quot;&#123;name&#125; 0.00 0 0.0 &#123;xmin&#125;.00 &#123;ymin&#125;.00 &#123;xmax&#125;.00 &#123;ymax&#125;.00 0.0 0.0 0.0 0.0 0.0 0.0 0.0&quot; def get_filename(self): return splitext(basename(self.path))[0] def get_dir(self): return dirname(self.path) def get_objects(self): objects = [] for object in self.root.findall(&quot;object&quot;): objects.append(&#123; &quot;name&quot; : object.find(&quot;name&quot;).text, &quot;xmin&quot; : object.find(&quot;bndbox&quot;).find(&quot;xmin&quot;).text, &quot;ymin&quot; : object.find(&quot;bndbox&quot;).find(&quot;ymin&quot;).text, &quot;xmax&quot; : object.find(&quot;bndbox&quot;).find(&quot;xmax&quot;).text, &quot;ymax&quot; : object.find(&quot;bndbox&quot;).find(&quot;ymax&quot;).text &#125;) return objects def fill_template(self, object): return self.template.format(**object) def export_kitti(self): objects = self.get_objects() #Skip empty if len(objects) == 0: return False file = open(join(self.get_dir(), self.get_filename()) + &quot;.txt&quot;, &#x27;w&#x27;) for object in objects[:-1]: file.write(self.fill_template(object) + &quot;\\n&quot;) # Write last without &#x27;\\n&#x27; file.write(self.fill_template(objects[-1])) file.close() return Truedef process_file(path): xml_reader = XMLReader(path) return xml_reader.export_kitti()def get_directory_xml_files(dir): return [join(dir, f) for f in listdir(dir) if isfile(join(dir, f)) and splitext(f)[1].lower() == &quot;.xml&quot;]def check_argv(argv): return len(argv) &gt; 1def main(): if not check_argv(sys.argv): print(&quot;Wrong arguments. You should specify xml files or directory with xml files&quot;) # remove script name args = sys.argv[1:] processed_file_count = 0 for path in args: files = [] if isfile(path): files.append(path) elif isdir(path): files += get_directory_xml_files(path) for file in files: if process_file(file): processed_file_count += 1 print(&quot;Finished. &#123;0&#125; Files are processed&quot;.format(processed_file_count))if __name__ == &quot;__main__&quot;: main() 二、开始训练resnet18模型 1. 设置训练环境和路径 代码如下（示例）： 当我们使用训练模型的时候，需要从NGC官网申请一个API Key。这个Key将和您训练的模型进行绑定。 Tao Toolkit可以直接在您计算机系统的环境下执行，它会自动启动docker，并加载相关工具。我们需要设置两套文件地址： LOCAL_PROJECT_DIR--&gt;您计算机系统中的实验文档存放地址 USER_EXPERIMENT_DIR--&gt;docker系统中的实验文档存放地址 在下面的步骤中，我们会将他们形成映射，您只需要操作你计算机系统中地址就好，无需管理docker系统中的地址 123456789101112131415161718192021# Setting up env variables for cleaner command line commands.import osprint(&quot;Please replace the variable with your key.&quot;)%env KEY=your_key%env GPU_INDEX=0%env USER_EXPERIMENT_DIR=/your_path/CV%env DATA_DOWNLOAD_DIR=/your_path/CV/data%env LOCAL_PROJECT_DIR=/your_path/CVos.environ[&quot;LOCAL_DATA_DIR&quot;] = os.path.join(os.getenv(&quot;LOCAL_PROJECT_DIR&quot;, os.getcwd()), &quot;data&quot;)os.environ[&quot;LOCAL_EXPERIMENT_DIR&quot;] = os.path.join(os.getenv(&quot;LOCAL_PROJECT_DIR&quot;, os.getcwd()))os.environ[&quot;LOCAL_SPECS_DIR&quot;] = os.path.join( os.getenv(&quot;NOTEBOOK_ROOT&quot;, os.getcwd()), &quot;specs&quot;)%env SPECS_DIR=/your_path/7th/specs!echo $LOCAL_SPECS_DIR!ls -rlt $LOCAL_SPECS_DIR 2.将系统目录映射到Tao Docker 代码如下（示例）： 1234567891011121314151617181920212223# Mapping up the local directories to the TAO docker.import jsonmounts_file = os.path.expanduser(&quot;~/.tao_mounts.json&quot;)# Define the dictionary with the mapped drivesdrive_map = &#123; &quot;Mounts&quot;: [ # Mapping the data directory &#123; &quot;source&quot;: os.environ[&quot;LOCAL_PROJECT_DIR&quot;], &quot;destination&quot;: &quot;/home/meng/7thSkyHackathon/CV/&quot; &#125;, # Mapping the specs directory. &#123; &quot;source&quot;: os.environ[&quot;LOCAL_SPECS_DIR&quot;], &quot;destination&quot;: os.environ[&quot;SPECS_DIR&quot;] &#125;, ]&#125;# Writing the mounts file.with open(mounts_file, &quot;w&quot;) as mfile: json.dump(drive_map, mfile, indent=4) 查看目录下文件 1!cat ~/.tao_mounts.json 3.安装TAO的加载器 123# 如果您已经安装好了，则不需要执行这一步!pip3 install nvidia-pyindex!pip3 install nvidia-tao 查看TAO的信息 12# 查看当前环境下TAO的信息!tao info ## 4.准备数据集和预训练模型 12345# verify# 此时的LOCAL_DATA_DIR为：LOCAL_PROJECT_DIR/data# 比如我的LOCAL_PROJECT_DIR为/home/hekun/mydata/workspace/tao-experiments， 那么在我的实验文档中LOCAL_DATA_DIR=/home/hekun/mydata/workspace/tao-experiments/data# 您需要将您的图片数据集（此时我的为pascal_img）和标注文件（此时我的为pascal_label）放到LOCAL_DATA_DIR中!ls -l $LOCAL_DATA_DIR/ 12345# 生成验证数据集，主要您要把generate_val_dataset.py文件中图片数据的格式后缀名修改成跟您图片数据格式一样。原文中使用的是.png格式的后缀名。# 此时generate_val_dataset.py的参数需要的文件夹地址均为您的计算机系统本地地址，不是docker中的地址。!python3.8 generate_val_dataset.py --input_image_dir=$LOCAL_DATA_DIR/images \\ --input_label_dir=$LOCAL_DATA_DIR/labels \\ --output_dir=$LOCAL_DATA_DIR/val 12345678910#修改specs/ssd_tfrecords_kitti_train.txt中的内容：#1.root_directory_path为docker环境中的地址，你需要修改和你自己的系统环境相对应。比如在我的例子中，# 保存图片数据的pascal_img文件夹在/home/hekun/mydata/workspace/tao-experiments/data目录下。# 而/home/hekun/mydata/workspace/tao-experiments/正好映射到docker文件系统目录中的/workspace/tao-experiments/。 所以我就将root_directory_path--&gt;/workspace/tao-experiments/data#2.image_dir_name定义为保存图片数据的文件夹，您可以理解为Tao会在root_directory_path的目录下寻找image_dir_name文件夹，image_dir_name文件夹里面的所有图片都被视作训练图片#3.label_dir_name定义为保存标注文件的文件夹。#4.image_directory_path 和root_directory_path可以理解为一样。#5.target_class_mapping定义为您标注的类别，key为您标注文件中写的类别，value为Tao训练时使用的类别名字print(&quot;TFRecords conversion spec file:&quot;)!cat $LOCAL_SPECS_DIR/ssd_tfrecords_kitti_train.txt 123456# 创建用于保存tfrecord格式的数据的文件夹，并利用Tao自带的工具转换数据。数据将被保存在-o后面的文件目录里面。print(&quot;Converting the training set to TFRecords.&quot;)!mkdir -p $LOCAL_DATA_DIR/tfrecords &amp;&amp; rm -rf $LOCAL_DATA_DIR/tfrecords/*!tao ssd dataset_convert \\ -d /your_path/CV/7th/specs/ssd_tfrecords_kitti_train.txt \\ -o /your_path/CV/data/tfrecords/kitti_train 查看目录下文件 1!ls -rlt $LOCAL_DATA_DIR/tfrecords/ 下载预训练模型 123456789101112#下面的步骤是用来下载并安装NGC CLI的，第一次运行的时候需要安装，如果已经安装了，那么可以跳过这一步# Installing NGC CLI on the local machine.## Download and install%env CLI=ngccli_cat_linux.zip!mkdir -p $LOCAL_PROJECT_DIR/ngccli# Remove any previously existing CLI installations!rm -rf $LOCAL_PROJECT_DIR/ngccli/*!wget &quot;https://ngc.nvidia.com/downloads/$CLI&quot; -P $LOCAL_PROJECT_DIR/ngccli!unzip -u &quot;$LOCAL_PROJECT_DIR/ngccli/$CLI&quot; -d $LOCAL_PROJECT_DIR/ngccli/!rm $LOCAL_PROJECT_DIR/ngccli/*.zip os.environ[&quot;PATH&quot;]=&quot;&#123;&#125;/ngccli:&#123;&#125;&quot;.format(os.getenv(&quot;LOCAL_PROJECT_DIR&quot;, &quot;&quot;), os.getenv(&quot;PATH&quot;, &quot;&quot;)) 12#此步骤是用来验证NGC的，如果下载不成功出现问题，可能是您没有开启NGC的验证，或者您的Key过时了，需要重新验证。如果下载成功，可以不必运行这一步。!docker login nvcr.io 12#同上一步，如果下面一步下载不成功，可以清理之前的验证，并运行上一步重新验证。如果下载成功，可以不必运行这一步。!ngc config clear 12#查看目前NGC上可以下载的预训练模型，比如下面这个命令就是列出所有的目标检测的预训练模型!ngc registry model list nvidia/tao/pretrained_object_detection:* 12#创建文件夹保存下载的预训练模型!mkdir -p $LOCAL_EXPERIMENT_DIR/pretrained_resnet18/ 12# 下载您所选择的预训练模型!ngc registry model download-version nvidia/tao/pretrained_object_detection:resnet18 --dest $LOCAL_EXPERIMENT_DIR/pretrained_resnet18 123#查看预训练模型是否下载成功print(&quot;Check that model is downloaded into dir.&quot;)!ls -l $LOCAL_EXPERIMENT_DIR/pretrained_resnet18/pretrained_object_detection_vresnet18 5.定义训练的参数 修改target_class_mapping为您需要训练的类别 此处的路径基本不需要修改，除非您自己改动过。 batch_size_per_gpu定义了batch_size大小，如果您的GPU显存不是很大，建议可以调整小一点，否则可能出现out of memory的错误 num_epochs定义了您会训练多少圈，如果您第一次训练，建议不要小于80 validation_period_during_training定义了训练多少圈验证一下，可以直观地看出您训练的效果变化，可以定义5 or 10 通过修改此处的txt来修改训练的参数 1!cat $LOCAL_SPECS_DIR/ssd_train_resnet18_kitti.txt ## 6.开始利用TAO训练 您只需要利用下面命令中的tao ssd train就可以训练 --gpus定义了您有几个GPU，--gpu_index定义了您用哪个GPU -e定义了您上面设置的训练设置文件 -r定义了您训练的模型输出文件夹 -k定义了您的秘钥API Key -m定义了您的预训练模型 12#创建模型输出文件夹，您训练的结果会保存在这里!mkdir -p $LOCAL_EXPERIMENT_DIR/experiment_dir_unpruned_final 123456print(&quot;To run with multigpu, please change --gpus based on the number of available GPUs in your machine.&quot;)!tao ssd train --gpus 1 --gpu_index=$GPU_INDEX \\ -e $SPECS_DIR/ssd_train_resnet18_kitti.txt \\ -r $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final \\ -k $KEY \\ -m $USER_EXPERIMENT_DIR/7th/pretrained_resnet18/pretrained_object_detection_vresnet18/resnet_18.hdf5 12345678#如果是上面没训练完，中途断开了，可以利用这里的命令在上面的基础上继续训练print(&quot;To resume from checkpoint, please uncomment and run this instead. Change last two arguments accordingly.&quot;)!tao ssd train --gpus 1 --gpu_index=$GPU_INDEX \\ -e $SPECS_DIR/ssd_train_resnet18_kitti.txt \\ -r $USER_EXPERIMENT_DIR/experiment_dir_unpruned \\ -k $KEY \\ -m $USER_EXPERIMENT_DIR/experiment_dir_unpruned/weights/ssd_resnet18_epoch_020.tlt \\ --initial_epoch 20 1234#查看您训练的模型print(&#x27;Model for each epoch:&#x27;)print(&#x27;---------------------&#x27;)!ls -ltrh $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final/weights 找到效果最好的那个模型 1234#查看您训练模型的精度，并选择一个最好的，把那个最好的模型的epoch复制个下面的EPOCH，说明我们后面的操作都是基于这个模型。#这个结果中，倒数第二个参数为mAP值，即您训练模型的精度，最后一个值为验证的损失。我们会选择mAP最大的那个模型!cat $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final/ssd_training_log_resnet18.csv%set_env EPOCH=000 7.评估训练的模型 12345#评估训练的模型!tao ssd evaluate --gpu_index=$GPU_INDEX \\ -e $SPECS_DIR/ssd_train_resnet18_kitti.txt \\ -m $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final/weights/ssd_resnet18_epoch_$EPOCH.tlt \\ -k $KEY 8.对模型进行剪枝 -m 定义您要剪枝的模型 -o 定义剪之后输出的模型 -eq定义剪枝的方式 -pth定义剪枝的阈值。这里可以理解为，pth越大剪去参数越多，模型越小，运行速度越快，但是可能精度越低。所以采用多大的pth需要反复试验，建议从0.5开始，如果你的模型训练的效果一直不好，那么把0.5换成0.3，减少 剪枝的部分。 -k 定义您的秘钥API Key 12%set_env EPOCH=020!mkdir -p $USER_EXPERIMENT_DIR/experiment_dir_pruned pth是你剪枝的参数，pth大则模型小，精度不高，pth大则模型精度高，文件大 123456!tao ssd prune --gpu_index=$GPU_INDEX \\ -m $USER_EXPERIMENT_DIR/experiment_dir_unpruned_final/weights/ssd_resnet18_epoch_$EPOCH.tlt \\ -o $USER_EXPERIMENT_DIR/experiment_dir_pruned/ssd_resnet18_pruned.tlt \\ -eq intersection \\ -pth 0.5 \\ -k $KEY 1!ls -rlt $USER_EXPERIMENT_DIR/experiment_dir_pruned/ 9.对剪枝后的模型重新训练 这里就像刚才训练时一样，我们需要定义训练的设置 注意这里的训练设置文件和刚才的训练设置文件不一样 您还是需要像上面的步骤一样修改其中的一些参数 12#查看重新训练的设置文件!cat $LOCAL_SPECS_DIR/ssd_retrain_resnet18_kitti.txt 12#创建文件夹，用于保存训练结果!mkdir -p $USER_EXPERIMENT_DIR/experiment_dir_retrain 123456# 跟上面训练的步骤一样，只不过修改了预训练模型!tao ssd train --gpus 1 --gpu_index=$GPU_INDEX \\ -e $SPECS_DIR/ssd_retrain_resnet18_kitti.txt \\ -r $USER_EXPERIMENT_DIR/experiment_dir_retrain \\ -m $USER_EXPERIMENT_DIR/experiment_dir_pruned/ssd_resnet18_pruned.tlt \\ -k $KEY 12# 查看训练结果!ls -rlt $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights 123# 同样的步骤，找到那个最好的!cat $USER_EXPERIMENT_DIR/experiment_dir_retrain/ssd_training_log_resnet18.csv%set_env EPOCH=000 10.评估新的模型 1234!tao ssd evaluate --gpu_index=$GPU_INDEX \\ -e $SPECS_DIR/ssd_retrain_resnet18_kitti.txt \\ -m $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights/ssd_resnet18_epoch_$EPOCH.tlt \\ -k $KEY 11.可视化推理结果 1!mkdir -p $LOCAL_DATA_DIR/test_samples 1!ls $LOCAL_DATA_DIR 12!echo $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights/ssd_resnet18_epoch_$EPOCH.tlt!ls $LOCAL_DATA_DIR/test_samples 12345678910111213# 在此步骤中：#1.我们需要将要测试的图片放在-i后面的文件夹中，注意这里的文件夹是Tao docker文件系统中的路径#2.-o是输出文件夹，即检测过得图片保存的位置#3.-e是您训练时用的文件#4.-m是您要测试的模型#5.-l是推理结果的标注文件#6.-k是您的秘钥API Key!tao ssd inference --gpu_index=$GPU_INDEX -i $LOCAL_DATA_DIR/test_samples \\ -o $USER_EXPERIMENT_DIR/ssd_infer_images \\ -e $SPECS_DIR/ssd_retrain_resnet18_kitti.txt \\ -m $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights/ssd_resnet18_epoch_$EPOCH.tlt \\ -l $USER_EXPERIMENT_DIR/ssd_infer_labels \\ -k $KEY 安装matplotlib 1!pip3 --default-timeout=100 install matplotlib==3.3.3 12345678910111213141516171819# Simple grid visualizer#!pip3 install matplotlib==3.3.3import matplotlib.pyplot as pltimport osfrom math import ceilvalid_image_ext = [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.jpeg&#x27;, &#x27;.ppm&#x27;]def visualize_images(image_dir, num_cols=4, num_images=10): output_path = os.path.join(os.environ[&#x27;LOCAL_EXPERIMENT_DIR&#x27;], image_dir) num_rows = int(ceil(float(num_images) / float(num_cols))) f, axarr = plt.subplots(num_rows, num_cols, figsize=[80,30]) f.tight_layout() a = [os.path.join(output_path, image) for image in os.listdir(output_path) if os.path.splitext(image)[1].lower() in valid_image_ext] for idx, img_path in enumerate(a[:num_images]): col_id = idx % num_cols row_id = idx // num_cols img = plt.imread(img_path) axarr[row_id, col_id].imshow(img) 1!ls $USER_EXPERIMENT_DIR/ssd_infer_images 123456# Visualizing the sample images.OUTPUT_PATH = &#x27;/home/meng/7thSkyHackathon/CV/ssd_infer_images&#x27; # relative path from $USER_EXPERIMENT_DIR.COLS = 3 # number of columns in the visualizer grid.IMAGES = 21 # number of images to visualize.visualize_images(OUTPUT_PATH, num_cols=COLS, num_images=IMAGES) 12.模型的导出 通过tao工具导出您训练的模型，导出的模型可以利用NVIDIA TensorRT或者NVIDIA Deepstream进行推理部署： -m定义了您要导出的模型 -k定义了您的秘钥API Key -o 定义了您导出的模型存放的位置 -e定义了您训练这个模型的设置文件 --batch_size定义了模型的输入batchsize --data_type定义了您导出的模型的数据类型，可以定义为fp32，fp16 or int8。 如果定义了int8 您还需要定义下面的量化文件。 12345678910!rm -rf $USER_EXPERIMENT_DIR/export!mkdir -p $USER_EXPERIMENT_DIR/export# Export in FP32 mode. Change --data_type to fp16 for FP16 mode!tao ssd export --gpu_index=$GPU_INDEX \\ -m $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights/ssd_resnet18_epoch_$EPOCH.tlt \\ -k $KEY \\ -o $USER_EXPERIMENT_DIR/export/ssd_resnet18_epoch_$EPOCH.etlt \\ -e $SPECS_DIR/ssd_train_resnet18_kitti.txt \\ --batch_size 1 \\ --data_type fp32 123print(&#x27;Exported model:&#x27;)print(&#x27;------------&#x27;)!ls -lh $USER_EXPERIMENT_DIR/export 在这里利用tao-converter工具将您训练的模型转化为TensorRT可以直接使用的推理引擎，注意：您需要在哪里使用您的模型，您就要在哪里转换这个模型。 您可以访问下面的地址，下载tao-converter工具： 注意：本地导出的模型不可用在节点上，两者代码虽然一样，但是创建的模型是不一样的 12345678!tao converter -k $KEY \\ -d 3,300,300 \\ -o NMS \\ -e $USER_EXPERIMENT_DIR/export/trt.engine \\ -m 1 \\ -t fp32 \\ -i nchw \\ $USER_EXPERIMENT_DIR/export/ssd_resnet18_epoch_$EPOCH.etlt 123print(&#x27;Exported engine:&#x27;)print(&#x27;------------&#x27;)!ls -lh $LOCAL_EXPERIMENT_DIR/export/trt.engine 13.验证导出的模型 123456!tao ssd inference --gpu_index=$GPU_INDEX \\ -m $USER_EXPERIMENT_DIR/export/trt.engine \\ -e $SPECS_DIR/ssd_retrain_resnet18_kitti.txt \\ -i $DATA_DOWNLOAD_DIR/test_samples \\ -o $USER_EXPERIMENT_DIR/ssd_infer_images \\ -t 0.4 12345OUTPUT_PATH = &#x27;ssd_infer_images&#x27; # relative path from $USER_EXPERIMENT_DIR.COLS = 3 # number of columns in the visualizer grid.IMAGES = 9 # number of images to visualize.visualize_images(OUTPUT_PATH, num_cols=COLS, num_images=IMAGES) 总结 在训练过程中遇到各种各样的问题要善于去自己改正，有些很简单的问题可能只是自己疏忽大意导致的，一点一点debug才能进步","categories":[{"name":"The 7th Sky Hackathon","slug":"The-7th-Sky-Hackathon","permalink":"https://mengfanjun020906.github.io/categories/The-7th-Sky-Hackathon/"}],"tags":[{"name":"python","slug":"python","permalink":"https://mengfanjun020906.github.io/tags/python/"},{"name":"Nvidia","slug":"Nvidia","permalink":"https://mengfanjun020906.github.io/tags/Nvidia/"},{"name":"人工智能","slug":"人工智能","permalink":"https://mengfanjun020906.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://mengfanjun020906.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"数字信号处理MATLAB作业三（题目+解答代码）","slug":"数字信号处理MATLAB作业三（题目+解答代码）","date":"2022-11-30T09:31:07.000Z","updated":"2023-03-24T05:51:55.546Z","comments":true,"path":"2022/11/30/数字信号处理MATLAB作业三（题目+解答代码）/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/30/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86MATLAB%E4%BD%9C%E4%B8%9A%E4%B8%89%EF%BC%88%E9%A2%98%E7%9B%AE+%E8%A7%A3%E7%AD%94%E4%BB%A3%E7%A0%81%EF%BC%89/","excerpt":"","text":"这题原本画出来就四条谱线，除了频率0的直流分量，就三根了，太少了，为了看着方便，我自己增加了序列 12345678910111213clearclose allclcn=0:8;x=[4 3 2 6 7 8 3 3 5];subplot(1,2,1);stem(n,x)xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;原序列&#x27;);y=fft(x);subplot(1,2,2);stem(n,y);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;频谱序列&#x27;); 除了频率0，剩下的幅度一样，相位取反 123456789101112131415161718192021222324252627282930313233343536clearclose allclcn=0:29;a=0.1;f1=0.0625;f2=0.4375;f3=0.5625;x1=exp(-a.*n).*sin(2*pi*f1.*n);x2=exp(-a.*n).*sin(2*pi*f2.*n);x3=exp(-a.*n).*sin(2*pi*f3.*n);subplot(3,2,1);stem(n,x1);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;时域f=0.0625&#x27;);y1=fft(x1);subplot(3,2,2);stem(n,y1);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;频域f=0.0625&#x27;);subplot(3,2,3);stem(n,x2);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;时域f=0.4375&#x27;);y2=fft(x2);subplot(3,2,4);stem(n,y2);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;频域f=0.4375&#x27;);subplot(3,2,5);stem(n,x3);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;时域f=0.5625&#x27;);y3=fft(x3);subplot(3,2,6);stem(n,y3);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅度&#x27;);title(&#x27;频域f=0.5625&#x27;); 1234567891011121314151617181920212223242526clearclose allclcN=8;n=0:7;x1=zeros(size(n));x2=zeros(size(n));xa=(n&gt;=0)&amp;(n&lt;=3);x1(xa)=n(xa);x2(xa)=4-n(xa);xa=(n&gt;=4)&amp;(n&lt;=7);x1(xa)=8-n(xa);x2(xa)=n(xa)-4;fp1=fft(x1);fp1=abs(fp1); fp2=fft(x2);fp2=abs(fp2);subplot(2,2,1);stem(n,x1);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域特性&#x27;);title(&#x27;三角波序列&#x27;); subplot(2,2,2);stem(n,fp1);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅频特性&#x27;);title(&#x27;三角波序列&#x27;); subplot(2,2,3);stem(n,x2);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域特性&#x27;);title(&#x27;反三角波序列&#x27;); subplot(2,2,4);stem(n,fp2);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅频特性&#x27;);title(&#x27;反三角波序列&#x27;); 在这里插入图片描述 1234567891011121314151617181920212223242526272829303132clearclose allclcN=8;n=0:7;x1=zeros(size(n));x2=zeros(size(n));xa=(n&gt;=0)&amp;(n&lt;=3);x1(xa)=n(xa);x2(xa)=4-n(xa);xa=(n&gt;=4)&amp;(n&lt;=7);x1(xa)=8-n(xa);x2(xa)=n(xa)-4;N2=32;n2=0:31;tempx1=zeros(1,24);x11=[x1,tempx1];tempx2=zeros(1,24);x22=[x2,tempx2];fp11=fft(x11);fp11=abs(fp11); fp22=fft(x22);fp22=abs(fp22);subplot(2,2,1);stem(n2,x11);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域特性&#x27;);title(&#x27;补0后三角波序列&#x27;); subplot(2,2,2);stem(n2,fp11);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅频特性&#x27;);title(&#x27;补0后三角波序列&#x27;); subplot(2,2,3);stem(n2,x22);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域特性&#x27;);title(&#x27;补0后反三角波序列&#x27;); subplot(2,2,4);stem(n2,fp22);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅频特性&#x27;);title(&#x27;补0后反三角波序列&#x27;); 后面补0，采样点变多了，副频特性要比补0前更清晰 N=16时 1234567891011121314151617181920212223clearclose allclcN=16;n=0:N-1;f1=1/16;f2=1/64;xn1=sin(2*pi*0.125*n)+cos(2*pi*(0.125+f1)*n);xn2=sin(2*pi*0.125*n)+cos(2*pi*(0.125+f2)*n);yn1=fft(xn1);yn2=fft(xn2);subplot(2,2,1);stem(n,xn1);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域&#x27;);title(&#x27;f为1/16&#x27;);subplot(2,2,2);stem(n,yn1);xlabel(&#x27;n&#x27;);ylabel(&#x27;频域&#x27;);title(&#x27;f为1/16&#x27;);subplot(2,2,3);stem(n,xn2);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域&#x27;);title(&#x27;f为1/64&#x27;);subplot(2,2,4);stem(n,yn2);xlabel(&#x27;n&#x27;);ylabel(&#x27;频域&#x27;);title(&#x27;f为1/64&#x27;); 在这里插入图片描述 1234567891011121314151617181920N2=128;n2=0:N2-1;f1=1/16;f2=1/64;xn3=sin(2*pi*0.125*n2)+cos(2*pi*(0.125+f1)*n2);xn4=sin(2*pi*0.125*n2)+cos(2*pi*(0.125+f2)*n2);yn3=fft(xn3);yn4=fft(xn4);subplot(2,2,1);stem(n2,xn3);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域&#x27;);title(&#x27;f为1/16&#x27;);subplot(2,2,2);stem(n2,yn3);xlabel(&#x27;n&#x27;);ylabel(&#x27;频域&#x27;);title(&#x27;f为1/16&#x27;);subplot(2,2,3);stem(n2,xn4);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域&#x27;);title(&#x27;f为1/64&#x27;);subplot(2,2,4);stem(n2,yn4);xlabel(&#x27;n&#x27;);ylabel(&#x27;频域&#x27;);title(&#x27;f为1/64&#x27;); 1234567891011121314151617181920212223242526272829303132333435363738394041dt=0.01;N=512;n=0:N-1;t=n*dt;f=n/(N*dt);f1=30;f2=10;x=0.5*sin(2*pi*f1*t)+cos(2*pi*f2*t);x1=x;subplot(2,2,1)plot(t,x1,&#x27;linewidth&#x27;,3);ylabel(&#x27;x1&#x27;,&#x27;fontsize&#x27;,16);xlim([0 0.3])y=fft(x);xk1=abs(y)*2/N;subplot(2,2,2)plot(f,xk1,&#x27;linewidth&#x27;,3);ylabel(&#x27;xk1&#x27;,&#x27;fontsize&#x27;,16);xlim([0 50])f1=20;f2=40;yy=zeros(1,length(y));for m=0:N-1 if(m/(N*dt)&gt;f1&amp;m/(N*dt)&lt;f2)|(m/(N*dt)&gt;(1/dt-f2)&amp;m/(N*dt)&lt;(1/dt-f1)) yy(m+1)=0.; else yy(m+1)=y(m+1); endendxk2=abs(yy)*2/Nsubplot(2,2,4)plot(f,xk2,&#x27;linewidth&#x27;,3);xlim([0 50]);xlabel(&#x27;f&#x27;,&#x27;fontsize&#x27;,16);ylabel(&#x27;xk2&#x27;,&#x27;fontsize&#x27;,16);x2=real(ifft(yy));subplot(2,2,3)plot(t,x2,&#x27;linewidth&#x27;,3);xlabel(&#x27;t&#x27;,&#x27;fontsize&#x27;,16);ylabel(&#x27;x2&#x27;,&#x27;fontsize&#x27;,16);xlim([0 0.3]) 对x1和x2进行了快速傅立叶变换","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"数字信号处理信号的序列补0MATLAB实现——实例","slug":"数字信号处理信号的序列补0MATLAB实现——实例","date":"2022-11-30T09:14:34.000Z","updated":"2023-03-24T05:32:50.809Z","comments":true,"path":"2022/11/30/数字信号处理信号的序列补0MATLAB实现——实例/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/30/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BA%8F%E5%88%97%E8%A1%A50MATLAB%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"这里我们直接展示补0的核心代码 生成三角波和反三角波 123456789101112N=8;n=0:7;x1=zeros(size(n));x2=zeros(size(n));xa=(n&gt;=0)&amp;(n&lt;=3);x1(xa)=n(xa);x2(xa)=4-n(xa);xa=(n&gt;=4)&amp;(n&lt;=7);x1(xa)=8-n(xa);x2(xa)=n(xa)-4; 对序列进行后面补0 1234tempx1=zeros(1,24);%创造一个1行24个0的序列x11=[x1,tempx1];%将原本的x1序列和24个0的序列合并tempx2=zeros(1,24);%创造一个1行24个0的序列x22=[x2,tempx2];%将原本的x2序列和24个0的序列合并 完整代码 1234567891011121314151617181920212223242526272829303132clearclose allclcN=8;n=0:7;x1=zeros(size(n));x2=zeros(size(n));xa=(n&gt;=0)&amp;(n&lt;=3);x1(xa)=n(xa);x2(xa)=4-n(xa);xa=(n&gt;=4)&amp;(n&lt;=7);x1(xa)=8-n(xa);x2(xa)=n(xa)-4;N2=32;n2=0:31;tempx1=zeros(1,24);x11=[x1,tempx1];tempx2=zeros(1,24);x22=[x2,tempx2];fp11=fft(x11);fp11=abs(fp11); fp22=fft(x22);fp22=abs(fp22);subplot(2,2,1);stem(n2,x11);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域特性&#x27;);title(&#x27;补0后三角波序列&#x27;); subplot(2,2,2);stem(n2,fp11);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅频特性&#x27;);title(&#x27;补0后三角波序列&#x27;); subplot(2,2,3);stem(n2,x22);xlabel(&#x27;n&#x27;);ylabel(&#x27;时域特性&#x27;);title(&#x27;补0后反三角波序列&#x27;); subplot(2,2,4);stem(n2,fp22);xlabel(&#x27;n&#x27;);ylabel(&#x27;幅频特性&#x27;);title(&#x27;补0后反三角波序列&#x27;); 在这里插入图片描述","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"https://mengfanjun020906.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数字信号处理信号的圆周卷积MATLAB实现——实例","slug":"数字信号处理信号的圆周卷积MATLAB实现——实例","date":"2022-11-28T06:38:43.000Z","updated":"2023-03-24T05:33:39.157Z","comments":true,"path":"2022/11/28/数字信号处理信号的圆周卷积MATLAB实现——实例/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9C%86%E5%91%A8%E5%8D%B7%E7%A7%AFMATLAB%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"xa(n)是高斯序列 xb(n)是衰减正弦序列 线性卷积很简单，利用conv函数就可以 那么圆周卷积要怎么实现呢 12345678910111213141516171819202122clc; n1=0:1:15; %16个点n2=0:1:30; %线性卷积，序列长度变成了16+16-1p=8;q=2;a=0.1;f=0.0625;xa=exp(-((n1-p).^2)/q);xb=exp(-a.*n1).*sin(2*pi*f.*n1);fa=fft(xa);fb=fft(xb); circle=fa.*fb; %圆周卷积 line=conv(xa,xb); %线性卷积 subplot(2,2,1); stem(n1,xa);ylabel(&#x27;时域特性&#x27;);title(&#x27;高斯序列 xa&#x27;);subplot(2,2,2); stem(n1,xb);ylabel(&#x27;时域特性&#x27;);title(&#x27;衰减正弦序列 xb&#x27;); subplot(2,2,3); stem(n1,circle);ylabel(&#x27;幅频特性&#x27;);title(&#x27;xa 与 xb 的 16 点循环卷积&#x27;); subplot(2,2,4); stem(n2,line);ylabel(&#x27;幅频特性&#x27;);title(&#x27; xa 与 xb 的线性卷积&#x27;);","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"数字信号处理MATLAB作业二（题目+解答代码）","slug":"数字信号处理MATLAB作业二（题目+解答代码）","date":"2022-11-28T06:23:35.000Z","updated":"2023-03-24T05:51:10.564Z","comments":true,"path":"2022/11/28/数字信号处理MATLAB作业二（题目+解答代码）/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86MATLAB%E4%BD%9C%E4%B8%9A%E4%BA%8C%EF%BC%88%E9%A2%98%E7%9B%AE+%E8%A7%A3%E7%AD%94%E4%BB%A3%E7%A0%81%EF%BC%89/","excerpt":"","text":"在这里插入图片描述 12345678910111213141516171819clearclose allclcfs=8000;%采样频率n=0:99;%采样点100个y=sin(0.00625*2*pi*n)+sin(0.0625*pi*2*n)+sin(0.125*2*pi*n);%采样后的信号 0.00625=50/8000subplot(2,1,1);stem(n,y)title(&#x27;抽样后信号的时域图像&#x27;)xlabel(&#x27;n&#x27;);ylabel(&#x27;幅值&#x27;);Y = fft(y);%进行fft变换f=(0:length(Y)-1)*fs/length(Y);%在频域，转换坐标为f，f= n*(fs/N)=Y的长度*采样频率,还是8k，但是在Matlab需要经过这样的运算subplot(2,1,2)stem(f,abs(Y));title(&#x27;信号频谱图&#x27;)xlabel(&#x27;f/Hz&#x27;)ylabel(&#x27;幅度&#x27;) 12345678910111213141516171819clearclose allclcfs=800;%采样频率n=0:99;%采样点100个y=sin(0.0625*2*pi*n)+sin(0.625*pi*2*n)+sin(1.25*2*pi*n);%采样后的信号 0.00625=50/8000% subplot(2,1,1);% stem(n,y)% title(&#x27;抽样后信号的时域图像&#x27;)% xlabel(&#x27;n&#x27;);ylabel(&#x27;幅值&#x27;);Y = fft(y);%进行fft变换f=(0:length(Y)-1)*fs/length(Y);%在频域，转换坐标为f，f= n*(fs/N)=Y的长度*采样频率,还是8k，但是在Matlab需要经过这样的运算%subplot(2,1,2)stem(f,abs(Y));title(&#x27;信号频谱图&#x27;)xlabel(&#x27;f/Hz&#x27;)ylabel(&#x27;幅度&#x27;) 1234567891011121314151617181920212223242526272829303132333435363738394041clearclose allclc%定义基本参数f=1;%原信号频率fs=16;%抽样信号频率N=52;%采样点数n=0:N-1;%画原序列图像xn=cos(2*pi*n*(f/fs));subplot(3,1,1)stem(n,xn)title(&#x27;原x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;)%画M=4倍抽样的x(n)M=4;m=0:N/M-1;%52/4=13 13-1=12 0:12有13个点xn1=decimate(xn,M);%对序列进行抽样subplot(3,1,2)stem(m,xn1)%注意对上m和xn1title(&#x27;进行M=4倍抽取后的x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;)%画L=3倍插值的x(n)L=3;xn2=interp(xn,L);p=0:N*L-1;subplot(3,1,3)stem(p,xn2)title(&#x27;进行L=3倍插值后的x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;) 12345678910111213141516171819202122clc; n1=0:1:15; n2=0:1:30; p=8;q=2;a=0.1;f=0.0625;xa=exp(-((n1-p).^2)/q);xb=exp(-a.*n1).*sin(2*pi*f.*n1);fa=fft(xa);fb=fft(xb); circle=fa.*fb; %圆周卷积 line=conv(xa,xb); %线性卷积 subplot(2,2,1); stem(n1,xa);ylabel(&#x27;时域特性&#x27;);title(&#x27;高斯序列 xa&#x27;);subplot(2,2,2); stem(n1,xb);ylabel(&#x27;时域特性&#x27;);title(&#x27;衰减正弦序列 xb&#x27;); subplot(2,2,3); stem(n1,circle);ylabel(&#x27;幅频特性&#x27;);title(&#x27;xa 与 xb 的 16 点循环卷积&#x27;); subplot(2,2,4); stem(n2,line);ylabel(&#x27;幅频特性&#x27;);title(&#x27; xa 与 xb 的线性卷积&#x27;); 在这里插入图片描述","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"MATLAB实现将函数/序列进行周期延拓","slug":"MATLAB实现将函数_序列进行周期延拓","date":"2022-11-26T07:42:14.000Z","updated":"2023-03-24T12:20:10.257Z","comments":true,"path":"2022/11/26/MATLAB实现将函数_序列进行周期延拓/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/26/MATLAB%E5%AE%9E%E7%8E%B0%E5%B0%86%E5%87%BD%E6%95%B0_%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8C%E5%91%A8%E6%9C%9F%E5%BB%B6%E6%8B%93/","excerpt":"","text":"原函数 假设我们有这么一个函数 x(n)=3cos(0.125πn+0.2π)+2sin(0.25πn+0.1π) n为0到15的整数 这是他的函数图像，如何将其进行周期化 我在MATLAB中文论坛看到了一个很巧妙的方法 1b = mod(a,m) b = mod(a,m) 返回 a 除以 m 后的余数，其中 a 是被除数，m 是除数。此函数通常称为取模运算，表达式为 b = a-m.*floor(a./m)。mod 函数遵从 mod(a,0) 返回 a 的约定。 ### 例子 1b = mod(23,5) b=3,其实就是一个取余的运算 周期化函数 那么我们转变一下思路，将函数的自变量进行一个延展，再用其周期进行取余，不就变成了周期函数 假如x要以16为周期，延拓4个周期 1234n2=0:80n22=mod(n2,15);x2=3*cos(0.125*pi*n22+0.2*pi)+2*sin(0.25*pi*n22+0.1*pi);stem(x2) 就算出来了 完整代码 画函数原来的图 123n1=0:15;x1=3*cos(0.125*pi*n1+0.2*pi)+2*sin(0.25*pi*n1+0.1*pi);stem(x1) 画周期函数的图 1234n2=0:80n22=mod(n2,15);x2=3*cos(0.125*pi*n22+0.2*pi)+2*sin(0.25*pi*n22+0.1*pi);stem(x2) 局限性 因为在这道题中，n只提供了正值，就导致负半轴的延拓必须通过修改n的值来实现 例如： 如果想将本文中的序列延拓到四个周期 ，正负各一半，就要这么写 1234567891011n1=0:15;x1=3*cos(0.125*pi*n1+0.2*pi)+2*sin(0.25*pi*n1+0.1*pi);subplot(2,1,1);stem(n1,x1)n2=0:63;n22=mod(n2,15);x2=3*cos(0.125*pi*n22+0.2*pi)+2*sin(0.25*pi*n22+0.1*pi);n3=-32:31;subplot(2,1,2);stem(n3,x2) 只能实现有限周期的延拓","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"https://mengfanjun020906.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"2021年亚太杯三等奖选手C题思路","slug":"2021年亚太杯三等奖选手C题思路","date":"2022-11-23T04:51:44.000Z","updated":"2023-03-24T12:21:00.972Z","comments":true,"path":"2022/11/23/2021年亚太杯三等奖选手C题思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/23/2021%E5%B9%B4%E4%BA%9A%E5%A4%AA%E6%9D%AF%E4%B8%89%E7%AD%89%E5%A5%96%E9%80%89%E6%89%8BC%E9%A2%98%E6%80%9D%E8%B7%AF/","excerpt":"","text":"昨天晚上刚出了亚太杯的成绩，获得了三等奖，毕竟是第一次参加数学建模比赛，不是成功参与奖就很高兴了，结束了之后，还要进行总结复盘，接下来，就是我们队伍的思路。 因为A题和B题都读不懂，所以我们才选了C题，但是坏处是，选C题的人数也很多。 ## 亚太杯C题第一小问 读完第一问，我们不难发现，有几个关键词需要我们注意。 请选择合适指标，收集相关数据，建立塞罕坝对生态环境影响的评价模型，为了定量评价。。。。。。。。对塞罕坝恢复前后的环境状况进行对比分析。 所以我们从第一步开始，先选择合适指标： 通过对以往环境对比评价类型的论文的参考，我们选择了三个方面，分别是，经济情况，土壤情况，以及二氧化碳情况，六个指标，对环境情况进行分析，采用了层次分析模型，下面是我们的模型示意图： 备选层只有两个选择，一个是恢复前的塞罕坝，一个是恢复后的塞罕坝， 第二步就是构建权重矩阵，我们可以得到 代码如下 123456789101112131415161718192021222324disp(&#x27;input A&#x27;);A=input(&#x27;A=&#x27;);[n,n]=size(A);[V,D]=eig(A);tempNum=D(1,1);pos=1;for h=1:n if D(h,h)&gt;tempNum tempNum=D(h,h); pos=h; endend w=abs(V(:,pos));w=w/sum(w);t=D(pos,pos);disp(&#x27;rules w=&#x27;);disp(w);disp(&#x27;bigget t=&#x27;);disp(t);CI=(t-n)/(n-1);RI=[0 0 0.52 0.89 1.12 1.26 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59 1.60 1.61 1.615 1.62 1.63];CR=CI/RI(n);if CR&lt;0.10 disp(&#x27; ACCE PT!&#x27;); disp(&#x27;CI=&#x27;);disp(CI); disp(&#x27;CR=&#x27;);disp(CR);else disp(&#x27; NOT ACCEPCT!&#x27;);end 最后得到的CR&lt;0.1，一致性检验通过，所以第一题就算是做完了。 优点： 快速，用了一个上午就做出来了； 简单，因为备选对象只有两个，所以算起来，矩阵很好列 缺点： 不准确，因为图速度，选取的指标太少了，其实结果是不准确的； 人为因素较多，在建模的时候，一想就知道恢复后更好，所以靠眼看，都知道谁好，有种从结论写过程的感觉； 到这里第一题就做完了，看起来还很顺利，但后面我们就陷入了瓶颈 亚太杯C题第二小问 读完题目之后，我们可以从其中选取几个关键词：请选择合适的指标，收集相关数据，建立数学模型，评估塞罕坝对北京抗沙能力的影响，定量评估塞罕坝在北京抗沙尘暴中的作用。 选取合适的指标，我们采用的是主成分分析法，根据第一问，我们选择从经济与森林面积出发建立经济层面与森林面积层面的指标，经过数据收集并且对数据进行了优化处理，通过对京津冀2019年的影响抗沙能力的林业面积和林业经济的各项指标进行主成分分析（在做主成分分析之前一定要进行数据优化，要不然就会因为尺度不一样而出大问题），根据总方差的解释结果，找到占比最大的指标，即为影响最大的指标，通过主成分分析法，找到四个主要指标，分别为林业总产值、林业用地面积、森林覆盖率，找到相关专业论文，找到了AQI，一共四个主要指标。 评估塞罕坝对北京抗沙能力的影响，这个要求我们当时也是没读明白，为什么塞罕坝会影响北京的抗沙能力，后来想了想，就是塞罕坝建立前怎么样，与建立后，北京的一些指标的对比，所以根据这四个指标在2001年与2019年的数据对比，得出了结论，（2001年塞罕坝已初步建成，但是国家统计局的网站上，最早只能找到2001，所以我们只选了2001年的），可以看出，2019年北京的四项指标，明显好于2001年。 关于塞罕坝在北京抗沙过程中的作用，我们的找到NOx 与SO2 比值的年际变化图： 根据增长趋势，我们得出结论：塞罕坝人工林不仅改善了当地的生态环境，而且对京、津及其周边地区的生态环境质量的改善起到重要作用。 亚太杯C题第三小问 刚看到这题，瞬间就懵了，来确定中国哪些地理位置需要建设生态区，一开始没有进行深入思考，就开始疯狂查找数据，我们发现，生态区分为：植物、动物、地形等，还有国家级，市级、县级。。。。。。。一开始就想无头苍蝇一样搜集数据，后来我们发现了关键的一点，将塞罕坝的生态保护模式推广到全国，我们就要弄清楚，塞罕坝的生态模式是什么，通过查阅资料，塞罕坝的生态模式就是，通俗来说，就是有风沙，然后，种树，那我们可不可以找到中国风沙最严重的地区，于是就开始根据全国风沙地图来选择， 不难看出来，那几个颜色最深的地方，就是风沙最严重的地方，来建立生态保护区。 1.生态保护区的指标：分为两层，一层是森林覆盖率和森林产值，第二层是几个乱七八糟的指标，因为我国建立生态区的标准过于复杂，所以我们从政府文件中选取了几个关键的指标。 2.判断其是否能建立：开始查找数据，因为地理位置偏远而且有的还是小县城，所以数据基本上，只有1年的数据，那没办法了，也只能硬着头皮来上，那么，该如何判断呢，这时，我突发奇想，既然我们这些小地方找不到数据，那我们找全国最大的，于是，我们利用神经网络算法，倒入了几组成功建立生态区的地区数据，经过机器学习，来判断我们找的这几个地方是否能建立生态区，后来一试，误差居然很小 代码如下 123456789101112131415161718192021222324252627282930313233343536373839y=input(&#x27; input data&#x27;);n=length(y);yy=ones(n,1);yy(1)=y(1);for i=2:n yy(i)=yy(i-1)+y(i)endB=ones(n-1,2);for i=1:(n-1) B(i,1)=-(yy(i)+yy(i+1))/2; B(i,2)=1;endBT=B&#x27;;for j=1:(n-1) YN(j)=y(j+1);endYN=YN&#x27;;A=inv(BT*B)*BT*YN;a=A(1);u=A(2);t=u/a;t_test=input(&#x27; numbers&#x27;);i=1:t_test+n;yys(i+1)=(y(1)-t).*exp(-a.*i)+t;yys(1)=y(1); for j=n+t_test:-1:2 ys(j)=yys(j)-yys(j-1);endx=1:n;xs=2:n+t_test;yn=ys(2:n+t_test);plot(x,y,&#x27;^r&#x27;,xs,yn,&#x27;*-b&#x27;);det=0;for i=2:n det=det+abs(yn(i)-y(i));enddet=det/(n-1);disp([&#x27; deviation：&#x27;,num2str(det),&#x27;%&#x27;]); disp([&#x27; predict：&#x27;,num2str(ys(n+1:n+t_test))]); 12345678910111213141516171819202122net = newff(minmax(P),[7,1],&#123;&#x27;tansig&#x27;,&#x27;purelin&#x27;&#125;,&#x27;trainlm&#x27;); net.trainParam.show=50;% net.trainParam.lr=0.05; net.trainParam.epochs=1000; net.trainParam.goal=1e-5;[net,tr]=train(net,P,T);net.iw&#123;1,1&#125;net.b&#123;1&#125;net.lw&#123;2,1&#125;net.b&#123;2&#125;P2=[-1;2];y3=sim(net,P2); 喜出望外，于是我们就利用神经网络算法给解决了问题，最大的缺点就是，数据根本找不到，我们后来都想编上几组 ，但是还好成功做出来了。 亚太杯C题第四小问 请从亚太地区选择另一个国家建立数学模型，因为不知道有什么可选取的规则，为了查找数据方便，我们就选了中国的好朋友，巴基斯坦，和第四问的思路差不多，还是寻找风沙图，但我们遇到了一个问题，就是找不到风沙图，毕竟不是在国内，于是转变思路，我们找了森林的分布图以及降水图 通过枚举法，说白了就是拿眼看 ，我们找到了以下地区的4项指标 通过灰色关联分析，和灰色预测，先判断其关联性，再通过灰色预测的斜率判断其建立生态区的规模，最终得出结果，找到了适合建立生态区的地区 代码如下 123456789101112131415161718192021222324252627282930313233343536373839y=input(&#x27; input data&#x27;);n=length(y);yy=ones(n,1);yy(1)=y(1);for i=2:n yy(i)=yy(i-1)+y(i)endB=ones(n-1,2);for i=1:(n-1) B(i,1)=-(yy(i)+yy(i+1))/2; B(i,2)=1;endBT=B&#x27;;for j=1:(n-1) YN(j)=y(j+1);endYN=YN&#x27;;A=inv(BT*B)*BT*YN;a=A(1);u=A(2);t=u/a;t_test=input(&#x27; numbers&#x27;);i=1:t_test+n;yys(i+1)=(y(1)-t).*exp(-a.*i)+t;yys(1)=y(1); for j=n+t_test:-1:2 ys(j)=yys(j)-yys(j-1);endx=1:n;xs=2:n+t_test;yn=ys(2:n+t_test);plot(x,y,&#x27;^r&#x27;,xs,yn,&#x27;*-b&#x27;);det=0;for i=2:n det=det+abs(yn(i)-y(i));enddet=det/(n-1);disp([&#x27; deviation：&#x27;,num2str(det),&#x27;%&#x27;]); disp([&#x27; predict：&#x27;,num2str(ys(n+1:n+t_test))]); 亚太杯C题第五小问 第五问应该是纯文字描述我们的模型，不用再建模了，所以就基本上把前四题叙述了一遍。 写完了之后，算上附录一共26页，成就感满满，也没想到能够取得三等奖，今年国赛加油。","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"}]},{"title":"数字信号处理FFT快速傅立叶变换MATLAB实现——实例","slug":"数字信号处理FFT快速傅立叶变换MATLAB实现——实例","date":"2022-11-22T12:25:52.000Z","updated":"2023-03-24T05:42:04.734Z","comments":true,"path":"2022/11/22/数字信号处理FFT快速傅立叶变换MATLAB实现——实例/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/22/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86FFT%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2MATLAB%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"今天做作业的时候发现要对一个信号进行FFT变换，在网上找了半天也没找到个能看懂的（因为我太菜了），后来自己研究了一下，感觉一知半解的 起因是这道作业题 ## 例题-满足奈奎斯特 我画了两个图，一个是原信号经过采样后的离散图，一个就是此信号经过FFT后的频谱图 因为是8kHZ采样，所以信号不会失真，频谱也是正确的 解答如下： 12345678910111213141516171819clearclose allclcfs=8000;%采样频率n=0:99;%采样点100个y=sin(0.00625*2*pi*n)+sin(0.0625*pi*2*n)+sin(0.125*2*pi*n);%采样后的信号 0.00625=50/8000subplot(2,1,1);stem(n,y)title(&#x27;抽样后信号的时域图像&#x27;)xlabel(&#x27;n&#x27;);ylabel(&#x27;幅值&#x27;);Y = fft(y);%进行fft变换f=(0:length(Y)-1)*fs/length(Y);%在频域，转换坐标为f，f= n*(fs/N)=Y的长度*采样频率,还是8k，但是在Matlab需要经过这样的运算subplot(2,1,2)stem(f,abs(Y));title(&#x27;信号频谱图&#x27;)xlabel(&#x27;f/Hz&#x27;)ylabel(&#x27;幅度&#x27;) 那么，如果采样频率没有满足奈奎斯特抽样定律，会发生什么呢 正好作业的第二道题就是不满足的 例题-不满足奈奎斯特 在这里插入图片描述 12345678910111213141516171819clearclose allclcfs=800;%采样频率n=0:99;%采样点100个y=sin(0.0625*2*pi*n)+sin(0.625*pi*2*n)+sin(1.25*2*pi*n);%采样后的信号 0.00625=50/8000subplot(2,1,1);stem(n,y)title(&#x27;抽样后信号的时域图像&#x27;)xlabel(&#x27;n&#x27;);ylabel(&#x27;幅值&#x27;);Y = fft(y);%进行fft变换f=(0:length(Y)-1)*fs/length(Y);%在频域，转换坐标为f，f= n*(fs/N)=Y的长度*采样频率,还是8k，但是在Matlab需要经过这样的运算subplot(2,1,2)stem(f,abs(Y));title(&#x27;信号频谱图&#x27;)xlabel(&#x27;f/Hz&#x27;)ylabel(&#x27;幅度&#x27;) 感觉和想象中不太一样，我还以为会乱成一片，那么经过观察，我们可以看到，在200HZ和300HZ出现了峰值，为啥在这里呢 因为以400HZ为对称轴的话，500HZ就走到400HZ那里又原路返回，1000HZ也同理 500HZ变成了红色的400HZ+100HZ 1000HZ变成了蓝色的400HZ+400HZ+200HZ 这就是频谱失真的情况 后续思考 然后看了这个，在上课时我又问了老师一个很弱智的问题 既然频谱不是混乱的，那倒着推出未失真的信号不就行了？ 后来得到解答，仔细想一想就能发现，假如在200HZ幅度很大，那他既有可能是200HZ，也有可能是600HZ，也有可能是1000HZ等等，其实就是无限的 所以说即使是向上图那样的情况，也依旧不可能知道原信号的频率","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"数字信号处理信号抽样与插值MATLAB实现——实例","slug":"数字信号处理信号抽样与插值MATLAB实现——实例","date":"2022-11-21T11:34:11.000Z","updated":"2023-03-24T05:32:12.586Z","comments":true,"path":"2022/11/21/数字信号处理信号抽样与插值MATLAB实现——实例/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/21/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7%E6%8A%BD%E6%A0%B7%E4%B8%8E%E6%8F%92%E5%80%BCMATLAB%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"因为之前MATLAB没有好好学，而且DSP也没有好好学，做起作业来十分困难，为了好好写作业，我又重新研究了DSP和MATLAB，学了一下信号的抽样和插值 先看一看x(n)原本的图像 代码如下 123456789101112%定义基本参数f=1;%原信号频率fs=16;%抽样信号频率N=52;%采样点数n=0:N-1;%画原序列图像xn=cos(2*pi*n*(f/fs));stem(n,xn)title(&#x27;原x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;) 题目中说了f/fs=16，也就是说T=16，在图像中也吻合 那么我们要将其进行4倍的抽样，该怎么做 实现代码如下 1234567891011121314151617%定义基本参数f=1;%原信号频率fs=16;%抽样信号频率N=52;%采样点数n=0:N-1;xn=cos(2*pi*n*(f/fs));%画M=4倍抽样的x(n)M=4;m=0:N/M-1;%52/4=13 13-1=12 0:12有13个点xn1=decimate(xn,M);%对序列进行抽样subplot(3,1,2)stem(m,xn1)%注意对上m和xn1title(&#x27;进行M=4倍抽取后的x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;) 抽样函数 其中decimate()函数的意思就是抽样 1decimate(xn,M)%表示对xn进行M倍的抽样，并不能进行插值 注意看图像的横坐标，之前的T=16，现在的T=4 下面对信号进行插值 12345678910111213141516%定义基本参数f=1;%原信号频率fs=16;%抽样信号频率N=52;%采样点数n=0:N-1;xn=cos(2*pi*n*(f/fs));%画L=3倍插值的x(n)L=3;xn2=interp(xn,L);p=0:N*L-1;stem(p,xn2)title(&#x27;进行L=3倍插值后的x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;) 插值函数 1interp(xn,L);%表示对xn进行L的插值，L必须为正整数 同样，观察横坐标，既然L=3，那么T就变成了48 在画图时要注意stem()里面的参数，常常会因为抽样点和信号对不上画不出来 完整代码 12345678910111213141516171819202122232425262728293031323334353637clearclose allclc%定义基本参数f=1;%原信号频率fs=16;%抽样信号频率N=52;%采样点数n=0:N-1;%画原序列图像xn=cos(2*pi*n*(f/fs));%subplot(3,1,1)stem(n,xn)title(&#x27;原x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;)%画M=4倍抽样的x(n)M=4;m=0:N/M-1;%52/4=13 13-1=12 0:12有13个点xn1=decimate(xn,M);%对序列进行抽样subplot(3,1,2)stem(m,xn1)%注意对上m和xn1title(&#x27;进行M=4倍抽取后的x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;)%画L=3倍插值的x(n)L=3;xn2=interp(xn,L);p=0:N*L-1;subplot(3,1,3)stem(p,xn2)title(&#x27;进行L=3倍插值后的x(n)图像&#x27;)xlabel(&#x27;n&#x27;)ylabel(&#x27;幅度&#x27;)","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"数字信号处理MATLAB作业一（题目+解答代码）","slug":"数字信号处理MATLAB作业一（题目+解答代码）","date":"2022-11-21T11:34:11.000Z","updated":"2023-03-24T05:53:13.707Z","comments":true,"path":"2022/11/21/数字信号处理MATLAB作业一（题目+解答代码）/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/21/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86MATLAB%E4%BD%9C%E4%B8%9A%E4%B8%80%EF%BC%88%E9%A2%98%E7%9B%AE+%E8%A7%A3%E7%AD%94%E4%BB%A3%E7%A0%81%EF%BC%89/","excerpt":"","text":"在这里插入图片描述 123456789101112131415161718192021222324252627282930313233clear;close all;clc;A=[1 2 3 4];B=[3 4 5 6];C=A+B;D=A-B;E=A.*BF=A./BF=A.^BG=A.^Bsubplot(4,2,1)stem(A)xlabel(&#x27;A&#x27;)subplot(4,2,2)stem(B)xlabel(&#x27;B&#x27;)subplot(4,2,3)stem(C)xlabel(&#x27;C&#x27;)subplot(4,2,4)stem(D)xlabel(&#x27;D&#x27;)subplot(4,2,5)stem(E)xlabel(&#x27;E&#x27;)subplot(4,2,6)stem(F)xlabel(&#x27;F&#x27;)subplot(4,2,[7,8])stem(G)xlabel(&#x27;G&#x27;) 在这里插入图片描述 在这里插入图片描述 为了看得更清楚我多画了一个(5),是(3)的以10为周期 1234567891011121314151617181920212223242526272829303132333435363738394041clear;close all;clc;n1=0:15;x1=0.8.^n1subplot(2,3,1)stem(x1)xlabel(&#x27;(1)&#x27;)n2=0:15;x2=exp((0.2+3*i)*n2);subplot(2,3,2)stem(x2)xlabel(&#x27;(2)&#x27;)n3=0:15;x3=3*cos(0.125*pi*n3+0.2*pi)+2*sin(0.25*pi*n3+0.1*pi);subplot(2,3,3)stem(x3)xlabel(&#x27;(3)&#x27;)n4=0:80n44=mod(n4,16);x4=3*cos(0.125*pi*n44+0.2*pi)+2*sin(0.25*pi*n44+0.1*pi);subplot(2,3,4)stem(x4)xlabel(&#x27;(4)&#x27;)n5=0:10x5=3*cos(0.125*pi*n5+0.2*pi)+2*sin(0.25*pi*n5+0.1*pi);subplot(2,3,5)stem(x5)xlabel(&#x27;(5)&#x27;)n6=0:50n66=mod(n6,10)x6=3*cos(0.125*pi*n66+0.2*pi)+2*sin(0.25*pi*n66+0.1*pi);subplot(2,3,6)stem(x6)xlabel(&#x27;(6)&#x27;) （1) 123456789clear;close all;clc;n=0:3;x=[1 -1 2 -5];x1=2*circshift(x,[0 -2])-circshift(x,[0 1])-2*x;stem(x1)xlabel(&#x27;时间序列n&#x27;) （2) 1234567891011121314clear;close all;clc;n=0:3;x=[1 -1 2 -5];x1=circshift(x,[0 1]);x2=circshift(x,[0 2]);x3=circshift(x,[0 3]);x4=circshift(x,[0 4]);x5=circshift(x,[0 5]);xn=1*x1+2*x2+3*x3+4*x4+5*x5;stem(xn)xlabel(&#x27;时间序列n&#x27;) 12345678910function stepshiftclc;n1=input(&#x27;请输入起点： &#x27;);n2=input(&#x27;请输入终点:&#x27;);n0=input(&#x27;请输入阶跃位置:&#x27;);n=n1:n2;x=[n-n0&gt;=0];stem(n,x,&#x27;fill&#x27;);xlabel(&#x27;时间序列n&#x27;);ylabel(&#x27;u(n-n0)&#x27;);end 123456789101112131415161718clear;close all;clc;B=[1 sqrt(2) 1];A=[1 -0.67 0.9];[H,w]=freqz(B,A);Hf=abs(H); %取幅度值实部Hx=angle(H); %取相位值对应相位角clf;subplot(2,1,1)plot(w,20*log10(Hf)) %幅值变换为分贝单位title(&#x27;离散系统幅频特性曲线&#x27;)subplot(2,1,2)plot(w,Hx)title(&#x27;离散系统相频特性曲线&#x27;) 12345678910111213141516clear;close all;clc;na=0:4;nb=0:3;n=0:7;A=[8 -2 -1 2 3];B=[2 3 -1 -3];subplot(3,1,1)stem(na,A)subplot(3,1,2)stem(nb,B)C=conv(A,B);subplot(3,1,3)stem(n,C) 在这里插入图片描述","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"从零开始的STM32F1课程学习(STM32CubeMX)","slug":"从零开始的STM32F1课程学习(STM32CubeMX)","date":"2022-11-21T03:10:38.000Z","updated":"2023-03-24T12:25:18.794Z","comments":true,"path":"2022/11/21/从零开始的STM32F1课程学习(STM32CubeMX)/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84STM32F1%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0(STM32CubeMX)/","excerpt":"","text":"新学期新气象，新学期我们要学32了，之前虽然学了一点点，但是学的都不是很系统，这里终于能系统的学习一下32了，从原理角度进行一下学习。 我的基本配置：STM32CubeMX、Jlink、STM32F103RCT6 MINI STM32MINI就是我们学校上课用的32 第一节课 嵌入式就是在单片机上跑操作系统 STM32芯片内部 这是STM32的命名规则 时钟最高72M PIN to PIN兼容是指两款芯片的引脚数目一样，功能一样，大小也一样 通过修改BOOT0和BOOT1的方式来修改32的启动方式，利用跳线帽改这个 将2,4等引脚短接来修改其启动方式 ### 第一节课课后练习：点灯 灯的连线 1.配置好Cube的Project Manager 路径和工程名称设置 Code Generator设置 #### 2.时钟树设置 都改成最高的 #### 3.RCC设置 #### 4.Debug模式设置 #### 5.LED0引脚设置 设置为GPIO_Output #### 6.生成代码 12345678910111213141516171819202122void MX_GPIO_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOD_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET); /*Configure GPIO pin : PA8 */ GPIO_InitStruct.Pin = GPIO_PIN_8; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125; 下面是标准库的配置 1234567891011121314void LED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitTypeStrucre; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); GPIO_InitTypeStrucre.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_InitTypeStrucre.GPIO_Pin=GPIO_Pin_8 ; GPIO_InitTypeStrucre.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitTypeStrucre); GPIO_SetBits(GPIOA,GPIO_Pin_8 );&#125; 7.在主函数while中写出灯的亮灭 HAL_Delay(1)实际延时时间多于1ms一点 123456/* USER CODE END WHILE *//* USER CODE BEGIN 3 */HAL_Delay(300); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET); HAL_Delay(300); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET); #### 8.配置Jlink #### 9.检测芯片 注意：要先给芯片上电，再连接Jlink #### 10.编译后下载 ## 第二节课 什么是看门狗？ 是一个定时器，将里面的数值加到一定数值之后，会被复位 所以在程序中每隔多少秒要把看门狗复位 看门狗主要用于无人看管的程序，防止程序跑飞了 GPIO：General Purpose Input Output，通用输入输出 输出三种：1.推挽2.开漏3.关闭 ### 第二节课课后练习：按键控制灯的亮灭 1.配置好基础配置，和上面前4步一样 2.启用按键和LED的引脚 #### 3.配置好GPIO KEY0采用上拉模式和输入模式 我一般习惯把名字起的和原理图一模一样，这样代码读起来方便 #### 4.在while中写出按键检测 12345678910111213while (1)&#123;if(HAL_GPIO_ReadPin(KEY0_GPIO_Port, KEY0_Pin)==GPIO_PIN_RESET)&#123; HAL_Delay(10); if(HAL_GPIO_ReadPin(KEY0_GPIO_Port, KEY0_Pin)==GPIO_PIN_RESET) &#123; HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin); while(HAL_GPIO_ReadPin(KEY0_GPIO_Port, KEY0_Pin)==GPIO_PIN_RESET); &#125;&#125; /* USER CODE END WHILE */&#125; 5.编译后下载成功 下载后要先按一下Reset才能成功执行 第三节课 第三节课课后练习：外部中断控制灯 1.配置好基础配置，和第一节课4步一样 2.配置按键的GPIO模式 #### 3.在主函数中让程序执行LED0的亮灭 让LED0闪烁，LED1灭 1234567891011while (1)&#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */HAL_Delay(300);HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);HAL_Delay(300);HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);&#125; 4. 在stm32f1xx_hal_gpio.c中找到中断回调函数 如果按下按键，则LED1亮，表示进入外部中断 123456789101112131415161718__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123; /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */ if(GPIO_Pin==GPIO_PIN_1) &#123; if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_1)==0) &#123; HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); &#125; __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_1); &#125;&#125; #### 5.编译后成功下载 第四节课 第四节课系统学习了外部中断 ### 第四节课课后练习：在while(1)中执行灯的同步闪烁，按下KEY0按键，灯闪烁加快20次，按下WKUP，灯交替闪烁20次，KEY0的优先级更高 #### 1.配置好基础配置 #### 2.配置按键的GPIO 在CUBE中都设置为GPIO_EXTI模式 因为KEY0接地，我们配置成上拉模式 同理，配置WKUP #### 3.在NVIC中配置中断优先级 数字越小，优先级越高 #### 4.配置两个灯为推挽输出 5.在while(1)中写出同步闪烁 12345678910111213while (1)&#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);delay_ms(500);HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);delay_ms(500);&#125;/* USER CODE END 3 */ delay_ms 1234567891011121314//毫秒延时void delay_ms(uint16_t nms)&#123; uint32_t temp; SysTick-&gt;LOAD = 9000*nms; SysTick-&gt;VAL=0X00;//清空计数器 SysTick-&gt;CTRL=0X01;//使能，减到零是无动作，采用外部时钟源 do &#123; temp=SysTick-&gt;CTRL;//读取当前倒计数值 &#125;while((temp&amp;0x01)&amp;&amp;(!(temp&amp;(1&lt;&lt;16))));//等待时间到达 SysTick-&gt;CTRL=0x00; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器&#125; 6.在stm32f10x_hal_gpio.c中写中断回调函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123; /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */ if(GPIO_Pin==GPIO_PIN_1) &#123; if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_1)==0) &#123; for(int i=0;i&lt;20;i++) &#123; HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8,GPIO_PIN_RESET); delay_ms(200); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8,GPIO_PIN_SET); delay_ms(200); &#125; &#125; __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_1); &#125; if(GPIO_Pin==GPIO_PIN_0) &#123; if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)==0) &#123; for(int i=0;i&lt;20;i++) &#123; HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8,GPIO_PIN_SET); delay_ms(200); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8,GPIO_PIN_RESET); delay_ms(200); &#125; &#125; __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0); &#125; &#125; 7.编译成功后下载 在这个作业中不要将按键设置成浮空，浮空状态会有点问题，要根据引脚设置成需要的状态 第五节课 高级定时器 TIM1 TIM8 在APB1上 通用定时器 TIM2 TIM3 TIM4 TIM5 在APB2上 基本定时器 TIM6 TIM7 在APB1上 周期表 p n u m 1 K M G T 更新事件Update event(UE) 可以把CNT清零 1定时器时间t=1/Tout 如果使能影子寄存器，影子寄存器会在更新事件发生时，将内部数值更新到ARR ARR是计算时间间隔所以要加1 因为PSC不能为0，所以要加上1 ### 第五节课课后练习：定时器实现灯的500ms间隔闪烁，和另一个灯的700ms闪烁 #### 1.配置好基础配置 #### 2.打开TIM2和TIM3 arr和psc的计算过程 123(4999+1)*(7199+1)=3600000072000000/36000000=21/2=0.5s=500ms 3.在NVIC中设置优先级 在这里插入图片描述 4.设置灯为推挽输出 在这里插入图片描述 5.打开定时器中断 main.c 123/* USER CODE BEGIN PV */static int i=0;/* USER CODE END PV */ 1234 /* USER CODE BEGIN 2 */HAL_TIM_Base_Start_IT(&amp;htim2);HAL_TIM_Base_Start_IT(&amp;htim3); /* USER CODE END 2 */ 在stm32f10x_hal_tim.c中找到中断回调函数，在main.c中重定义 123456789101112131415void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if(htim==&amp;htim2) &#123; HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_8);//对GPIO口的电平进行反转（低-高，高—低） &#125; if(htim==&amp;htim3) &#123; if(++i&gt;=700) &#123; i=0; HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_2);//对GPIO口的电平进行反转（低-高，高—低） &#125; &#125; 6.编译后成功下载 第六节课 第六节课课后练习：通过两个按键利用PWM控制灯的亮灭 1.配置好基础配置 2.打开TIM1_CH1 #### 2.在NVIC中打开中断 #### 3.设置两个按键的GPIO #### 4.写出按键检测代码和启动PWM 123456/* USER CODE BEGIN 1 */ int i=500; /* USER CODE END 1 */ /* USER CODE BEGIN 2 */ HAL_TIM_PWM_Start(&amp;htim1,TIM_CHANNEL_1); // 使能PWM输出 /* USER CODE END 2 */ 12345678910111213141516171819202122232425 /* USER CODE BEGIN 3 */if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_1)==GPIO_PIN_RESET)&#123; HAL_Delay(10); if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_1)==GPIO_PIN_RESET) &#123; i=i+1; htim1.Instance-&gt;CCR1 = i; HAL_Delay(1); while(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_1)==GPIO_PIN_RESET); &#125;&#125;if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)==GPIO_PIN_RESET)&#123; HAL_Delay(10); if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)==GPIO_PIN_RESET) &#123; i=i-1; htim1.Instance-&gt;CCR1 = i; HAL_Delay(1); while(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)==GPIO_PIN_RESET); &#125;&#125;&#125;/* USER CODE END 3 */ 5.编译后下载 第七节课 第七节课课后作业：串口的收发回显测试 1.配置好基础配置 2.打开串口 设置异步模式和打开中断 #### 3.在main.c中添加fputc fgetc 123456789101112131415161718192021222324/** * 函数功能: 重定向c库函数printf到DEBUG_USARTx * 输入参数: 无 * 返 回 值: 无 * 说 明：无 */int fputc(int ch, FILE *f)&#123; HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xffff); return ch;&#125; /** * 函数功能: 重定向c库函数getchar,scanf到DEBUG_USARTx * 输入参数: 无 * 返 回 值: 无 * 说 明：无 */int fgetc(FILE *f)&#123; uint8_t ch = 0; HAL_UART_Receive(&amp;huart1, &amp;ch, 1, 0xffff); return ch;&#125; 4.主函数代码 定义了一个字符串 123/* USER CODE BEGIN 1 */ char str[10]; /* USER CODE END 1 */ 因为scanf在单片机中并不是阻塞式接收，所以我们要将其改为阻塞式的 12345678910/* USER CODE BEGIN 3 */ printf(&quot;测试发送\\n&quot;); HAL_Delay(100); str[0]=0; while(str[0] == 0) &#123; scanf(&quot;%s&quot;,str); &#125;//使其变成手动的阻塞式接收 HAL_Delay(1000); printf(&quot;output:%s\\n&quot;,str); 5.编译下载 可以发送也可以接收","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"stm32","slug":"stm32","permalink":"https://mengfanjun020906.github.io/tags/stm32/"},{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"TAO CONVERTER使用命令注释","slug":"TAO CONVERTER使用命令注释","date":"2022-11-19T12:14:41.000Z","updated":"2022-12-05T05:50:36.704Z","comments":true,"path":"2022/11/19/TAO CONVERTER使用命令注释/","link":"","permalink":"https://mengfanjun020906.github.io/2022/11/19/TAO%20CONVERTER%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E9%87%8A/","excerpt":"","text":"1234567891011121314tao-converter [-h] -k &lt;你的加密密钥-在NGC网站可以生成&gt; -d &lt;输入尺寸&gt; -o &lt;输出节点-用逗号分隔开&gt; [-c &lt;校准缓存文件路径&gt;] [-e &lt;输出引擎的路径&gt;] [-b &lt;校准批次尺寸&gt;] [-m &lt;TRT引擎的最大Batch_Size&gt;] [-t &lt;引擎的数据类型&gt;] [-w &lt;TRT引擎的最大工作空间大小&gt;] [-i &lt;输入尺寸的顺序&gt;] [-p &lt;优化文件&gt;] [-s] [-u &lt;DLA_core&gt;] input_file","categories":[{"name":"The 7th Sky Hackathon","slug":"The-7th-Sky-Hackathon","permalink":"https://mengfanjun020906.github.io/categories/The-7th-Sky-Hackathon/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TAO","slug":"TAO","permalink":"https://mengfanjun020906.github.io/tags/TAO/"},{"name":"Nvidia","slug":"Nvidia","permalink":"https://mengfanjun020906.github.io/tags/Nvidia/"}]},{"title":"智能采摘小车进展","slug":"智能采摘小车进展","date":"2022-10-24T02:17:45.000Z","updated":"2022-12-05T05:47:45.151Z","comments":true,"path":"2022/10/24/智能采摘小车进展/","link":"","permalink":"https://mengfanjun020906.github.io/2022/10/24/%E6%99%BA%E8%83%BD%E9%87%87%E6%91%98%E5%B0%8F%E8%BD%A6%E8%BF%9B%E5%B1%95/","excerpt":"","text":"此博客为记录419通信实验室智能小车+机械臂项目的进展博客 2022年10月6日 串口一对多下载与通信 在这里插入图片描述 实现了单片机A和单片机B的串口下载与接收 具体的操作步骤见那边写串口的文章 ### 实现了编码器EN1和EN3的读取 #### Cube配置 #### 代码配置 12345678910111213141516/* USER CODE BEGIN 4 *//****************************** 功能：每5ms在定时器中执行一次， 获取电机速度SPEED 返回值：电机速度SPEED 形参：无*******************************/int GetSpeed()&#123; short SPEED = 0;// static short last = 0; SPEED = (short)(__HAL_TIM_GET_COUNTER(&amp;htim2)*100)/(4*16*10);//哪个定时器对应不同的编码器 __HAL_TIM_SET_COUNTER(&amp;htim2,0); return SPEED;&#125;/* USER CODE END 4 */ int mian()里面，while（1）之前 1234567/*打开定时器中断*/HAL_TIM_Base_Start_IT((TIM_HandleTypeDef *)&amp;htim7);/*开启串口DMA接收，默认DMA为循环模式，千万不要放在循环里！！*/HAL_UART_Receive_DMA(&amp;huart1,(uint8_t*)&amp;TargetSpeed,sizeof(TargetSpeed));/*打开编码器捕获*/HAL_TIM_Encoder_Start(&amp;htim4,TIM_CHANNEL_ALL);//这是EN3HAL_TIM_Encoder_Start(&amp;htim2,TIM_CHANNEL_ALL);//这是EN1 结果 ## 2022年10月7日 ### 实现了四个编码器的读取 |定时器|编码器| |--|--| |TIM2|EN1| |TIM3|EN2| |TIM4|EN3| |TIM5|EN4| ## 2022年10月21日 实现了树莓派与STM32的收发数据测试 我们用的树莓派是4B，之前用了3B+的做了串口接收的测试，参考的是这一篇文章 树莓派3B+与STM32进行串口通讯，收数据是通了。发数据还有点问题，然后就去找了很多，发现是利用Python的Serial库进行的串口通讯 123456import serialdev=serial.Serial(&#x27;/dev/ttyAMA0&#x27;,115200,timeout=0.5)#读取串口号，设置波特率，连接超时0。5秒while True: print(dev.readlins())#读显示出串口的数据 s= 6 dev.write(&quot;&#123;&#125;\\r\\n&quot;.format(s).encode())#将s写入串口中 STM32程序 这里就关系到我们之前用的串口发送接收重定义了， 123456/*fgetc*/int fgetc(FILE * F)&#123;HAL_UART_Receive (&amp;huart1,&amp;ch_r,1,0xffff);//接收return ch_r;&#125; 这里的HAL_UART_Receive()他在HAL库中不是阻塞式接收，也就是说scanf在32中被执行的时候并不会暂停，所以为了确保其能接收到数据，我们要将他手动改成阻塞式的 12345678910111213/* USER CODE BEGIN 3 */ printf(&quot;Aaaa\\n&quot;); printf(&quot;1145141919810\\n&quot;); printf(&quot;woshiA\\n&quot;); HAL_Delay(1000); n=0; while(n == 0) &#123; scanf(&quot;%d&quot;,&amp;n); &#125;//使其变成手动的阻塞式接收 HAL_Delay(1000); printf(&quot;output:%d&quot;,n); HAL_Delay(1000); 接收发送成功截图 这里的output就是收到的数据，但是不知道为啥这个minicom显示的是这样的，不影响调试，就是很丑","categories":[],"tags":[{"name":"stm32","slug":"stm32","permalink":"https://mengfanjun020906.github.io/tags/stm32/"},{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"}]},{"title":"Mac用Pycharm安装mediapipe报错ERROR_ Could not find a version that satisfies the requirement mediapipe","slug":"Mac用Pycharm安装mediapipe报错ERROR_ Could not find a version that satisfies the requirement mediapipe","date":"2022-10-23T05:54:26.000Z","updated":"2022-12-05T05:49:10.311Z","comments":true,"path":"2022/10/23/Mac用Pycharm安装mediapipe报错ERROR_ Could not find a version that satisfies the requirement mediapipe/","link":"","permalink":"https://mengfanjun020906.github.io/2022/10/23/Mac%E7%94%A8Pycharm%E5%AE%89%E8%A3%85mediapipe%E6%8A%A5%E9%94%99ERROR_%20Could%20not%20find%20a%20version%20that%20satisfies%20the%20requirement%20mediapipe/","excerpt":"","text":"问题 因为最近要用python做一个手部检测的项目，于是用找了个开源的程序跑了跑，发现安装mediapipe的时候会报错 1ERROR: Could not find a version that satisfies the requirement mediapipe 百思不得其解，去网上找了好多的解答都不行，于是去Stackoverflow看了看，发现是因为苹果的M1和M2的问题，不能兼容mediapipe，正好我的电脑就是M2的，怪不得 ## 解决方案 1pip install mediapipe-silicon","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"https://mengfanjun020906.github.io/tags/python/"}]},{"title":"蓝桥杯单片机练习——可调节亮度的LED灯","slug":"蓝桥杯单片机练习——可调节亮度的LED灯","date":"2022-10-18T00:49:02.000Z","updated":"2022-12-05T05:08:09.985Z","comments":true,"path":"2022/10/18/蓝桥杯单片机练习——可调节亮度的LED灯/","link":"","permalink":"https://mengfanjun020906.github.io/2022/10/18/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%AF%E8%B0%83%E8%8A%82%E4%BA%AE%E5%BA%A6%E7%9A%84LED%E7%81%AF/","excerpt":"","text":"因为之前看到了第九届的省赛，LED彩灯控制，看到了一个给LED灯分等级亮度，直接望而生畏，遂放弃。 在和大佬沟通交流与过后，我发现实现LED的亮度控制一点也不难，先看代码，大部分人应该都能看懂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;reg51.h&gt;sbit k4=P3^3;sbit k5=P3^2;sbit k6=P3^1;sbit k7=P3^0;void stop()&#123; P2=(P2&amp;0x1f)|0x80; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xA0; P0 = P0 &amp; 0XAF; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xc0; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xe0; P0=0xFF; P2&amp;=0x1f;&#125;void delay_us(int us)&#123; while (us--);&#125;void main()&#123; unsigned int i; stop(); while(1) &#123; if(k4==0) &#123; P2=0x80; P0=0x00; &#125; if(k5==0) &#123; P2=0x80; P0=0x00; delay_us(10); P0=0xff; delay_us(10); &#125; if(k6==0) &#123; P2=0x80; P0=0x00; delay_us(5); P0=0xff; delay_us(5); &#125; if(k7==0) &#123; P2=0x80; P0=0x00; P0=0xff; &#125; &#125;&#125; 原理就是使LED灯快速闪烁，然后改变时间间隔，来达到控制亮度的结果，S4是最亮的，然后S7最暗，四个按键呈阶梯式分布，就这么简单。","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"数学建模算法学习笔记","slug":"数学建模算法学习笔记","date":"2022-10-13T10:32:18.000Z","updated":"2023-03-24T05:30:35.965Z","comments":true,"path":"2022/10/13/数学建模算法学习笔记/","link":"","permalink":"https://mengfanjun020906.github.io/2022/10/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"这是为了准备国赛突击学习的模型算法，我在原有的基础上加上自己的理解虽然不知道对不对，就是为了记录下自己学的模型他究竟是个什么东西，语言通俗，但是极不准确，只适合做一个大概的了解，建议大家详细的还是要看更专业的文章去学习，但是自己看着还是挺顺眼的，欢迎批评指正，里面我说的程序包就是老哥提供的程序包 视频来源：泰山教育小石老师数学建模教程 【零基础教程】老哥：数学建模算法、编程、写作和获奖指南全流程培训！ ahp决策比较 c1/c2为4表示c1比c2更加重要，如果是数值小于1，则表示其c1没有c2重要 z表示旅游选择要去的目的地，a1，a2，a3，a4，a5表示五个不同的考虑因素，例如，饮食，费用，居住等，b1，b2，b3表示旅游要去的地点 2.层次分析法算法用于多个元素之前，有多个决策条件，决策条件所占的比重不同，根据不同的比重，比较出最符合题目要求的结果； 3.多属性决策模型也是和层次分析算法一样，也是进行多属性元素的决策； 4.比较完多个矩阵后，得到的值，A的矩阵中的值，分别与B1，B2等中的对应第一个数乘起来，才是最终的比较结果 层次分析法使用方法 把代码直接复制到Matlab的命令行中，然后输入判决矩阵A，注意A一定要满足逻辑，不然一致性检验会不通过 插值与拟合 插值与拟合代码使用方法 数据之间有空缺，我们利用代码进行补全 123一维插值步骤（1）输入已知数据，x,y（2）输入待插自变量的值x1 12345二维插值步骤（1）先输入二维数据的x,y坐标值（2）输入Z数据（3）输入待插点的x,y坐标（4）应用函数插值即可 123多项式拟合步骤(1)输入待拟合数据x,y(2)输入函数公式进行拟合 灰色预测模型 1.灰色预测模型是通过少量的、不完全的信息，建立出数学模型，并做出预测的一种预测方法，预测是根据过去和现在的发展规律，借助科学的方法对其未来趋势进行预测，描述和分析。 2.运用GM（1，1）的方法对数据进行预测，得出的结果需要检验，检验表格如下 最后拟合出数据的下一个值和下下个值 灰色预测使用方法 1234灰色预测步骤（1）输入前期的小样本数据，要加上中括号（2）输入预测个数（3）运行 dijkatra模型 最短路径问题求解 weight= [0 2 8 1 Inf Inf Inf Inf Inf Inf Inf; 2 0 6 Inf 1 Inf Inf Inf Inf Inf Inf; 8 6 0 7 5 1 2 Inf Inf Inf Inf; 1 Inf 7 0 Inf Inf 9 Inf Inf Inf Inf; Inf 1 5 Inf 0 3 Inf 2 9 Inf Inf; Inf Inf 1 Inf 3 0 4 Inf 6 Inf Inf; Inf Inf 2 9 Inf 4 0 Inf 3 1 Inf; Inf Inf Inf Inf 2 Inf Inf 0 7 Inf 9; Inf Inf Inf Inf 9 6 3 7 0 1 2; Inf Inf Inf Inf Inf Inf 1 Inf 1 0 4; Inf Inf Inf Inf Inf Inf Inf 9 2 4 0;]; [dis, path]=dijkstra(weight,1, 11) 1为起始点，11位终点,根据所给的图形列出矩阵模型，用vi，与 vj进行比较 从起点数组（S）开始，遍历周围的点，从这些点（数组U）中找到距离最短的点，放入起点数组（S）中，就是这样的过程 ### dijkatra模型使用方法 1可以使用图论软件进行计算 floyd算法 计算最短路径问题 制作好加权距离矩阵，然后写进tulun的m中，用这个算法的时候，可以用dijistra喝floyd两种算法，经过比较，用最合适的 模拟退火模型 用来解决tsp问题，就是一个旅行商要拜访n个城市，要走的路径是每个城市只能拜访一次，而且最后要回到出发的城市，路径选择的目标是要求得路径路程为所有路径之中的最小值。 需要更改的的只有tsp.m里面的城市坐标参数 模拟退火算法主要用于难以准确求出具体的解的问题之中。通过多次迭代，它可以不断地接近最优解。每次求解可能的结果可能都不一样，因为是在不断趋于最优解的。 就是在随机中找到全局的最优解，和爬山算法不同，爬山算法找不到全局的最优解，只能找到部分区间的最优解。 ### 模拟退火使用方法 例子 1求目标函数f(x)=x1^2+x2^2+8在x1^2-x2&gt;0;-x1-x2^2+2=0约束下的最小值问题 1231.复制代码2.调整参数，把变量名都改过来3.执行程序 在这里修改程序参数 123%产生随机扰动（3）新解的产生 sol_new2=sol_new2+rand*0.2; sol_new1=2-sol_new2^2; 12%检查是否满足约束 if sol_new1^2-sol_new2&gt;=0 &amp;&amp; -sol_new1-sol_new2^2+2==0 &amp;&amp; sol_new1&gt;=0 &amp;&amp;sol_new2&gt;=0 12%退火过程 E_new=sol_new1^2+sol_new2^2+8;%（2）目标函数 种群竞争模型 表示两个种群在竞争后的结果 这是初始条件的配置 12345678function dx=fun(t,x,r1,r2,n1,n2,s1,s2)r1=1;%r1和r2都表示为自然增长率r2=1;n1=100;%甲种群初始数量n2=100;%乙种群初始数量s1=0.5;%表示甲物种的生存能力较强s2=2;%表示乙物种的生存能力较弱，以1为分界点，大于1，生存能力弱dx=[r1*x(1)*(1-x(1)/n1-s1*x(2)/n2);r2*x(2)*(1-s2*x(1)/n1-x(2)/n2)]; 这是进行运算 12345678h=0.1;%所取时间点间隔ts=[0:h:30];%时间区间x0=[10,10];%初始条件opt=odeset(&#x27;reltol&#x27;,1e-6,&#x27;abstol&#x27;,1e-9);%相对误差1e-6，绝对误差1e-9[t,x]=ode45(@fun,ts,x0,opt);%使用5级4阶龙格—库塔公式计算plot(t,x(:,1),&#x27;r&#x27;,t,x(:,2),&#x27;b&#x27;,&#x27;LineWidth&#x27;,2),grid;pause;%r表示为第一个种群，b表示为第二个种群plot(x(:,1),x(:,2),&#x27;LineWidth&#x27;,2),grid %作相轨线 若要使物种同时存活，主要是改变s1，s2的数值，才能改变竞争的结果，且s1&lt;1,s2&lt;1 排队论 现实生活中的排队现象 排队过程是一个随机过程 1.顾客的输入过程 2.排队结构和排队规则，列间转移的意思是：我排这个队的时候，发现另一个队列人更少，所以我去排另一个了 3.服务结结机构和服务规则 系统运行指标参数，用来评价排队系统的优劣 队长：系统中的顾客数，包括被服务的顾客和正在排队的顾客 排队长：系统中等待服务的顾客数 逗留时间：指一个顾客在系统中的所有时间 等待时间：一个顾客在系统中的排队等待时间 服务强度： M/M/1排队系统 M/M/S排队系统 123456789101112131415161718192021222324s=2;%窗口数量mu=4;%每小时服务台服务人数lambda=3;%每小时到达人数ro=lambda/mu;ros=ro/s;sum1=0;for i=0:(s-1) sum1=sum1+ro.^i/factorial(i);endsum2=ro.^s/factorial(s)/(1-ros);p0=1/(sum1+sum2);p=ro.^s.*p0/factorial(s)/(1-ros);Lq=p.*ros/(1-ros);L=Lq+ro;W=L/lambda;Wq=Lq/lambda;fprintf(&#x27;排队等待的平均人数为%5.2f人\\n&#x27;,Lq)fprintf(&#x27;系统内的平均人数为%5.2f人\\n&#x27;,L)fprintf(&#x27;平均逗留时间为%5.2f分钟\\n&#x27;,W*60)fprintf(&#x27;平均等待时间为%5.2f分种\\n&#x27;,Wq*60) 排队论使用方法 1234567891011121314151617181920212223242526272829步骤：（1）确定问题是否属于排队论领域（2）确定修理工个数s（3）确定机器源数m（4）找到时间终止点T（5）带入模型即可function out=MMSmteam(s,m,mu1,mu2,T)%M/M/S/m排队模型%s——修理工个数%m——机器源数%T——时间终止点%mu1——机器离开-到达时间服从指数分布%mu2——修理时间服从指数分布%事件表：% p_s——修理工空闲概率% arrive_time——机器到达事件% leave_time——机器离开事件%mintime——事件表中的最近事件%current_time——当前时间%L——队长%tt——时间序列%LL——队长序列%c——机器到达时间序列%b——修理开始时间序列%e——机器离开时间序列%a_count——到达机器数%b_count——修理机器数%e_count——损失机器数以上是需要修改的参数 主成分分析法 根据spss进行数据分析，结合多个因素，对一个因素进行分析，例如：对对各城市进行分析，通过城市的多项数据，结合spss计算出F1和F2，最后将F1和F2相加，算出总F，将F排序，得出最终结果。 ### 主成分分析降维使用方法 123456789PCA步骤：（1）对原始数据进行标准化处理（2）计算样本相关系数矩阵（3）计算相关系数矩阵R的特征值和相应的特征向量（4）选择重要的主成分，写出主成分表达式 聚类分析 聚类分析不必事先给出分析的标准，从样本出发，自动进行分析。 进行spss进行分析，主要看的是树状图，冰柱图直接放到论文里面就行，没那么重要 ### 聚类分析使用方法 3种聚类方法区别不大，直接把函数导入进行使用就好 ## 多元回归分析 为了了解多个变量之间是否相关。 虽然自变量和因变量之间没有严格的、确定的函数关系，但可以设法找出最代表他们的数学关系。 BP神经网络模型 关于这个模型我实在不是很理解，所以只能进行一下粗略的阐述，我感觉其实就是用来分类的，将多种元素进行分类 。（上面是我一年前说的话了）这个暑假我又入坑了机器学习，自己也搭建了几个神经网络，他这里说到的BP神经网络的核心其实就是这个BP，反向传播，在python里面我记得有个优化器直接就叫反向传播，这个神经网络分为前向传播和反向传播，反向传播太详细的我也说不清，大概意思就是使每一个神经元更准确 神经网络更多的是用来解决分类问题，但不同于SVM那些，如果数据互相穿插的很多，那SVM会出现过拟合，行不通，所以这个神经网络就是你输入一些数据进行学习，学习几轮之后，再输进去要预测的数值进行分类，现在Matlab的Classification应该是没有python的全，到时候如果能用python做尽量用python BP神经网络模型使用方法 选择神经网络的判断指标可以由层次分析法进行精确筛选，比如一开始有10个指标，然后利用层次分析法选5个出来，再利用神经网络这5个指标的数据进行分类，结果会更精确 12345P的每一行代表一个指标，每一列代表一个元素P=[-1 -1 2 2 4; 0 5 0 5 7];%-1和0作比较，代表两个元素一个多一个少，剩下的依次类推，两个矩阵列要一致 T=[-1 -1 1 1 -1]; %-1和1代表两个事件的结果，用来进行评价 Performance表示误差，误差小表示其模型合理； Training State表示中间参数的运转过程； 看最后的结果和谁更接近，如果接近-1就是-1的类，如果接近1就是1的类。 遗传算法 求某一个函数的极值问题，解决规划问题中最大值和最小值的关系； ### 遗传算法的使用方法 例子 123456% 求下列函数的最大值 %% f(x)=10*sin(5x)+7*cos(4x) x∈[0,10] %% 将 x 的值用一个10位的二值形式表示为二值问题，一个10位的二值数提供的分辨率是每为 (10-0)/(2^10-1)≈0.01 。 %% 将变量域 [0,10] 离散化为二值域 [0,1023], x=0+10*b/1023, 其中 b 是 [0,1023] 中的一个二值数。 %把所有的函数保存到函数库中再执行主程序 SVM分类器 在高维空间进行分类 ### SVM分类器使用方法 1231.先给出分类样本进行学习2.再输入新的需要分类的数据3.再执行以下函数 12345678910111213141516%更新部分值sum = zeros(n,1);for k = 1 : n for i = 1 : n sum(k) = sum(k) + a(i) * y(i) * K(i,k); endendWold = Wnew;Wnew = 0;%更新a后的W(a)tempSum = 0;%临时变量for i = 1 : n for j = 1 : n tempSum= tempSum + y(i )*y(j)*a(i)*a(j)*K(i,j); end Wnew= Wnew+ a(i);end 但我这里更推荐py的算法，直接导入数据就好 K-means算法 先定义一个类，找到类的中心点，然后再判断样本离每个中心点的距离，将这些点在都判断完之后，形成一个大的类，形成大的类以后再重新计算中心点，再将这些中心点进行比较，以此类推。 ### K-means算法使用方法 在演示数据中导入自己的数据，然后执行程序 12345678910111213%演示数据%% 1 random sample%随机生成三组数据a = rand(30,2) * 2;b = rand(30,2) * 5;c = rand(30,2) * 10;figure(1);subplot(2,2,1); plot(a(:,1), a(:,2), &#x27;r.&#x27;); hold onplot(b(:,1), b(:,2), &#x27;g*&#x27;);plot(c(:,1), c(:,2), &#x27;bx&#x27;); hold offgrid on;title(&#x27;raw data&#x27;); 蒙特卡洛算法模拟 用大量的数据实现一些确定性问题的计算，通过计算交点下的面积占一个矩形的比例，计算其面积。 ### 蒙特卡洛算法使用方法 1234蒙特卡洛法是经过大量事件的统计结果来实现一些确定性问题的计算。使用蒙特卡洛法必须使用计算机生成相关分布的随机数。例如：y = x^2 ，y = 12 - x与X轴在第一象限与X轴围成一个曲边三角形。设计一个随机试验，求该图形的近似值。利用撒豆子的方法，计算一个图形面积占用另一个图形面积的比例，利用此种方法计算其面积 Topsis算法 基于归一化后的原始数据矩阵，采用余弦法找出有限方案中的最优方案和最劣方案（分别用最优向量和最劣向量表示），然后分别计算各评价对象与最优方案和最劣方案间的距离，获得各评价对象与最优方案的相对接近程度，以此作为评价优劣的依据。 根据一个矩阵和一个标准矩阵对比，评价哪个矩阵是最好的 Topsis算法使用方法 1构建好矩阵直接执行程序就OK 回归预测分析 提供一定的原始数据，执行模型，得出新的预测结果。 ### 回归预测分析使用方法 123456789101112131415先修改原始数据%原始数据%公路客运量(万人)glkyl=[12815 15543 19326 22864 26150 28468 30882 39375 45759 49589 52560 48726 51083 56495 62767 83606 92090 101370 107317 108654 111847 112872 116997 126007 128980];%公路货运量(万吨)glhyl=[2690 2998 3012 3042 3616 3728 3988 9397 17680 19426 24128 24354 22879 24162 28957 36439 40593 45052 47400 45224 45338 45815 47151 55705 63532];%市区人数(万人)sqrs=[47.8 52.2 59 63.1 68.5 70 72 79.2 84.7 88.6 91 93 97.5 103.7 110 123 129.6 132 137.6 141 145 155.5 157 163.1 165.9];%市区机动车数(万辆)sqjdcs=[1.2 1.5 1.7 1.8 2.1 2.7 2.9 3.2 3.4 3.7 4.3 4.4 4.5 4.7 5 5.2 5.4 5.7 5.9 6.2 6.3 6.7 7.2 7.5 7.9];%市区公路面积(万平方公里)sqglmj=[0.2 0.25 0.25 0.3 0.45 0.5 0.5 0.7 0.7 0.75 0.8 0.8 0.85 1.1 1.25 1.3 1.3 1.5 1.55 1.75 1.8 1.8 2.05 2.1 2.3];这里是原始数据输入的矩阵bb=[sqrs;sqjdcs;sqglmj]&#x27;; %输入数据矩阵cc=[glkyl;glhyl]&#x27;; %输出数据矩阵 ycc是输出的结果 智能粒子群算法 求函数的极值，求最大值，好处是有动态变化图。 ### 智能粒子群算法使用方法 1234粒子群算法基本步骤1 找出待优化的目标函数2 设定种群规模大小（不会设置可直接采用下方代码的）3 替换掉下方公式即可 小波异常提取 提取异常值，找到异常值之后，画出图像，即可找到异常值 ### 小波异常提取使用方法 1将数值赋值给cuspamax，然后再直接执行程序 灰色关联分析 构建各个指标之间的关联度，找到谁与标准数据的关联度最大 ### 灰色关联分析使用方法 123456灰色关联分析步骤【1】确定比较对象（评价对象）(就是数据，并且需要进行规范化处理，就是标准化处理，见下面例题的表格数据)和参考数列（评价标准，一般该列数列都是1，就是最优的的情况） 【2】确定各个指标权重，可用层次分析确定 【3】计算灰色关联系数 【4】计算灰色加权关联度 【5】评价分析 小波特征提取 提取出一个图像中具有特征的部分 ### 小波特征提取使用方法 1直接执行代码 元胞自动机 元胞自动机（CA）是一种用来仿真局部规则和局部联系的方法。典型的元胞自动机是定义在网格上的，每一个点上的网格代表一个元胞与一种有限的状态。变化规则适用于每一个元胞并且同时进行。元胞的变化规则&amp;元胞状态典型的变化规则，决定于元胞的状态，以及其（ 4 或 8 ）邻居的状态。 元胞自动机的应用 元胞自动机已被应用于物理模拟，生物模拟等领域。 元胞自动机的matlab编程 结合以上，我们可以理解元胞自动机仿真需要理解三点。一是元胞，在matlab中可以理解为矩阵中的一点或多点组成的方形块，一般我们用矩阵中的一点代表一个元胞。二是变化规则，元胞的变化规则决定元胞下一刻的状态。三是元胞的状态，元胞的状态是自定义的，通常是对立的状态，比如生物的存活状态或死亡状态，红灯或绿灯，该点有障碍物或者没有障碍物等等。 元胞和规则才构成了元胞自动机，主要适用于模拟地震火灾等情况，因为一处着火，会引燃其他地方，等等，附和元胞自动机的条件 元胞之间通过物理规则来演变的，没有很复杂的函数，每一个元胞根据规则来判断周围环境，然后再去执行。 所以元胞自动机不存在复杂的公式，只存在各种各样的规则 红色代表的是活的，黑色代表的是死的，开始运行后，最后得到的稳定结果，就是火灾模拟后得到的结果 线性规划 视频来源： 老哥数学建模 因为matlab只能求解线性规划问题的最小值，所以，求最大值的时候，要在前面加一个负号 先来做一道例题 1234567&gt;&gt; f=[-2;-3;5];%因为题目给的是最大值，所以要变为负号&gt;&gt; a=[-2,5,-1;1,3,1];%标准形式小于等于，则将2，5，1换号&gt;&gt; b=[-10;12];%等式右侧值，因为要小于等于，10也换号&gt;&gt; aeq=[1,1,1];%等式约束，x1+x2+x3=7&gt;&gt; beq=7;%等式约束，x1+x2+x3=7&gt;&gt; [x,y]=linprog(f,a,b,aeq,beq,zeros(3,1));%zeros创建三行一列矩阵，表示x1，x2，x3的下限&gt;&gt; x,y=-y;%要求最大值，y加个负号 答案，解得 1234567891011x = 6.4286 0.5714 0&gt;&gt; y%y的数值要自己输入才能出来y = 14.5714 下面进行实际问题的解决 下面进行假设 线性规划模型使用方法 1234567线性规划步骤（1）定义决策变量（1）构造目标函数（2）寻找限制条件（4）按照步骤带入Matlab函数线性规划是linprog非线性规划是quadprog 整数规划 一般都是纯整数规划 整数规划一般用于指派、运输问题 一般会有一个关于产量的限制 图论算法 将顶点、边、行驶时间看作数学概念，就转化为旅行售货员的问题了 V(G)是图上的顶点E(G)是图上的边 一般见到的都是有限图 图的矩阵表示，如果两点相连就是1，不相连就是0，构建一个矩阵 有指向的图就是u1指向u2，矩阵才为1，否则为0 加权的就按照给的权重计算，如果没有指向的话，则是∞ 例：u2没有指向u1的线段，在矩阵中用无穷表示 关联矩阵，竖着写点，横着写线，如果之间相连了就是1，没有相连就是0 关联矩阵加上了方向，相连的正方向为1，反方向为-1 迹和简单链是点可以重合但是轨迹不能重合 二次指数平滑及时间序列预测使用方法 123function [Y,S1,S2,a,b] = expsmooth2(Yt,alpha,t)%Yt:原时间序列；alpha:平滑系数，一般都是0.5；t:预测时长%Y:预测值；S1/S2:一次/二次指数平滑值；a/b:预测公式参数 1填写好Yt，alpha还有t，然后执行expsmooth2就可以进行预测了 赛题思路解析学习 1.如何读懂题和定位题目 抓关键词 输入+条件+输出 分析题目之间的关系 按领域分类 按数学模型分类 机场要求保证短途载客车的出租车司机收益，建立模型 第一问建立出的模型，在第二问带入数据。用结果分析第一问的灵敏度 安全的条件指的是不拥挤，利用排队论，设置其变量，保证其达到“不拥挤”这一条件，并且建立评价模型。 2.三次思路法 第一次思路，根据知识储备和经验的基本思路，不要一开始就去读文献； 二次思路，查资料，得到基本可行的思路框架，画流程图/思维导图； 三次思路，找资料+开拓思路+进行取舍； 想一道题的时间不要花太多时间，不能有太多完美主义，把题都做完，心里面不会那么慌； 3.和队友出现分歧怎么办 分工很重要； 考虑完成度和表现形式； 实战——19C 第一问： 找数据 经济学模型 （航班数量的处理）聚类分析 第二问 ： 搜集机场数据 模型结果和实际结果做对比 灵敏度分析 第三问： 单od多目标优化模型 效率+加权评价 第四问： - 减少排队时间 - 再开一个车道或者不排队 - 经济上的直接补偿 每个模型必须要做灵敏度分析 关于如何做灵敏度分析：因为数据不是那么的准确，用控制变量的思想，横轴是你要变化的量，纵轴是要得出来的结果， 4.如何查找文献 学位论文选读有用的，论文直接从知网找就行。 找综述文章 论文该如何使用？ 找关键词和思路，再通过自己的经验化简模型； 模型如何突破思路？ 对数据的处理：异常、残缺，服从某种分布； 优化模型：目标函数、决策变量的巧妙切入； 分级评价-多级指标； 加权评判函数：不同的变量和权重（权重是自己来设计的）； 阈值-特殊情况； 特殊情况特殊分析； 完善模型 数据处理：异常残缺等； 模型的特殊情况：找到特殊值进行分析； 下面是建模的主要步骤 算出数据之后一定要给出结论 在亚太杯结束后，我会把个人的思路和解决方案放出 详细请见另一篇新的笔记","categories":[{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"学习笔记","slug":"MATLAB与数学建模/学习笔记","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"算法","slug":"算法","permalink":"https://mengfanjun020906.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Pytorch机器学习经典算法——线性回归","slug":"Pytorch机器学习经典算法——线性回归","date":"2022-10-06T02:03:23.000Z","updated":"2023-03-24T06:03:03.382Z","comments":true,"path":"2022/10/06/Pytorch机器学习经典算法——线性回归/","link":"","permalink":"https://mengfanjun020906.github.io/2022/10/06/Pytorch%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","excerpt":"","text":"原视频链接：3. 零基础入门PyTorch之线性回归【逐行代码讲解】 原文章链接：【PyTorch修炼】零基础入门PyTorch之线性回归【逐行代码讲解】 线性回归其实就是 y=kx+b 但是需要注意的是，这里所有的未知量都是一个矩阵而不是一个数，k是权重，b是偏差 要求： 数据都是tensor类型 如果有batch_size需要用dataloader去装这个数据 建立 model 完成训练过程 -&gt;进行前向传播 -&gt;利用loss反向传播 -&gt;优化器进行优化 用matlplotlib进行数据可视化 程序示例 导入库 123import torchimport torch.nn as nnimport matplotlib.pyplot as plt 写出函数并画图 1234567x=torch.linspace(0,20,500)#0-20之间取500个点k=3b=10y=k*x+bplt.scatter(x.data.numpy(),y.data.numpy())#因为torch的数据类型都是tensor，而plt只能画numpy数据结构的，所以需要写data.numpy()转换一下plt.show() 输出结果： 现在我们把写的函数都注释掉，来用机器学习拟合这条线 自己做一个数据集 1234567x=torch.rand(512)#随机在0-1之间有512个点noise=0.2*torch.randn(x.size())#加入高斯白噪声k=3b=10y=k*x+b+noiseplt.scatter(x.data.numpy(),y.data.numpy())plt.show() 输出结果： 构建神经网络 123456789class LinearModel(nn.Module): def __init__(self,in_fea,out_fea): super(LinearModel, self).__init__() self.output=nn.Linear(in_features=in_fea,out_features=out_fea) def forward(self,x): x=self.output(x) return xinput_x=torch.unsqueeze(x,dim=1)#因为我们输入的x是512个数，而不是512，所以需要转换维度input_y=torch.unsqueeze(y,dim=1) 构建损失函数和优化器 123model=LinearModel()loss_func=nn.MSELoss()#均方差求lossoptimizer=torch.optim.SGD(model.parameters(),lr=0.02)#随机梯度下降优化器 准备画图 1plt.ion()#打开交互模型 开始训练 12345678910111213141516for step in range(20): pred=model(input_x)#预测值 loss=loss_func(pred,input_y)#损失值 optimizer.zero_grad()#梯度归零 loss.backward()#反向传播 optimizer.step()#进行优化器训练 if step %10 ==0:#每十次移动一次 plt.cla()#清除上一次的 plt.scatter(input_x.data.numpy(),input_y.data.numpy()) plt.plot(input_x.data.numpy(),pred.data.numpy(),&#x27;r-&#x27;,lw=5)#画出预测的图像，线是红色，粗细是5 [w,b]=model.parameters() plt.text(0,0.5,&#x27;loss=%.4f,k=%.2f,b=%.2f&#x27;%(loss.item(),k.item(),b.item())) plt.pause(1)#每次停顿一下plt.ioff()#关闭实时显示plt.show() 输出结果： 可以看到红线正在逐渐拟合 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import torchimport torch.nn as nnimport matplotlib.pyplot as plt# x=torch.linspace(0,20,500)#0-20之间取500个点# k=3# b=10# y=k*x+b## plt.scatter(x.data.numpy(),y.data.numpy())#因为torch的数据类型都是tensor，而plt只能画numpy数据结构的，所以需要写data.numpy()转换一下# plt.show()x=torch.rand(512)#随机在0-1之间有512个点noise=0.2*torch.randn(x.size())#加入高斯白噪声k=3b=10y=k*x+b+noise# plt.scatter(x.data.numpy(),y.data.numpy())# plt.show()class LinearModel(nn.Module): def __init__(self,in_fea,out_fea): super(LinearModel, self).__init__() self.output=nn.Linear(in_features=in_fea,out_features=out_fea) def forward(self,x): x=self.output(x) return xinput_x=torch.unsqueeze(x,dim=1)#因为我们输入的x是512个数，而不是512，所以需要转换维度input_y=torch.unsqueeze(y,dim=1)model=LinearModel(1,1)loss_func=nn.MSELoss()#均方差求lossoptimizer=torch.optim.SGD(model.parameters(),lr=0.02)#随机梯度下降优化器plt.ion()#打开交互模型for step in range(200): pred=model(input_x) loss=loss_func(pred,input_y) optimizer.zero_grad()#梯度归零 loss.backward()#反向传播 optimizer.step() if step %10 ==0: plt.cla() plt.scatter(input_x.data.numpy(),input_y.data.numpy()) plt.plot(input_x.data.numpy(),pred.data.numpy(),&#x27;r-&#x27;,lw=5)#画出预测的图像，线是红色，粗细是5 plt.xlim(0, 1.1)#防止x文本消失 plt.ylim(0, 20) [w,b]=model.parameters() plt.text(0,0.5,&#x27;loss=%.4f,k=%.2f,b=%.2f&#x27;%(loss.item(),w.item(),b.item())) plt.pause(1)#每次停顿一下plt.ioff()plt.show()","categories":[{"name":"Pytorch学习","slug":"Pytorch学习","permalink":"https://mengfanjun020906.github.io/categories/Pytorch%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://mengfanjun020906.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"上位机用串口对STM32F1单片机一对二下载与通信","slug":"上位机用串口对STM32F1单片机一对二下载与通信","date":"2022-10-03T12:29:51.000Z","updated":"2023-03-24T05:24:00.043Z","comments":true,"path":"2022/10/03/上位机用串口对STM32F1单片机一对二下载与通信/","link":"","permalink":"https://mengfanjun020906.github.io/2022/10/03/%E4%B8%8A%E4%BD%8D%E6%9C%BA%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%AF%B9STM32F1%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%80%E5%AF%B9%E4%BA%8C%E4%B8%8B%E8%BD%BD%E4%B8%8E%E9%80%9A%E4%BF%A1/","excerpt":"","text":"问题 最近一直在做一个项目，发现STM32的定时器不太够。 正好我们上课在学STM32F103RCT6，就想利用两个芯片做项目。 那么问题来了：怎么用一个上位机给两个单片机下载程序和通信呢？ 解决方案 结果学长设计了一个电路： 感觉其中的OE很有玄机，于是去查了查这个芯片的芯片手册，看到了这句话 上面的意思大概就是：如果将OE置为低电平，那么芯片的其他脚将变成高阻态。 再看看上面的电路 如果UART CS为高，那么就是给单片机B下载 如果UART CS为低，那么就是给单片机A下载 但只有这个还不够，STM32还有BOOT电路，BOOT电路在这里就不详细说了。 关于这一点，我们是这么设计的电路： 通过ISP A和ISP B来对单片机A和单片机B的BOOT电路进行控制，但由于这是一个MOS管的开漏电路，如果给ISP A为1那么输出会变成0，需要注意这一点。如果ISP A和ISP B设置的不对的话，程序可以下载进去，但是就是没有反应。 于是，我们得到了这个表 后来进行了测试 成功出现了B的数据！ 这时为ISP A和ISP B都为高，再将UART CS置低，就会出现A的串口输出，不需要将串口关闭。 这样就实现了上位机一对二对单片机进行下载与串口接收。 总结 之前在打第一版板子之前老师和我们说，这个方法太笨了，不如用CAN，但是我们还是想试一下，结果居然成功了，之前BOOT电路那里一直忘了改，导致一直出现各种奇怪的问题。 芯片其实就是个电平转换芯片，没想到居然还能有这样的作用，不得不说还是学长更聪明啊。","categories":[],"tags":[{"name":"stm32","slug":"stm32","permalink":"https://mengfanjun020906.github.io/tags/stm32/"},{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"}]},{"title":"如何阅读芯片手册","slug":"如何阅读芯片手册","date":"2022-09-26T00:22:15.000Z","updated":"2023-03-24T05:22:56.349Z","comments":true,"path":"2022/09/26/如何阅读芯片手册/","link":"","permalink":"https://mengfanjun020906.github.io/2022/09/26/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%8A%AF%E7%89%87%E6%89%8B%E5%86%8C/","excerpt":"","text":"原视频链接：如何快速阅读芯片数据手册（初学者和外行进） ## 1.芯片手册的结构 ### 1.Features 特性 对芯片的特点进行了总结 ### 2.General Description 概述 把芯片的功能进行了一个大概的总结，这部分对新手来说很重要，每一个不懂的单词都要弄明白 ### 3.Absolute Max Ratings 损坏指标 在用芯片时，不能超过的的电压以及温度等 ### 4.Specifications 指标 同上 ### 5.Pin Configuration 引脚分配 画原理图时需要仔细阅读，查三遍 ### 6.内部寄存器或协议说明 ### 7.Application Information 应用信息 非常重要的内容 ### 8.Package &amp; Order Information 封装和订购信息 可以用来画PCB的封装 例：MIC5219我们最近在画的一款芯片 可以根据物理信息图来设计焊盘的大小等参数，一般焊盘要比实际物理尺寸大一点 12345总结：如果在学习阶段，一定要精读1和2如果是要器件选型，要精读1,4,8如果要进行电路设计，要精读5,7,8如果进行程序设计，要读6如果进行机械设计，要读8","categories":[],"tags":[{"name":"pcb工艺","slug":"pcb工艺","permalink":"https://mengfanjun020906.github.io/tags/pcb%E5%B7%A5%E8%89%BA/"}]},{"title":"解决Mingw-w64下载太慢问题","slug":"解决Mingw-w64下载太慢问题","date":"2022-08-30T08:17:47.000Z","updated":"2023-03-24T01:09:22.454Z","comments":true,"path":"2022/08/30/解决Mingw-w64下载太慢问题/","link":"","permalink":"https://mengfanjun020906.github.io/2022/08/30/%E8%A7%A3%E5%86%B3Mingw-w64%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2%E9%97%AE%E9%A2%98/","excerpt":"","text":"官网下载太慢了，我们只用换一个镜像源就可以 1.点击Problems Downloading? 2.切换香港的","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://mengfanjun020906.github.io/tags/vscode/"}]},{"title":"pip install清华镜像源","slug":"pip install清华镜像源","date":"2022-08-26T02:19:31.000Z","updated":"2022-12-05T05:36:50.309Z","comments":true,"path":"2022/08/26/pip install清华镜像源/","link":"","permalink":"https://mengfanjun020906.github.io/2022/08/26/pip%20install%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E6%BA%90/","excerpt":"","text":"1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xxx 使用方法： 1.将这段话复制到你虚拟环境下 2.将xxx改成你需要的包的名字 3.按Enter","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://mengfanjun020906.github.io/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"pip","slug":"pip","permalink":"https://mengfanjun020906.github.io/tags/pip/"}]},{"title":"Python中a, b = b, a + b的含义","slug":"Python中a, b = b, a + b的含义","date":"2022-08-23T11:30:28.000Z","updated":"2022-12-05T05:38:23.108Z","comments":true,"path":"2022/08/23/Python中a, b = b, a + b的含义/","link":"","permalink":"https://mengfanjun020906.github.io/2022/08/23/Python%E4%B8%ADa,%20b%20=%20b,%20a%20+%20b%E7%9A%84%E5%90%AB%E4%B9%89/","excerpt":"","text":"现在在学Python的基础，看了一道斐波那契数列的练习题，看到了如下结构 12345a = 0b = 1for _ in range(20): # _表示占位符 a, b = b, a + b print(a, end=&#x27; &#x27;)#end=&#x27; &#x27;表示关闭自动换行 循环里面的那一行就是看不懂，后来自己去查了查资料，才明白 1.计算=右边的a+b 2.a=b 3.b=a+b 顺序其实就是这样的，那么上面程序运行的结果就是 11 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 解释：第一轮a=0,b=1,先进行了等号右边的计算a+b=1,赋值之后，a=b=1,b=a+b=1。 第二轮a=1,b=1,先进行了等号右边的计算a+b=2,赋值之后，a=b=1,b=a+b=2。 第三轮a=1,b=2,先进行了等号右边的计算a+b=2,赋值之后，a=b=2,b=a+b=3。 以此类推，后面的结果就出来了","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://mengfanjun020906.github.io/tags/python/"}]},{"title":"蓝桥杯单片机常用模块(自用)","slug":"蓝桥杯单片机常用模块(自用)","date":"2022-08-14T01:32:48.000Z","updated":"2023-03-24T01:09:38.160Z","comments":true,"path":"2022/08/14/蓝桥杯单片机常用模块(自用)/","link":"","permalink":"https://mengfanjun020906.github.io/2022/08/14/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97(%E8%87%AA%E7%94%A8)/","excerpt":"","text":"关于我写的程序啥都不是还有脸上传的事 之前一直在用txt记笔记，但是后来因为代码太多了，所以想到了记到csdn上 下面是正文，无顺序，想到哪写到哪。 一些基础的 -在138译码器中，前3位代表5 6 7 P2=0xA0对应着1010 0000，则5 6 7为101，为1111 1011，Y5为0，则配置的是Y5C，控制P00-P07 P2=0x80对应着1000 0000，则5 6 7为100 为1111 0111，Y4为0，对应Y4C，这个是led灯 P2=0xC0对应着1100 0000，则5 6 7为110 为1111 1101，Y6为0，对应Y6C，这是打开数码管的片选端（控制是第几个显示）,后面写P0为什么表示选哪几个，例：0x80就是1000 0000，第一个显示，也可以写为P2=(P2&amp;0X1f)|0X80，0x80前面那个表示将P2.0-P2.4置为0 P2=0xE0对应着 1110 1111，则5 6 7位111为1111 1110，Y7为0，对应Y7C，这个是打开数码管的数据端（控制是显示什么数字） sfr是定义特殊功能寄存器，单片机里面，共有两种寄存器，第一种是ROM，第二种是RAM。 1 ROM的功能：ROM的数据在程序运行的时候是不容改变的，除非你再次烧写程序，他就会改变，就像我们的书本，印上去就改不了了，除非再次印刷，这个就是ROM的原理。 2 RAM的功能：RAM就是在程序运行中，数据会随时改变的，就像我们的黑板，写上了可以擦，擦完再写上去，相当于程序运行的时候，调用ROM里面的数据进行各种运算。 共阳极数码管数据表： 12unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff&#125;;//0-9,第10个是-，11是全灭unsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1&#125;;//A,b,C,d,E,F,H,L,P,U 常用字母段码表 数码管片选位置表（从左到右0-7）： 1unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;; 数码管调用函数，前面是位置，后面是显示的东西，分为shuzi和zimu两种 12345678910111213141516171819202122void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125;void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125; 配置所有引脚 1234567891011121314151617void allinit()&#123; P2=(P2&amp;0x1f)|0x80; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xA0; P0 = P0 &amp; 0XAF; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xc0; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xe0; P0=0xFF; P2&amp;=0x1f;&#125; LED灯单独亮选择 1234567unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125; 定时器 定时器0，设置1s： 123456789void Init_timer0() &#123; TMOD = 0x01; TH0 = (65535 - 50000) / 256; //50000微秒 TL0 = (65535 - 50000) % 256; EA = 1; ET0 = 1; TR0 = 1; &#125; 下面是以时钟为例，写执行的内容 1234567891011121314151617181920212223void Service_timer0() interrupt 1&#123; TH0 = (65535 - 50000) / 256; TL0 = (65535 - 50000) % 256; count++; if(count == 20) //20*50ms为1s &#123; second++; count = 0; &#125; if(second == 60) &#123; minute++; second=0; &#125; if(minute==60) &#123; hour++; minute=0; if(hour==24) hour=0; &#125; &#125; 矩阵按键 定义引脚 123456789sbit R1=P3^0;//第一排初始化（如果跳线帽在右边，则只有最左侧一列可以控制，写这个没问题）sbit R2=P3^1;//第二排初始化sbit R3=P3^2;//第三排初始化sbit R4=P3^3;//第四排初始化sbit C1=P3^4;//第一列初始化（此为从右往左数）sbit C2=P3^5;//第二列初始化sbit C3=P4^2;//第三列初始化sbit C4=P4^4;//第四列初始化 初始化矩阵键盘 123456void Init()//初始化矩阵键盘&#123; R1=R2=R3=R4=1; C1=C2=C3=C4=1;&#125; DS18B20配置 首先是看原理图，找到DQ，连接着P14 所以先定义好DQ 123456789sbit DQ=P1^4;void dsinit()&#123; DQ=0; Delay500us(); DQ=1; Delay500us();&#125; 温度获取： 12345678910111213141516171819202122void temperature_get()&#123; uchar high,low; init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0x44); init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=((high&lt;&lt;4)|(low&gt;&gt;4));//不带小数点 temp2=low&amp;0x0f*100/16;//取两位小数点 shi=temp%100/10; ge=temp%10; //int temp;uchar shi;uchar ge;int temp2;都是全局的&#125; 防抖 按下按键，语句只执行一次： 这里以R1为例 123456789if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; //执行语句 while(R1==0); &#125; &#125; 下面是一堆delay函数 有不同时间的，应该好用，我自己试过了 1234567891011121314151617181920212223242526272829303132void Delay100us() //@12.000MHz&#123; unsigned char i, j; i = 2; j = 39; do &#123; while (--j); &#125; while (--i);&#125;void Delay500us() //@12.000MHz&#123; unsigned char i, j; i = 6; j = 211; do &#123; while (--j); &#125; while (--i);&#125;void delay_ms(unsigned int n)&#123; unsigned int i=0,j=0; for(i=0;i&lt;n;i++) for(j=0;j&lt;123;j++);&#125; nop()的意思是一条空语句，用来延时 PCF8591 本来上课讲了，但是我一点也没听，看了这篇文章之后，就懂了，可以说是写的真好 关于iic与pcf8591 步骤：开启总线-----发送地址+写-----发送控制字节-----等待PCF8591响应-----停止总线-----重新启动总线-----发送地址+读------读取数据-----主机发送非应答信号-----停止总线 PCF8591的设备地址包括固定部分和可编程部分。可编程部分需要根据硬件引脚A0、A1和A2来设置。设备地址的最后一位用于设置数据传输的方向，即读/写位，在IIC总线协议中，设备地址是起始信号后第一个发送的字节。如果硬件地址引脚A0、A1、A2均接地，那么，PCF8591的设备的读操作地址为：0x91；而写操作地址则为：0x90。读是1，写是0 光敏传感器接到AIN1，通道1；控制寄存器应写入：0x01。 电位器Rb2接到AIN3，通道3；控制寄存器应写入：0x03。 12345678910111213141516171819202122232425262728//ADC转换，可以带入数值unsigned char ad(unsigned int voltage)&#123; uint temp; uint v; int flag; IIC_Start(); IIC_SendByte(0x90); //写操作 flag=IIC_WaitAck(); //等待应答，判断对方发送的是0还是1，从而执行下一步 if(flag) return 0; IIC_SendByte(0x40); flag=IIC_WaitAck(); if(flag) return 0; IIC_SendByte(voltage_1); flag=IIC_WaitAck(); if(flag) return 0; IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); //读操作 flag=IIC_WaitAck(); if(flag) return 0; temp= IIC_RecByte(); IIC_SendAck(1); IIC_Stop();&#125; 读取电压，5v电压 1234567891011121314151617181920212223242526void Read_AIN3()&#123; int voltage; int dat; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(0x03);//读取的Rb2电位器，通道三，要是0x01就是光敏电阻 IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); dat = IIC_RecByte(); IIC_WaitAck(); IIC_Stop(); voltage=dat*100/51; shumaguan_shuzi(6,voltage%100/10); shumaguan_shuzi(7,voltage%10); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[5]; P2=(P2&amp;0X1f)|0xFF;P0=shuzi[voltage/100]+0x80; &#125; 三位数显示在数码管上： 百位：dat / 100 十位：(dat % 100) / 10 个位：dat % 10 下面是转载隔壁宿舍大佬的代码，一个函数实现ADC和DAC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void adc_read(unsigned char ain)//在ain这里写0x01和0x03使用光敏电阻和电位器&#123; EA = 0; IIC_Start(); IIC_SendByte(0x90); if(!IIC_WaitAck()) &#123; IIC_SendByte(ain); if(!IIC_WaitAck()) &#123; IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); if(!IIC_WaitAck()) &#123; addata = IIC_RecByte(); IIC_SendAck(0); vi=(addata*100)/51; v1=vi%1000/100; v2=vi%100/10; v3=vi%10; IIC_Stop(); &#125; &#125; &#125; EA = 1;&#125;void dac_write(float dat)&#123; int dat_2; dat_2 = dat*100*255/500; EA=0; IIC_Start(); IIC_SendByte(0X90); if(!IIC_WaitAck()) &#123; IIC_SendByte(0X40); if(!IIC_WaitAck()) &#123; IIC_SendByte(dat_2); if(!IIC_WaitAck()) &#123; IIC_Stop(); &#125; &#125; &#125; EA=1;&#125; 读写eeprom的函数 在write_eeprom和read_eeprom时一定要中间写一个delay，要不然数据读不进去 12345678910111213141516171819202122232425262728293031void write_eeprom(unsigned char add,unsigned char date)//写入eeprom数据，前面是地址，后面是数据&#123; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_SendByte(date); IIC_WaitAck(); IIC_Stop();&#125;unsigned char read_eeprom(unsigned char add)//读eeprom的数据，括号里面写地址&#123; unsigned char temp; EA = 0; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Start(); IIC_SendByte(0xa1); IIC_WaitAck(); temp = IIC_RecByte(); IIC_SendAck(1); IIC_WaitAck(); IIC_Stop(); EA = 1; return temp;&#125; NE555 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051unsigned int count_f = 0;unsigned char count_t = 0;unsigned int dat_f = 0;void Init_Timer()&#123; TH0 = 0xff; TL0 = 0xff; TH1 = (65536 - 50000) / 256; TL1 = (65536 - 50000) % 256; TMOD = 0x16; ET0 = 1; ET1 = 1; EA = 1; TR0 = 1; TR1 = 1;&#125; void Service_T0() interrupt 1&#123; count_f++;&#125; void Service_T1() interrupt 3&#123; TH1 = (65536 - 50000) / 256; TL1 = (65536 - 50000) % 256; count_t++; if(count_t == 20) &#123; dat_f = count_f; count_f = 0; count_t = 0; &#125;&#125;void display_f()&#123; shumaguan_zimu(0,5); if(dat_f&gt;9999) shumaguan_shuzi(3,dat_f/10000); if(dat_f&gt;999) shumaguan_shuzi(4,dat_f/1000%10); if(dat_f&gt;99) shumaguan_shuzi(5,dat_f/100%10); if(dat_f&gt;9) shumaguan_shuzi(6,dat_f/10%10); shumaguan_shuzi(7,dat_f%10); &#125; 以1s间隔闪烁一次，以第八届省赛的题目为例，要求每隔1s闪烁一次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void Init_timer0()//定时器配置 &#123; TMOD = 0x01; TH0 = (65535 - 50000) / 256; //50ms技术 TL0 = (65535 - 50000) % 256; EA = 1; ET0 = 1; TR0 = 1; &#125;void Service_timer0() interrupt 1//定时器0，中断&#123; count_b++;//全局变量 if(count_b==20)//计算了1s &#123; count_b=0; if(mode_smg==0)//mode_smg也是全局变量 &#123; mode_smg=1; &#125; else if(mode_smg==1) &#123; mode_smg=0; &#125; &#125;&#125;void hour_blink()//显示小时以1s的间隔显示一次&#123; if(mode_smg==1) &#123; shumaguan_shuzi(0,hour_p/10); shumaguan_shuzi(1,hour_p%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_p/10); shumaguan_shuzi(4,minute_p%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_p/10); shumaguan_shuzi(7,second_p%10); &#125; if(mode_smg==0) &#123; shumaguan_shuzi(0,11); shumaguan_shuzi(1,11); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_p/10); shumaguan_shuzi(4,minute_p%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_p/10); shumaguan_shuzi(7,second_p%10); &#125;&#125; 先写这么多，想到了继续补","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"蓝桥杯单片机学习","slug":"学习笔记/蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"基于Pytorch完整的训练一个神经网络(CIFAR10)并进行验证","slug":"基于Pytorch完整的训练一个神经网络(CIFAR10)并进行验证","date":"2022-07-20T08:48:01.000Z","updated":"2023-03-24T01:09:09.855Z","comments":true,"path":"2022/07/20/基于Pytorch完整的训练一个神经网络(CIFAR10)并进行验证/","link":"","permalink":"https://mengfanjun020906.github.io/2022/07/20/%E5%9F%BA%E4%BA%8EPytorch%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CIFAR10)%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81/","excerpt":"","text":"原视频链接：Pytorch深度学习快速入门教程（绝对通俗易懂!)【小土堆】 土堆老师的Github地址 之前学的也不少了，现在要去训练一个完整的神经网络，利用Pytorch和CIFAR10数据集 准备数据集 123456import torchvision#导入torchvision##准备数据集train_data=torchvision.datasets.CIFAR10(root=&quot;../data&quot;,train=True,transform=torchvision.transforms.ToTensor(), download=True)##数据集的目录，是否训练，将PIL型变为Tensor型，需要下载test_data=torchvision.datasets.CIFAR10(root=&quot;../data&quot;,train=False,transform=torchvision.transforms.ToTensor(), download=True) ### 测试数据集长度 123456#length 长度train_data_size=len(train_data)test_data_size=len(test_data)#如果train_data_size为10，训练集的长度为:10print(&quot;训练数据集长度为：&#123;&#125;&quot;.format(train_data_size))#&#123;&#125;,会被替换为后面的值，把他变成字符串了print(&quot;测试数据集长度为：&#123;&#125;&quot;.format(test_data_size))#&#123;&#125;,会被替换为后面的值，把他变成字符串了 输出结果 1234Files already downloaded and verifiedFiles already downloaded and verified训练数据集长度为：50000测试数据集长度为：10000 ### 用DataLoader加载数据 123#利用dataloader来加载数据集train_dataloader=DataLoader(train_data,batch_size=64)#一次训练所抓取的数据样本数量为64test_dataloader=DataLoader(test_data,batch_size=64) 搭建神经网络 这是CIFAR10 model的结构 123456789101112131415161718class NetWork(nn.Module): def __init__(self): super(NetWork, self).__init__() self.model=nn.Sequential( nn.Conv2d(3,32,5,1,2), nn.MaxPool2d(2), nn.Conv2d(32,32,5,1,2), nn.MaxPool2d(2), nn.Conv2d(32,64,5,1,2), nn.MaxPool2d(2), nn.Flatten(), nn.Linear(64*4*4,64), nn.Linear(64,10) )#在序列中去填网络结构 def forward(self,x): x=self.model(x) return x 将此程序放入另一个新创建的python文件中，注意在同一个文件夹下 12345678910111213141516171819202122232425262728from torch import nnimport torchclass NetWork(nn.Module): def __init__(self): super(NetWork, self).__init__() self.model=nn.Sequential( nn.Conv2d(3,32,5,1,2), nn.MaxPool2d(2), nn.Conv2d(32,32,5,1,2), nn.MaxPool2d(2), nn.Conv2d(32,64,5,1,2), nn.MaxPool2d(2), nn.Flatten(), nn.Linear(64*4*4,64), nn.Linear(64,10) )#在序列中去填网络结构 def forward(self,x): x=self.model(x) return xif __name__ == &#x27;__main__&#x27;: network=NetWork() input=torch.ones((64,3,32,32)) output=network(input) print(output.shape) 输出结果： 1torch.Size([64, 10]) 输出了64行，每一行上有10个数据，10代表了我们每一张图片在我们十个类别中的概率 ### 创建损失函数 1loss_fn=nn.CrossEntropyLoss()#交叉熵 创建优化器 12learning_rate=0.01#学习速率optimizer=torch.optim.SGD(network.parameters(),lr=learning_rate)#随机梯度下降,先填网络模型，然后是学习速率 开始训练 12345678910111213141516171819202122#设置训练网络的一些参数total_train_step=0#记录训练次数#记录测试的次数total_test_step=0#训练的轮数epoch=10for i in range(epoch): print(&quot;----------------第&#123;&#125;轮训练开始-------------&quot;.format(i+1)) #训练步骤开始 for data in train_dataloader: imgs,targets=data outputs=network(imgs) loss=loss_fn(outputs,targets) #优化器优化模型 optimizer.zero_grad()#优化器梯度清零 loss.backward()#反向传播 optimizer.step()#优化器进行优化 total_train_step=total_train_step+1 #记录训练次数 print(&quot;训练次数：&#123;&#125;,Loss:&#123;&#125;&quot;.format(total_train_step,loss.item())) 输出结果 123456789101112131415Files already downloaded and verifiedFiles already downloaded and verified训练数据集长度为：50000测试数据集长度为：10000----------------第1轮训练开始-------------训练次数：1,Loss:2.31258487701416训练次数：2,Loss:2.312842607498169训练次数：3,Loss:2.302748918533325训练次数：4,Loss:2.3247387409210205训练次数：5,Loss:2.307778835296631训练次数：6,Loss:2.311138868331909训练次数：7,Loss:2.290013551712036训练次数：8,Loss:2.302402973175049训练次数：9,Loss:2.293430805206299训练次数：10,Loss:2.2981677055358887 这里如果不停止会一直输出，所以，我们要把训练过程改善一下 123456789101112for data in train_dataloader: imgs,targets=data outputs=network(imgs) loss=loss_fn(outputs,targets) #优化器优化模型 optimizer.zero_grad()#优化器梯度清零 loss.backward()#反向传播 optimizer.step()#优化器进行优化 total_train_step=total_train_step+1 #记录训练次数 if total_train_step %100==0:#每100次才打印 print(&quot;训练次数：&#123;&#125;,Loss:&#123;&#125;&quot;.format(total_train_step,loss.item())) 每100次才打印数据 ### 开始测试步骤 训练完毕之后，我们接下来采用测试数据进行测试 12345678total_test_loss=0 with torch.no_grad(): for data in test_dataloader: imgs,targets =data outputs =network(imgs)#输入放到网络当中我们可以得到对应输出 loss =loss_fn(outputs,targets)#计算误差 total_test_loss=total_test_loss+loss.item() print(&quot;整体测试集上的Loss:&#123;&#125;&quot;.format(total_test_loss)) 输出结果 123456789101112131415Files already downloaded and verifiedFiles already downloaded and verified训练数据集长度为：50000测试数据集长度为：10000----------------第1轮训练开始-------------训练次数：100,Loss:2.2861547470092773训练次数：200,Loss:2.273378372192383训练次数：300,Loss:2.238002300262451训练次数：400,Loss:2.1429920196533203训练次数：500,Loss:2.050020694732666训练次数：600,Loss:2.005511522293091训练次数：700,Loss:2.015151262283325整体测试集上的Loss:314.1541121006012----------------第2轮训练开始-------------训练次数：800,Loss:1.8569183349609375 训练结果可视化 为了使得我们可以清晰地看到训练结果，我们用Tensorboard把他画出来 需要在训练步骤和测试步骤里面加上一句代码 开头启用Tensorboard 1writer=SummaryWriter(&quot;logs_train&quot;) 训练步骤下 1234if total_train_step %100==0:#每100次才打印 print(&quot;训练次数：&#123;&#125;,Loss:&#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step)##标题，loss值，训练次数 writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step)##标题，loss值，训练次数 测试步骤下 12writer.add_scalar(&quot;test_loss&quot;,total_test_loss,total_test_step)##标题，测试误差值，测试次数total_test_step=total_test_step+1 最后加上 1writer.close() 在Terminal中加上启动tensorboard的代码，要在pytorch的环境下 1tensorboard --logdir=logs_train 打开连接后，画出的图像如下 输出结果 train_loss test_loss loss一直在下降，证明训练有一定效果 拓展 二分类问题求准确率 先来了解一个函数叫做Argmax() 1234import torchoutputs=torch.Tensor([[0.1,0.2], [0.3,0.4]])print(outputs.argmax(1))#1表示横向,0表示纵向比较 输出结果 1tensor([1, 1]) 表示在横向上，0.2比0.1大，为1,0.4比0.3大，也为1，如果将argmax换成0 1234import torchoutputs=torch.Tensor([[0.1,0.2], [0.05,0.4]])print(outputs.argmax(0))#1表示横向,0表示纵向比较 输出结果 1tensor([0, 1]) 在纵向上，0.05比0.1小，所以是0，另一纵向同理 再将其与真实结果比较，计算其总和 12345678import torchoutputs=torch.Tensor([[0.1,0.2], [0.05,0.4]])print(outputs.argmax(0))#1表示横向,0表示纵向比较preds=outputs.argmax(1)targets =torch.Tensor([0,1])print((preds==targets).sum()) 输出结果 12tensor([1, 1])tensor(1) 测试模型的准确率 通过以上的内容，我们可以优化我们的模型，计算其准确率 123456789101112131415total_test_loss=0 total_accuracy=0#整体正确率 with torch.no_grad(): for data in test_dataloader: imgs,targets =data outputs =network(imgs)#输入放到网络当中我们可以得到对应输出 loss =loss_fn(outputs,targets)#计算误差 total_test_loss=total_test_loss+loss.item() accuracy=(outputs.argmax(1)==targets).sum()#横向准确率 total_accuracy=total_accuracy+accuracy print(&quot;整体测试集上的Loss:&#123;&#125;&quot;.format(total_test_loss)) print(&quot;整体测试集上的正确率:&#123;&#125;&quot;.format(total_accuracy/test_data_size)) writer.add_scalar(&quot;test_loss&quot;,total_test_loss,total_test_step)##标题，测试误差值，测试次数 writer.add_scalar(&quot;test_accuracy&quot;,total_accuracy/test_data_size,total_test_step) total_test_step=total_test_step+1 输出结果 12345678910----------------第1轮训练开始-------------训练次数：100,Loss:2.2833285331726074训练次数：200,Loss:2.2706451416015625训练次数：300,Loss:2.203575849533081训练次数：400,Loss:2.102896213531494训练次数：500,Loss:2.012601852416992训练次数：600,Loss:2.006645441055298训练次数：700,Loss:1.9837690591812134整体测试集上的Loss:309.36241841316223整体测试集上的正确率:0.2946999967098236 在Tensorboard中显示 准确率是在上升的 以上就是训练一个完整的模型的步骤了 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#######################一个完整的神经网络 准备数据，加载数据，准备模型，设置损失函数，设置优化器，开始训练，最后验证，结果聚合展示import torchvisionfrom torch import nnfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterfrom model import *#引入model中的所有import##准备数据集train_data=torchvision.datasets.CIFAR10(root=&quot;../data&quot;,train=True,transform=torchvision.transforms.ToTensor(), download=True)##数据集的目录，是否训练，将PIL型变为Tensor型，需要下载test_data=torchvision.datasets.CIFAR10(root=&quot;../data&quot;,train=False,transform=torchvision.transforms.ToTensor(), download=True)#length 长度train_data_size=len(train_data)test_data_size=len(test_data)#如果train_data_size为10，训练集的长度为:10print(&quot;训练数据集长度为：&#123;&#125;&quot;.format(train_data_size))#&#123;&#125;,会被替换为后面的值，把他变成字符串了print(&quot;测试数据集长度为：&#123;&#125;&quot;.format(test_data_size))#&#123;&#125;,会被替换为后面的值，把他变成字符串了#利用dataloader来加载数据集train_dataloader=DataLoader(train_data,batch_size=64)#一次训练所抓取的数据样本数量为64test_dataloader=DataLoader(test_data,batch_size=64)#创建网络模型network=NetWork()#损失函数loss_fn=nn.CrossEntropyLoss()#交叉熵#优化器learning_rate=0.01#学习速率optimizer=torch.optim.SGD(network.parameters(),lr=learning_rate)#随机梯度下降,先填网络模型，然后是学习速率#设置训练网络的一些参数total_train_step=0#记录训练次数#记录测试的次数total_test_step=0#训练的轮数epoch=10#添加tensorboardwriter=SummaryWriter(&quot;logs_train&quot;)for i in range(epoch): print(&quot;----------------第&#123;&#125;轮训练开始-------------&quot;.format(i+1)) #训练步骤开始 network.train() for data in train_dataloader: imgs,targets=data outputs=network(imgs) loss=loss_fn(outputs,targets) #优化器优化模型 optimizer.zero_grad()#优化器梯度清零 loss.backward()#反向传播 optimizer.step()#优化器进行优化 total_train_step=total_train_step+1 #记录训练次数 if total_train_step %100==0:#每100次才打印 print(&quot;训练次数：&#123;&#125;,Loss:&#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step)##标题，loss值，训练次数 #测试步骤开始 network.eval() total_test_loss=0 total_accuracy=0#整体正确率 with torch.no_grad():#网络模型没有梯度，不需要梯度优化 for data in test_dataloader: imgs,targets =data outputs =network(imgs)#输入放到网络当中我们可以得到对应输出 loss =loss_fn(outputs,targets)#计算误差 total_test_loss=total_test_loss+loss.item() accuracy=(outputs.argmax(1)==targets).sum()#横向准确率 total_accuracy=total_accuracy+accuracy print(&quot;整体测试集上的Loss:&#123;&#125;&quot;.format(total_test_loss)) print(&quot;整体测试集上的正确率:&#123;&#125;&quot;.format(total_accuracy/test_data_size)) writer.add_scalar(&quot;test_loss&quot;,total_test_loss,total_test_step)##标题，测试误差值，测试次数 writer.add_scalar(&quot;test_accuracy&quot;,total_accuracy/test_data_size,total_test_step) total_test_step=total_test_step+1 torch.save(network,&quot;network_&#123;&#125;.pth&quot;.format(i))#保存每一轮的训练结果 print(&quot;模型已保存&quot;)writer.close() 利用GPU去训练神经网络 只需要稍作改动 1234#创建网络模型network=NetWork()if torch.cuda.is_available(): network=network.cuda()#利用gpu进行训练 损失函数改成cuda 123#损失函数loss_fn=nn.CrossEntropyLoss()#交叉熵loss_fn=loss_fn.cuda()#利用gpu训练 在训练和测试那里，吧imgs和targets改成cuda就OK了 12imgs=imgs.cuda()targets=targets.cuda() 跟CPU跑的比较了下，CPU跑100轮用了4.9s，GPU用了3.2s，确实会快 验证网络模型 万事俱备只欠东风，现在我们可以去拿训练好的网络去预测一只狗狗了， 首先从网上找一个狗狗的照片，这里就不展示了 将狗狗的照片放入你的Pytorch文件夹下，然后就可以编写代码了 1234567891011121314151617181920212223242526272829303132333435363738394041import torchimport torchvision.transformsfrom PIL import Imagefrom torch import nnimage_path=&quot;你的狗狗照片的绝对路径&quot;image=Image.open(image_path)image=image.convert(&#x27;RGB&#x27;)#保持其颜色通道transform=torchvision.transforms.Compose([torchvision.transforms.Resize((32,32)), torchvision.transforms.ToTensor()])## 将输入图片resize成统一尺寸，# 将PIL Image或numpy.ndarray转换为tensor，并归一化到[0,1]之间image=transform(image)class NetWork(nn.Module): def __init__(self): super(NetWork, self).__init__() self.model=nn.Sequential( nn.Conv2d(3,32,5,1,2), nn.MaxPool2d(2), nn.Conv2d(32,32,5,1,2), nn.MaxPool2d(2), nn.Conv2d(32,64,5,1,2), nn.MaxPool2d(2), nn.Flatten(), nn.Linear(64*4*4,64), nn.Linear(64,10) )#在序列中去填网络结构 def forward(self,x): x=self.model(x) return xmodel=torch.load(&quot;network_gpu_9.pth&quot;,map_location=torch.device(&#x27;cpu&#x27;))#保存模型,从gpu映射到cpu上，读取之前训练好的模型，我用的是训练10轮的image=torch.reshape(image,(1,3,32,32))#batch_size,3个颜色通道 32*32model.eval()with torch.no_grad(): output=model(image)print(output)print(output.argmax(1)) 输出结果 123tensor([[-0.5509, -0.1295, 1.7645, 3.3668, -3.0762, 4.5566, 3.2504, 0.9605, -6.5720, -1.3539]])tensor([5]) 对照表格，我们可以发现，经过训练，电脑大概知道了狗狗的样子","categories":[{"name":"Pytorch学习","slug":"Pytorch学习","permalink":"https://mengfanjun020906.github.io/categories/Pytorch%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"神经网络","slug":"神经网络","permalink":"https://mengfanjun020906.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Pytorch机器学习经典算法——逻辑回归","slug":"Pytorch机器学习经典算法——逻辑回归","date":"2022-07-08T07:49:18.000Z","updated":"2022-12-05T05:35:40.560Z","comments":true,"path":"2022/07/08/Pytorch机器学习经典算法——逻辑回归/","link":"","permalink":"https://mengfanjun020906.github.io/2022/07/08/Pytorch%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/","excerpt":"","text":"原视频地址 导入基本库 12345import torchimport torch.nn as nnfrom sklearn import datasetsfrom sklearn.preprocessing import StandardScaler#缩放特征from sklearn.model_selection import train_test_split#分离测试与训练数据 导入乳腺癌数据集 打印出数据集的样本值和特征值 1234bc=datasets.load_breast_cancer()X,y=bc.data,bc.target#X是基本数据，y是已知结果n_samples,n_features=X.shape#X的样本值和特征值print(n_samples,n_features) 输出结果 1569 30 569个样本和30个特征 ### 对导入的数据进行处理 12345678910111213X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2,random_state=1234)#放入测试部分是20%,random_state的值相当于一种规则，通过设定为相同的数，每次分割的结果都是相同的sc=StandardScaler()#使特征具有零均值和单位变量X_train=sc.fit_transform(X_train)X_test=sc.transform(X_test)X_train=torch.from_numpy(X_train.astype(np.float32))#将X_train数据转换为tensor且是float32型的数据X_test=torch.from_numpy(X_test.astype(np.float32))y_train=torch.from_numpy(y_train.astype(np.float32))y_test=torch.from_numpy(y_test.astype(np.float32))y_train=y_train.view(y_train.shape[0],1)#重塑y的tensory_test=y_test.view(y_test.shape[0],1)#重塑y的tensor,让他从一行变成一列 搭建模型 这里只需要一个线性层 12345678class LogisticRegression(nn.Module): def __init__(self,n_input_features): super(LogisticRegression, self).__init__() self.linear=nn.Linear(n_input_features,1)#我们只需要一个标签 def forward(self,x): y_pred=torch.sigmoid(self.linear(x)) return y_pred 搭建优化器和损失函数 123model=LogisticRegression(n_features)#30个输入特征和一个输出特征criterian=nn.BCELoss()#二分类交叉熵损失optimizer=torch.optim.SGD(model.parameters(),lr=0.01)#随机梯度下降法 对每一轮计算Loss 12345678910111213epochs=100for epoch in range(epochs): y_pred=model(X_train) loss=criterian(y_pred,y_train) loss.backward() optimizer.step() optimizer.zero_grad() if(epoch+1)%10==0: print(f&#x27;epoch:&#123;epoch+1&#125;,loss=&#123;loss.item():.4f&#125;&#x27;) 评估模型准确度 12345with torch.no_grad():#对模型评估 y_pred = model(X_test) y_pred_cls=y_pred.round()#因为之前sigmoid函数已经将其放入了0-1之间，round的作用是将其以0.5为依据变成0或1 acc=y_pred_cls.eq(y_test).sum()/float(y_test.shape[0])#判断预测值与实际值是否相等，相等的话就加1 print(f&#x27;accuracy=&#123;acc:.4f&#125;&#x27;) 输出结果 1234567891011epoch:10,loss=0.5711epoch:20,loss=0.4670epoch:30,loss=0.4019epoch:40,loss=0.3575epoch:50,loss=0.3251epoch:60,loss=0.3003epoch:70,loss=0.2806epoch:80,loss=0.2645epoch:90,loss=0.2511epoch:100,loss=0.2396accuracy=0.9123 可以更改训练次数和学习率来提高模型准确度","categories":[{"name":"Pytorch学习","slug":"Pytorch学习","permalink":"https://mengfanjun020906.github.io/categories/Pytorch%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://mengfanjun020906.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Pytorch实战——MNIST数据集手写数字识别","slug":"Pytorch实战——MNIST数据集手写数字识别","date":"2022-07-06T01:14:41.000Z","updated":"2023-03-24T06:03:50.949Z","comments":true,"path":"2022/07/06/Pytorch实战——MNIST数据集手写数字识别/","link":"","permalink":"https://mengfanjun020906.github.io/2022/07/06/Pytorch%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/","excerpt":"","text":"原视频链接：轻松学Pytorch手写字体识别MNIST 1.加载必要的库 123456#1 加载必要的库import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets,transforms 2.定义超参数 1234#2 定义超参数BATCH_SIZE= 64 #每次训练的数据的个数DEVICE=torch.device(&quot;cuda&quot;if torch.cuda.is_available()else&quot;cpu&quot;)#做一个判断，如果有gpu就用gpu，如果没有的话就用cpuEPOCHS=20 #训练轮数 3.构建pipeline，对图像做处理 12345#3 构建pipeline，对图像做处理pipeline=transforms.Compose([ transforms.ToTensor(),#将图片转换成tensor类型 transforms.Normalize((0.1307,),(0.3081,))#正则化，模型过拟合时，降低模型复杂度]) 4.下载、加载数据集 12345678#下载数据集train_set=datasets.MNIST(&quot;data&quot;,train=True,download=True,transform=pipeline)#文件夹，需要训练，需要下载，要转换成tensortest_set=datasets.MNIST(&quot;data&quot;,train=False,download=True,transform=pipeline)#加载数据train_loader=DataLoader(train_set,batch_size=BATCH_SIZE,shuffle=True)#加载训练集，数据个数为64，需要打乱test_loader=DataLoader(test_set,batch_size=BATCH_SIZE,shuffle=True) 下载完毕之后，看一眼数据集内的图片 12345678910111213with open(&quot;MNIST的绝对路径&quot;,&quot;rb&quot;) as f: file=f.read()image1=[int(str(item).encode(&#x27;ascii&#x27;),10)for item in file[16: 16+784]]print(image1)import cv2import numpy as npimage1_np=np.array(image1,dtype=np.uint8).reshape(28,28,1)print(image1_np.shape)cv2.imwrite(&quot;digit.jpg&quot;,image1_np)#保存图片 输出结果 5.构建网络模型 1234567891011121314151617181920212223242526#5 构建网络模型class Digit(nn.Module): def __init__(self): super().__init__() self.conv1= nn.Conv2d(1,10,kernel_size=5) self.conv2=nn.Conv2d(10,20,kernel_size=3) self.fc1=nn.Linear(20*10*10,500) self.fc2=nn.Linear(500,10) def forward(self,x): input_size=x.size(0) x=self.conv1(x)#输入batch_size 1*28*28 ，输出batch 10*24*24(28-5+1=24) x=F.relu(x) #激活函数,保持shape不变 x=F.max_pool2d(x,2,2)#2是池化步长的大小,输出batch20*12*12 x=self.conv2(x)#输入batch20*12*12 输出batch 20*10*10 (12-3+1=10) x=F.relu(x) x=x.view(input_size,-1)#拉平,-1自动计算维度 20*10*10=2000 x=self.fc1(x)#输入batch 2000 输出batch 500 x=F.relu(x) x=self.fc2(x)#输出batch 500 输出batch 10 ouput=F.log_softmax(x,dim=1)#计算分类后每个数字概率 return ouput 6.定义优化器 123model =Digit().to(device)optimizer=optim.Adam(model.parameters())##选择adam优化器 7.定义训练方法 12345678910111213141516171819#7 定义训练方法def train_model(model,device,train_loader,optimizer,epoch): #模型训练 model.train() for batch_index,(data,target) in enumerate(train_loader): #部署到DEVICE上去 data,target=data.to(device), target.to(device) #梯度初始化为0 optimizer.zero_grad() #预测,训练后结果 output=model(data) #计算损失 loss = F.cross_entropy(output,target)#多分类用交叉验证 #反向传播 loss.backward() #参数优化 optimizer.step() if batch_index%3000==0: print(&quot;Train Epoch :&#123;&#125; \\t Loss :&#123;:.6f&#125;&quot;.format(epoch,loss.item())) 8.定义测试方法 12345678910111213141516171819202122#8 定义测试方法def test_model(model,device,test_loader): #模型验证 model.eval() #正确率 corrcet=0.0 #测试损失 test_loss=0.0 with torch.no_grad(): #不会计算梯度，也不会进行反向传播 for data,target in test_loader: #部署到device上 data,target=data.to(device),target.to(device) #测试数据 output=model(data) #计算测试损失 test_loss+=F.cross_entropy(output,target).item() #找到概率最大的下标 pred=output.argmax(1) #累计正确的值 corrcet+=pred.eq(target.view_as(pred)).sum().item() test_loss/=len(test_loader.dataset) print(&quot;Test--Average Loss:&#123;:.4f&#125;,Accuarcy:&#123;:.3f&#125;\\n&quot;.format(test_loss,100.0 * corrcet / len(test_loader.dataset))) 9.调用方法 1234#9 调用方法for epoch in range(1,EPOCHS+1): train_model(model,DEVICE,train_loader,optimizer,epoch) test_model(model,DEVICE,test_loader) 输出结果 123456789101112131415161718192021222324252627282930313233343536373839Train Epoch :1 Loss :2.296158Train Epoch :1 Loss :0.023645Test--Average Loss:0.0027,Accuarcy:98.690Train Epoch :2 Loss :0.035262Train Epoch :2 Loss :0.002957Test--Average Loss:0.0027,Accuarcy:98.750Train Epoch :3 Loss :0.029884Train Epoch :3 Loss :0.000642Test--Average Loss:0.0032,Accuarcy:98.460Train Epoch :4 Loss :0.002866Train Epoch :4 Loss :0.003708Test--Average Loss:0.0033,Accuarcy:98.720Train Epoch :5 Loss :0.000039Train Epoch :5 Loss :0.000145Test--Average Loss:0.0026,Accuarcy:98.840Train Epoch :6 Loss :0.000124Train Epoch :6 Loss :0.035326Test--Average Loss:0.0054,Accuarcy:98.450Train Epoch :7 Loss :0.000014Train Epoch :7 Loss :0.000001Test--Average Loss:0.0044,Accuarcy:98.510Train Epoch :8 Loss :0.001491Train Epoch :8 Loss :0.000045Test--Average Loss:0.0031,Accuarcy:99.140Train Epoch :9 Loss :0.000428Train Epoch :9 Loss :0.000000Test--Average Loss:0.0056,Accuarcy:98.500Train Epoch :10 Loss :0.000001Train Epoch :10 Loss :0.000377Test--Average Loss:0.0042,Accuarcy:98.930 总结和改进 看完视频之后，老师确实讲得好，但是却没有讲明白为什么网络结构为什么要这样搭建，于是我又去看了看CNN，这个网络结构也能实现 1234567891011121314151617181920212223242526#5 构建网络模型class Digit(nn.Module): def __init__(self): super().__init__() self.conv1= nn.Conv2d(1,10,5) self.conv2=nn.Conv2d(10,20,5) self.fc1=nn.Linear(20*4*4,10) def forward(self,x): input_size=x.size(0) x=self.conv1(x)#输入batch_size 1*28*28 ，输出batch 10*24*24(28-5+1=24) x=F.relu(x) #激活函数,保持shape不变 x=F.max_pool2d(x,2,2)#2是池化步长的大小,输出batch20*12*12 x=self.conv2(x)#输入batch20*12*12 输出batch 20*10*10 (12-3+1=10) x=F.relu(x) x=F.max_pool2d(x,2,2) x=x.view(input_size,-1)#拉平,-1自动计算维度 20*10*10=2000 x=self.fc1(x)#输入batch 2000 输出batch 500 x=F.relu(x) ouput=F.log_softmax(x,dim=1)#计算分类后每个数字概率 return ouput 用CNN之后，发现准确度一下子下降到了50%，百思不得其解，我猜可能是优化器的问题，就把优化器换成了SGD，结果果然效果更好 123Train Epoch :17 Loss :0.014693Train Epoch :17 Loss :0.000051Test--Average Loss:0.0026,Accuarcy:99.010 在第17轮准确率居然到了99%，不知道为什么，先挖个坑，等我以后研究明白再来填","categories":[{"name":"Pytorch学习","slug":"Pytorch学习","permalink":"https://mengfanjun020906.github.io/categories/Pytorch%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"神经网络","slug":"神经网络","permalink":"https://mengfanjun020906.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"关于Scikit-learn机器学习的笔记——第六篇","slug":"关于Scikit-learn机器学习的笔记——第六篇","date":"2022-06-16T02:38:13.000Z","updated":"2023-03-24T01:08:23.286Z","comments":true,"path":"2022/06/16/关于Scikit-learn机器学习的笔记——第六篇/","link":"","permalink":"https://mengfanjun020906.github.io/2022/06/16/%E5%85%B3%E4%BA%8EScikit-learn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AF%87/","excerpt":"","text":"视频教程：【莫烦Python】Scikit-learn (sklearn) 优雅地学会机器学习 Overfitting过拟合现象 黑线已经区分的很好了，但绿线就出现了过拟合的现象 程序示例： 1234567891011121314151617181920212223from sklearn.model_selection import learning_curvefrom sklearn.datasets import load_digitsfrom sklearn.svm import SVCimport matplotlib.pyplot as pltimport numpy as npdigits=load_digits()X=digits.datay=digits.targettrain_sizes,train_loss,test_loss=learning_curve( SVC(gamma=0.001),X,y,cv=10,scoring=&#x27;neg_mean_squared_error&#x27;, train_sizes=[0.1,0.25,0.5,0.75,1])##输出train_size,train的误差，test的误差值，SVC的gamma参数为0.0001，用方差值去测试，在10%，25%的点去记录一下train_loss_mean=-np.mean(train_loss,axis=1)##axis=1表示按列要求，0是按行要求，mean是中间值的意思test_loss_mean=-np.mean(test_loss,axis=1)plt.plot(train_sizes,train_loss_mean,&#x27;o-&#x27;,color=&quot;r&quot;,label=&quot;Training&quot;)plt.plot(train_sizes,test_loss_mean,&#x27;o-&#x27;,color=&quot;g&quot;,label=&quot;Cross-validation&quot;)plt.xlabel(&quot;Training examples&quot;)plt.ylabel(&quot;Loss&quot;)plt.legend(loc=&quot;best&quot;)plt.show() 输出结果： 绿色：表示testdata在刚开始的时候cross-validation的值很高，但随着training的进行，误差会逐渐降低 红色：误差较小，是因为机器在学习的时候，能够较好的预测出train的走向，这就是为什么我们之前要将train和test分开的原因 若将gamma的值改为0.01 123train_sizes,train_loss,test_loss=learning_curve( SVC(gamma=0.01),X,y,cv=10,scoring=&#x27;neg_mean_squared_error&#x27;, train_sizes=[0.1,0.25,0.5,0.75,1]) 输出结果： 曲线最终并没有向下走 红色表示testdata，蓝色表示traindata，在达到一定值以后，test的误差会变大，因为出现了Overfitting 在这里插入图片描述","categories":[{"name":"SKlearn学习笔记","slug":"SKlearn学习笔记","permalink":"https://mengfanjun020906.github.io/categories/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sklearn","slug":"sklearn","permalink":"https://mengfanjun020906.github.io/tags/sklearn/"}]},{"title":"关于Scikit-learn机器学习的笔记——第五篇","slug":"关于Scikit-learn机器学习的笔记——第五篇","date":"2022-06-16T02:38:01.000Z","updated":"2023-03-24T01:08:43.069Z","comments":true,"path":"2022/06/16/关于Scikit-learn机器学习的笔记——第五篇/","link":"","permalink":"https://mengfanjun020906.github.io/2022/06/16/%E5%85%B3%E4%BA%8EScikit-learn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AF%87/","excerpt":"","text":"视频教程：【莫烦Python】Scikit-learn (sklearn) 优雅地学会机器学习 首先用KNN模型来进行基础的学习并且计算模型的分数 程序示例： 12345678910111213from sklearn.datasets import load_iris##从sklearn数据库导入数据from sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifier##从sklearn数据库导入算法，K邻近分类iris=load_iris()##导入鸢尾花数据X=iris.data##花的属性存在data里面y=iris.target##花的分类在target里面X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=4)knn=KNeighborsClassifier(n_neighbors=5)##机器学习命令,考虑学习点附近5个点的neighborknn.fit(X_train,y_train)##这个函数帮助我们完成学习的步骤，所有training在这一步进行print(knn.score(X_test,y_test)) 输出结果： 10.9736842105263158 得分为0.97 接下来我们用5组数据去验证 程序示例： 1234567891011121314from sklearn.datasets import load_iris##从sklearn数据库导入数据from sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifier##从sklearn数据库导入算法，K邻近分类iris=load_iris()##导入鸢尾花数据X=iris.data##花的属性存在data里面y=iris.target##花的分类在target里面from sklearn.model_selection import cross_val_score#X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=4)knn=KNeighborsClassifier(n_neighbors=5)##机器学习命令,考虑学习点附近5个点的neighborscores=cross_val_score(knn,X,y,cv=5,scoring=&#x27;accuracy&#x27;)##将数据分成5层，把数据集平均分成5份，scoring方法是accuracy判断准确度print(scores) 输出结果： 1[0.96666667 1. 0.93333333 0.96666667 1. ] 有两组到了100%，平均一下会更加精准 1print(scores.mean()) 输出结果： 10.9733333333333334 接下来我们观察k从1到31，cv=10，模型的评价值 123456789101112131415161718192021from sklearn.datasets import load_iris##从sklearn数据库导入数据from sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifier##从sklearn数据库导入算法，K邻近分类iris=load_iris()##导入鸢尾花数据X=iris.data##花的属性存在data里面y=iris.target##花的分类在target里面from sklearn.model_selection import cross_val_scoreimport matplotlib.pyplot as pltk_range=range(1,31)##k的范围是1到31k_scores=[]for k in k_range: knn=KNeighborsClassifier(n_neighbors=k)##机器学习命令,考虑学习点附近k个点的neighbor，把k从1到31都带进去 scores=cross_val_score(knn,X,y,cv=10,scoring=&#x27;accuracy&#x27;)##for classication #loss=-cross_val_score(knn,X,y,cv=10,scoring=&#x27;mean_squared_error&#x27;)##for regression k_scores.append(scores.mean())##每次的结果都附加上去plt.plot(k_range,k_scores)plt.xlabel(&#x27;Value for K of KNN&#x27;)plt.ylabel(&#x27;Cross-Validated Accuracy&#x27;)plt.show() 输出结果： 可以看出，k在14到18之间，是非常准确的 如果我们用另一种方式，用判断误差的形式，观察结果会是什么样子的 程序示例： 123456789101112131415161718192021from sklearn.datasets import load_iris##从sklearn数据库导入数据from sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifier##从sklearn数据库导入算法，K邻近分类iris=load_iris()##导入鸢尾花数据X=iris.data##花的属性存在data里面y=iris.target##花的分类在target里面from sklearn.model_selection import cross_val_scoreimport matplotlib.pyplot as pltk_range=range(1,31)##k的范围是1到31k_scores=[]for k in k_range: knn=KNeighborsClassifier(n_neighbors=k)##机器学习命令,考虑学习点附近k个点的neighbor，把k从1到31都带进去，这里的模型也可以改，判断该采用什么样子的模型 #scores=cross_val_score(knn,X,y,cv=10,scoring=&#x27;accuracy&#x27;)##for classication,用了cv=10更精准 loss=-cross_val_score(knn,X,y,cv=10,scoring=&#x27;neg_mean_squared_error&#x27;)##for regression，判断误差 k_scores.append(loss.mean())##每次的结果都附加上去plt.plot(k_range,k_scores)plt.xlabel(&#x27;Value for K of KNN&#x27;)plt.ylabel(&#x27;Cross-Validated Accuracy&#x27;)plt.show() 输出结果： loss越小，他的误差越小，应该选最小loss的k值 如果要换不同的模型，只需要改model那里就好","categories":[{"name":"SKlearn学习笔记","slug":"SKlearn学习笔记","permalink":"https://mengfanjun020906.github.io/categories/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sklearn","slug":"sklearn","permalink":"https://mengfanjun020906.github.io/tags/sklearn/"}]},{"title":"关于Scikit-learn机器学习的笔记——第四篇","slug":"关于Scikit-learn机器学习的笔记——第四篇","date":"2022-06-15T13:24:25.000Z","updated":"2023-03-24T01:08:34.093Z","comments":true,"path":"2022/06/15/关于Scikit-learn机器学习的笔记——第四篇/","link":"","permalink":"https://mengfanjun020906.github.io/2022/06/15/%E5%85%B3%E4%BA%8EScikit-learn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AF%87/","excerpt":"","text":"视频教程：【莫烦Python】Scikit-learn (sklearn) 优雅地学会机器学习 在我们获得数据时，需要对数据进行normalization x1的数据范围更大，x2的数据范围很小，以这样的数值这样进行机器学习会使得结果不准确，所以我们需要经过标准化，再去进行机器学习 程序示例： 123456789from sklearn import preprocessingimport numpy as npa=np.array([[10,2.7,3.6], [-100,5,-2], [120,20,40]],dtype=np.float64)##3个features分别是从-100到120，从2.7到20，从-2到40print(a)##无scale的结果print(preprocessing.scale(a)) ##有scale之后的结果 输出结果： 123456[[ 10. 2.7 3.6] [-100. 5. -2. ] [ 120. 20. 40. ]][[ 0. -0.85170713 -0.55138018] [-1.22474487 -0.55187146 -0.852133 ] [ 1.22474487 1.40357859 1.40351318]] 很明显的看出来，经过scale的结果会更适合机器学习，因为他的偏差会更小 接下来我们生成一些随机值，用SVM模型寻找超平面 程序示例： 12345678910from sklearn import preprocessingimport numpy as npfrom sklearn.model_selection import train_test_split##从sklearn数据库导入函数from sklearn.datasets._samples_generator import make_classificationfrom sklearn.svm import SVCimport matplotlib.pyplot as pltX,y=make_classification(n_samples=300,n_features=2,n_redundant=0,n_informative=2,random_state=22,n_clusters_per_class=1,scale=100)plt.scatter(X[:,0],X[:,1],c=y)plt.show() 输出结果： 接下来，我们利用SVM去学习，先不进行标准化数据 程序示例： 12345678910111213from sklearn import preprocessingimport numpy as npfrom sklearn.model_selection import train_test_split##从sklearn数据库导入函数from sklearn.datasets._samples_generator import make_classificationfrom sklearn.svm import SVCimport matplotlib.pyplot as pltX,y=make_classification(n_samples=300,n_features=2,n_redundant=0,n_informative=2,random_state=22,n_clusters_per_class=1,scale=100)X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=.3)##X,y分为训练数据和测试数据，用traindata去学习，testdata去预测clf=SVC()clf.fit(X_train,y_train)##traindata放入模型去学习print(clf.score(X_test,y_test))##用test去测试他的分数 输出结果： 10.9333333333333333 假如利经过标准化，那我们会得到什么样的结果 程序示范例： 1234567891011121314from sklearn import preprocessingimport numpy as npfrom sklearn.model_selection import train_test_split##从sklearn数据库导入函数from sklearn.datasets._samples_generator import make_classificationfrom sklearn.svm import SVCimport matplotlib.pyplot as pltX,y=make_classification(n_samples=300,n_features=2,n_redundant=0,n_informative=2,random_state=22,n_clusters_per_class=1,scale=100)X=preprocessing.scale(X)##进行标准化数据X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=.3)##X,y分为训练数据和测试数据，用traindata去学习，testdata去预测clf=SVC()clf.fit(X_train,y_train)##traindata放入模型去学习print(clf.score(X_test,y_test))##用test去测试他的分数 输出结果： 10.94444444444444 结果分数会高一点，这个分数会随着生成的数值的不同而变化","categories":[{"name":"SKlearn学习笔记","slug":"SKlearn学习笔记","permalink":"https://mengfanjun020906.github.io/categories/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sklearn","slug":"sklearn","permalink":"https://mengfanjun020906.github.io/tags/sklearn/"}]},{"title":"关于Scikit-learn机器学习的笔记——第三篇","slug":"关于Scikit-learn机器学习的笔记——第三篇","date":"2022-06-15T13:24:07.000Z","updated":"2022-12-05T05:24:04.727Z","comments":true,"path":"2022/06/15/关于Scikit-learn机器学习的笔记——第三篇/","link":"","permalink":"https://mengfanjun020906.github.io/2022/06/15/%E5%85%B3%E4%BA%8EScikit-learn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AF%87/","excerpt":"","text":"视频教程：【莫烦Python】Scikit-learn (sklearn) 优雅地学会机器学习 接着上一次的代码，我们这次学习model的一些属性 运用model.coef_与model.intercept_输出这一模型的k值和与y轴交点 程序示例： 12345678910111213from sklearn import datasets##导入datasetsfrom sklearn.linear_model import LinearRegression##导入线性回归模型import matplotlib.pyplot as plt##使用图像化工具loaded_data=datasets.load_boston()##加载boston数据data_X=loaded_data.data##数据值data_y=loaded_data.target##目标值modele=LinearRegression()##用线性回归模型modele.fit(data_X,data_y)##data_X是训练数据输入，data_y是训练数据输出print(modele.coef_) #例如样本是线性回归模型y=0.1x+0.3，则会输出k值也就是0.1print(modele.intercept_) #输出模型与Y轴的交点，会输出0.3 输出结果： 12345[-1.08011358e-01 4.64204584e-02 2.05586264e-02 2.68673382e+00 -1.77666112e+01 3.80986521e+00 6.92224640e-04 -1.47556685e+00 3.06049479e-01 -1.23345939e-02 -9.52747232e-01 9.31168327e-03 -5.24758378e-01]##这些数值就是boston的房屋面积、房屋价格、楼层等因素与这些数值相乘36.45948838508989##与y轴交点 这两个值加在一起，就是整个线性回归模型 接下来我们输出定义模型的参数： 1print(modele.get_params()) 输出结果： 1&#123;&#x27;copy_X&#x27;: True, &#x27;fit_intercept&#x27;: True, &#x27;n_jobs&#x27;: None, &#x27;normalize&#x27;: &#x27;deprecated&#x27;, &#x27;positive&#x27;: False&#125; 对模型进行打分： 1print(modele.score(data_X,data_y))#在线性回归中用R^2进行打分 coefficient of determination 输出结果： 10.7406426641094094##约为74%准确度","categories":[{"name":"SKlearn学习笔记","slug":"SKlearn学习笔记","permalink":"https://mengfanjun020906.github.io/categories/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sklearn","slug":"sklearn","permalink":"https://mengfanjun020906.github.io/tags/sklearn/"}]},{"title":"关于Scikit-learn机器学习的笔记——第二篇","slug":"关于Scikit-learn机器学习的笔记——第二篇","date":"2022-06-14T01:41:26.000Z","updated":"2023-03-24T01:08:09.422Z","comments":true,"path":"2022/06/14/关于Scikit-learn机器学习的笔记——第二篇/","link":"","permalink":"https://mengfanjun020906.github.io/2022/06/14/%E5%85%B3%E4%BA%8EScikit-learn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AF%87/","excerpt":"","text":"视频教程：【莫烦Python】Scikit-learn (sklearn) 优雅地学会机器学习 在第一篇中，我们采用了鸢尾花的数据集进行了测试，这次我们采用boston的数据集进行测试，boston也是sklearn自带的数据库 程序示例： 123456789101112from sklearn import datasets##导入datasetsfrom sklearn.linear_model import LinearRegression##导入线性回归模型loaded_data=datasets.load_boston()##加载boston数据data_X=loaded_data.data##数据值data_y=loaded_data.target##目标值modele=LinearRegression()##用线性回归模型modele.fit(data_X,data_y)##data_X是训练数据输入，data_y是训练数据输出print(modele.predict(data_X[:4,:]))##对前四个数据进行预测print(data_y[:4])##前四个数据实际值，形成对比，观察其预测的准确度 输出结果： 12[30.00384338 25.02556238 30.56759672 28.60703649]##预测值[24. 21.6 34.7 33.4]##实际值 可以看到，预测的结果并没有那么准确，因为我们并没有将对模型进行改善，所以作为入门学习，采用sklearn默认的模型就足够了 接下来我们创造一些数据，赋值给X，y 程序示例： 1234567from sklearn import datasets##导入datasetsfrom sklearn.linear_model import LinearRegression##导入线性回归模型import matplotlib.pyplot as plt##使用图像化工具X,y=datasets.make_regression(n_samples=100,n_features=1,n_targets=1,noise=1)##创造100个例子，1个特征值，1个回归目标，1noiseplt.scatter(X,y)##画图plt.show()##展示出画图的结果 输出结果： 若noise变大，noise=10，离散会更大 noise=10的输出结果： 运用我们创造出的数据进行机器学习，可以让我们更有目的性的去进行训练","categories":[{"name":"SKlearn学习笔记","slug":"SKlearn学习笔记","permalink":"https://mengfanjun020906.github.io/categories/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sklearn","slug":"sklearn","permalink":"https://mengfanjun020906.github.io/tags/sklearn/"}]},{"title":"第十三届蓝桥杯单片机三等奖选手的复盘","slug":"第十三届蓝桥杯单片机三等奖选手的复盘","date":"2022-05-11T10:38:52.000Z","updated":"2022-12-05T05:17:44.793Z","comments":true,"path":"2022/05/11/第十三届蓝桥杯单片机三等奖选手的复盘/","link":"","permalink":"https://mengfanjun020906.github.io/2022/05/11/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%89%E7%AD%89%E5%A5%96%E9%80%89%E6%89%8B%E7%9A%84%E5%A4%8D%E7%9B%98/","excerpt":"","text":"出成绩已经是上个月的事情了，因为最近的事情太多，所以就没有时间写复盘，现在有时间了，可以写一个总结，也算是对自己接下来的发展给一个建议。 拿了省三，感觉还是有点可惜的，我在做的时候我记得是错了4个选择，然后程序题就差了电位器和LED的闪烁有点问题，剩下的所有都是实现了，可能是我之前的bug太多了，扣分项就比较多，做的时候一下子写五个小时还是很累的，我大概是提前交卷了一个小时，因为实在做不下去了，就赶紧交卷走人了，总结出的经验大概有以下几个： 做的时候不能着急把功能做出来，要先把整个板子的基础逻辑写好，先把卷子读完，再去写，我写的时候着急了，看到温度和模式转换，就直接写了一大片 每个模式一定要注意细节，把模式切换的每一个bug都解决，不要问做的差不多可不可以，一定要一点问题都没有的做出来 然后就是技术问题了，我们专业的大佬拿了一等奖，看了看他的代码，300多行就实现了，我写了400多行还是感觉差一点 我去学stm32赶项目了，这几天先不更了，再次更新就是更新stm32系列了","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"},{"name":"个人反思与总结","slug":"蓝桥杯单片机学习/个人反思与总结","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/%E4%B8%AA%E4%BA%BA%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"STM32F103C8T6 HAL库——从零开始的制作平衡小车生活","slug":"STM32F103C8T6 HAL库——从零开始的制作平衡小车生活","date":"2022-04-18T07:13:54.000Z","updated":"2023-03-24T06:05:39.905Z","comments":true,"path":"2022/04/18/STM32F103C8T6 HAL库——从零开始的制作平衡小车生活/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/18/STM32F103C8T6%20HAL%E5%BA%93%E2%80%94%E2%80%94%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%88%B6%E4%BD%9C%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E7%94%9F%E6%B4%BB/","excerpt":"","text":"最近买了个平衡小车，为了圆我PID梦，买来玩玩，废话不多说，直接开搞 第一步：让小车的轮子转起来 我用的电机是TB6612FNG，想详细了解的话直接去搜手册，给他输出两路PWM还要两个引脚进行高低电平的转换就可以设置前进或者后退了，规则如下 看一下引脚图吧 引脚连接： PWMA PA11 PWMB PA8 AIN1 PB13 AIN2 PB12 BIN1 PB14 BIN2 PB15 下面开始配置CUBE 首先是SYS： 其次是时钟： 下面开始引脚的设置： 用定时器1，10Hz就够了 生成： 代码部分： main.h 1234567891011/* USER CODE BEGIN Private defines */#define AIN2_Pin GPIO_PIN_12#define AIN2_GPIO_Port GPIOB#define AIN1_Pin GPIO_PIN_13#define AIN1_GPIO_Port GPIOB#define BIN2_Pin GPIO_PIN_14#define BIN2_GPIO_Port GPIOB#define BIN1_Pin GPIO_PIN_15#define BIN1_GPIO_Port GPIOB/* USER CODE END Private defines */ main.c 12345678/* USER CODE BEGIN 2 */ HAL_TIM_PWM_Start(&amp;htim1,TIM_CHANNEL_1);//开启TIM1_CH1 HAL_TIM_PWM_Start(&amp;htim1,TIM_CHANNEL_4);//开启TIM1_CH4 HAL_GPIO_WritePin(AIN1_GPIO_Port,AIN1_Pin,GPIO_PIN_RESET);//AIN1为0 HAL_GPIO_WritePin(AIN2_GPIO_Port,AIN2_Pin,GPIO_PIN_SET);//AIN2位1，反转 HAL_GPIO_WritePin(BIN1_GPIO_Port,BIN1_Pin,GPIO_PIN_RESET);//BIN1为0 HAL_GPIO_WritePin(BIN2_GPIO_Port,BIN2_Pin,GPIO_PIN_SET);//BIN2位1，反转 /* USER CODE END 2 */ 123456789101112131415161718192021222324252627/* USER CODE BEGIN 3 */ HAL_GPIO_WritePin(AIN1_GPIO_Port,AIN1_Pin,GPIO_PIN_RESET); HAL_GPIO_WritePin(AIN2_GPIO_Port,AIN2_Pin,GPIO_PIN_SET); HAL_GPIO_WritePin(BIN1_GPIO_Port,BIN1_Pin,GPIO_PIN_RESET); HAL_GPIO_WritePin(BIN2_GPIO_Port,BIN2_Pin,GPIO_PIN_SET); for(int i=0;i&lt;7100;i++) &#123; __HAL_TIM_SET_COMPARE(&amp;htim1,TIM_CHANNEL_4,i);//让轮子转起来 HAL_Delay(1); &#125; for(int j=7100;j&gt;0;j--) &#123; __HAL_TIM_SET_COMPARE(&amp;htim1,TIM_CHANNEL_4,j); HAL_Delay(1); &#125; for(int i=0;i&lt;7100;i++) &#123; __HAL_TIM_SET_COMPARE(&amp;htim1,TIM_CHANNEL_1,i); HAL_Delay(1); &#125; for(int j=7100;j&gt;0;j--) &#123; __HAL_TIM_SET_COMPARE(&amp;htim1,TIM_CHANNEL_1,j); HAL_Delay(1); &#125; &#125; /* USER CODE END 3 */ 第二步：用编码器测出小车的速度 先看原理图 PA0和PA1，PA6和PA7分别是小车的编码器引脚，所以我们在cunbe中将这四个引脚设置为Encoder模式 在cube中设置好编码器之后，我们再设置好串口，异步通信，再打开中断 首先开启编码器 123456789101112void Encoder_Start(void) //启动两个编码器. 而编码器初始化HAL_TIM_Encoder_Init()和HAL_TIM_Encoder_MspInit()在main()函数中调用的MX_TIM2_Init()中。&#123; __HAL_TIM_SET_COUNTER(&amp;htim2,0); //用带参宏设置编码器的初始值为0(涉及正反转的需要) __HAL_TIM_SET_COUNTER(&amp;htim3,0); HAL_TIM_Encoder_Start_IT(&amp;htim2,TIM_CHANNEL_ALL); //开启编码器的中断模式,两个定时器通道TI1和TI2是每个编码器的两个信号采集通道. HAL_TIM_Encoder_Start_IT(&amp;htim3,TIM_CHANNEL_ALL); HAL_TIM_Encoder_Start(&amp;htim2,TIM_CHANNEL_ALL); //开启两个编码器 HAL_TIM_Encoder_Start(&amp;htim3,TIM_CHANNEL_ALL); &#125; 读取编码器速度值 1234567891011121314151617181920int Read_Speed(int TIMx)&#123; int Encoder_Value = 0; switch(TIMx) &#123; case 2: Encoder_Value =(short) __HAL_TIM_GET_COUNTER(&amp;htim2); //保存编码器计数器的值 __HAL_TIM_SET_COUNTER(&amp;htim2,0); //保存之后要清零,以便下次继续读取.另外每次清零后采样值减0,直接用单位时间的话就可以得出速度信息了.不要麻烦还要减去初值了. break; case 3: Encoder_Value =(short) __HAL_TIM_GET_COUNTER(&amp;htim3); __HAL_TIM_SET_COUNTER(&amp;htim3,0); break; default: Encoder_Value = 0; &#125; return Encoder_Value;&#125; 这里是主函数，记得定义encoder2和encoder3 12345678910 /* USER CODE BEGIN WHILE */ while (1) &#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ encoder2=Read_Speed(2); encoder3=Read_Speed(3); printf(&quot;A轮=%d,B轮=%d\\n&quot;,encoder2,encoder3); &#125;&#125; 输出结果，因为是拿手转的，只能一只手转轮子： 第三步：读取MPU6050的数据值 接下来就是最难的MPU6050了，我这里就不详细讲了，因为我自己对底层也不是很了解 左边我们可以看到XYZ的加速度，和XYZ陀螺仪数值，他们经过ADC转换后的数值通过IIC可以直接输出，但是数值就是纯数值，并不是角度值，然后就去DMP了，DMP在输出去FIMO，我理解就是，可以把MPU6050读取的这些东西，变成四元数，然后再通过IIC输出，就可以变成角度值了 首先我们在CUBE中配置好IIC的SDA线和SCL线 MPU6050的读写程序我就不展示了，因为这些从网络上都能找到，我用的是正点原子的，需要注意的就是我这里用的是硬件的HAL库IIC，之前我们老师说硬件的IIC有点bug，让我们用软件的，但是我试了试硬件的IIC，发现也挺好用的，就不用软件的了 读取结果： 可以看到欧拉角的角度值，这样就可以去调整小车的姿态了 第四步：PID 最近在做智能采摘机器人 有时间一定接着更！","categories":[],"tags":[{"name":"stm32","slug":"stm32","permalink":"https://mengfanjun020906.github.io/tags/stm32/"},{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"关于Scikit-learn机器学习的笔记——第一篇","slug":"关于Scikit-learn机器学习的笔记——第一篇","date":"2022-04-18T07:13:54.000Z","updated":"2023-03-24T01:08:48.871Z","comments":true,"path":"2022/04/18/关于Scikit-learn机器学习的笔记——第一篇/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/18/%E5%85%B3%E4%BA%8EScikit-learn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AF%87/","excerpt":"","text":"视频教程：【莫烦Python】Scikit-learn (sklearn) 优雅地学会机器学习 首先从安装sklearn入手，我用的是python3.7，需要安装numpy和scipy，安装之后，就可以用sklearn自带的数据了，就用它自带的鸢尾花了 程序示例（我是用Pycharm运行的)： 12345678910import numpy as npfrom sklearn import datasets##从sklearn数据库导入数据from sklearn.model_selection import KFoldfrom sklearn.model_selection import train_test_split##从sklearn数据库导入函数from sklearn.neighbors import KNeighborsClassifier##从sklearn数据库导入算法，K邻近分类iris=datasets.load_iris()##导入鸢尾花数据iris_X=iris.data##花的属性存在data里面iris_Y=iris.target##花的分类在target里面print(iris_X[:2,:]) ##打印出iris的属性，2个 输出结果： 12[[5.1 3.5 1.4 0.2] [4.9 3. 1.4 0.2]] 有花的4种属性，可能是花的大小什么的，不是很懂。 再看看他的分类： 1print(iris_Y)##花的分类 输出结果： 12345[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2] 0代表一类，1代表一类，2代表一类 我们要去学习花的四个属性搭配上他的类别，会预测出新的东西 这个函数分出了我们的用于学习的data和测试的data，测试数据比例占30%，训练数据占70%，这些数据被分成两部分的好处是他们不会互相影响 12X_train,X_test,Y_train,Y_test=train_test_split(iris_X,iris_Y,test_size=0.3)##train_data：所要划分的样本特征集 train_target：所要划分的样本结果 test_size：样本占比，如果是整数的话就是样本的数量print(Y_train)#看看他的类别 输出结果： 123[2 1 1 1 0 0 1 0 2 1 1 2 0 0 0 1 0 1 0 2 1 1 0 2 2 2 1 0 2 1 1 2 1 1 1 2 0 1 2 0 0 1 1 0 0 2 2 2 1 2 0 2 1 0 1 0 1 0 2 2 1 0 0 1 0 0 0 1 1 0 2 2 0 1 0 2 1 1 2 2 2 2 0 2 1 0 0 0 1 2 0 1 1 2 2 1 2 2 1 2 2 2 0 2 0] 这里的数据是被打乱的，可以在机器学习过程中不会有排列在一起的影响 利用K邻近算法进行机器学习 下面进行分类： 1234knn=KNeighborsClassifier()##机器学习命令knn.fit(X_train,Y_train)##这个函数帮助我们完成学习的步骤，所有training在这一步进行print(knn.predict(X_test))##机器预测测试数据结果，这里的knn已经训练完了print(Y_test)##之前的真实数据 输出结果： 1234[2 1 0 0 0 0 2 0 2 1 0 2 2 0 0 1 0 1 2 0 1 2 2 0 0 1 2 0 1 1 2 0 1 2 1 2 0 2 2 0 0 1 0 2 2][2 1 0 0 0 0 1 0 2 1 0 2 2 0 0 1 0 1 2 0 1 2 2 0 0 1 2 0 1 1 2 0 1 2 1 2 0 2 2 0 0 1 0 2 2] 结果出现1-2位不同，预测得很好，机器学习只能大概模拟出数据，不能完全还原真实数据","categories":[{"name":"SKlearn学习笔记","slug":"SKlearn学习笔记","permalink":"https://mengfanjun020906.github.io/categories/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"sklearn","slug":"sklearn","permalink":"https://mengfanjun020906.github.io/tags/sklearn/"}]},{"title":"用Pytorch搭建第一个神经网络(CIFAR10)且进行优化","slug":"用Pytorch搭建第一个神经网络(CIFAR10)且进行优化","date":"2022-04-18T07:13:54.000Z","updated":"2023-03-24T05:55:53.309Z","comments":true,"path":"2022/04/18/用Pytorch搭建第一个神经网络(CIFAR10)且进行优化/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/18/%E7%94%A8Pytorch%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CIFAR10)%E4%B8%94%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/","excerpt":"","text":"最近一直在学习pytorch，这次自己跟着教程搭了一个神经网络，用的最经典的CIFAR10，先看一下原理 输入3通道32*32，最后经过3个卷积，3个最大池化，还有1个flatten，和两个线性化，得到十个输出 程序如下： 12345678910111213141516171819202122232425262728293031323334from torch import nnfrom torch.nn import Conv2d, MaxPool2d, Flatten, Linearclass NetWork(nn.Module): def __init__(self): super(NetWork, self).__init__() self.conv1=Conv2d(3,32,5,padding=2) self.maxpool1=MaxPool2d(2) self.conv2=Conv2d(32,32,5,padding=2) self.maxpool2=MaxPool2d(2) self.conv3=Conv2d(32,64,5,padding=2) self.maxpool3=MaxPool2d(2) self.flatten=Flatten() self.linear1=Linear(1024,64)#1024=64*4*4 self.linear2=Linear(64,10) def forward(self,x): x=self.conv1(x) x=self.maxpool1(x) x=self.conv2(x) x=self.maxpool2(x) x=self.conv3(x) x=self.maxpool3(x) x=self.flatten(x) x=self.linear1(x) x=self.linear2(x) return xnetwork=NetWork()print(network) 这里我们还可以用tensorboard看一看，记得import 1234567input=torch.ones((64,3,32,32))output=network(input)writer=SummaryWriter(&quot;logs_seq&quot;)writer.add_graph(network,input)writer.close() 在tensorboard中是这样的 打开NetWork 可以放大查看 神经网络都是有误差的，所以我们采用梯度下降来减少误差 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import torchvision.datasetsfrom torch import nnfrom torch.nn import Sequential,Conv2d,MaxPool2d,Flatten,Linearfrom torch.utils.data import DataLoaderimport torchdataset=torchvision.datasets.CIFAR10(&quot;./dataset2&quot;,train=False,transform=torchvision.transforms.ToTensor(), download=True)dataloader=DataLoader(dataset,batch_size=1)class NetWork(nn.Module): def __init__(self): super(NetWork, self).__init__() self.conv1=Conv2d(3,32,5,padding=2) self.maxpool1=MaxPool2d(2) self.conv2=Conv2d(32,32,5,padding=2) self.maxpool2=MaxPool2d(2) self.conv3=Conv2d(32,64,5,padding=2) self.maxpool3=MaxPool2d(2) self.flatten=Flatten() self.linear1=Linear(1024,64)#1024=64*4*4 self.linear2=Linear(64,10) self.model1=Sequential( Conv2d(3,32,5,padding=2), MaxPool2d(2), Conv2d(32,32,5,padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self,x): # x=self.conv1(x) # x=self.maxpool1(x) # x=self.conv2(x) # x=self.maxpool2(x) # x=self.conv3(x) # x=self.maxpool3(x) # x=self.flatten(x) # x=self.linear1(x) # x=self.linear2(x) x=self.model1(x) return xloss=nn.CrossEntropyLoss()network=NetWork()optim=torch.optim.SGD(network.parameters(),lr=0.01)##利用梯度下降作为优化器for epoch in range(20):##循环20次 running_loss=0.0 for data in dataloader: imgs, targets=data outputs=network(imgs) result_loss=loss(outputs, targets) optim.zero_grad()##把每一次的下降值归零 result_loss.backward() optim.step() running_loss=running_loss+result_loss print(running_loss) 我电脑的GPU是RTX2060属于比较老的了，跑了三遍大概花了1分钟，实在太慢我就结束运行了 输出结果： 123tensor(18733.7539, grad_fn=&lt;AddBackward0&gt;)tensor(16142.7451, grad_fn=&lt;AddBackward0&gt;)tensor(15420.9199, grad_fn=&lt;AddBackward0&gt;) 可以看出误差是在越来越小的，但是在应用中跑20层实在太少了，等我新电脑到了我跑100层","categories":[{"name":"Pytorch学习","slug":"Pytorch学习","permalink":"https://mengfanjun020906.github.io/categories/Pytorch%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"神经网络","slug":"神经网络","permalink":"https://mengfanjun020906.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"蓝桥杯单片机第十一届模拟题——智能门锁的程序以及设计思路","slug":"蓝桥杯单片机第十一届模拟题——智能门锁的程序以及设计思路","date":"2022-04-18T07:13:54.000Z","updated":"2023-03-24T01:11:10.326Z","comments":true,"path":"2022/04/18/蓝桥杯单片机第十一届模拟题——智能门锁的程序以及设计思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/18/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E6%A8%A1%E6%8B%9F%E9%A2%98%E2%80%94%E2%80%94%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"","text":"最近在练习蓝桥杯的单片机，因为之前沉迷游戏太久了，于是就想做出来一个涨涨面子，这一做就是一周。。。。。。。但总算做出来了，在这里复盘一下，顺便放出代码，大家也能看看，检查一下bug之类的。 注意！！！J5为KBD模式，J13位IO模式，然后跳线帽不要放在P34和SIGNAL上，我就因为这个看了1个小时的代码 原理图 请添加图片描述 题目 主要是分四个显示： 输入显示 修改显示 正确显示 错误显示（清除） 首先我做的就是输入部分，这里是把就矩阵键盘分成了四行，分别让每一行为0，再检测其列的电平，若在那一行，行电平为0，列电平也为0，就能确定被按下的按键，做出按键后移之后，第一部分输入部分就做完了。 第二部分是清楚输入，就是直接将所有数据置为0，这个好写。 第三部分就是修改了，因为修改按键是S12，所以在按下S12的时候，直接跳进另一个修改循环，直到再次按下S12的时候再跳出循环。 第四部分是正确显示，在正确显示的条件下，按下S12才能进入密码修改界面。 基本思路就是这样，实际上做起来，也是遇到了各种各样的问题，但是一点一点debug就能做出来 首先是iic.c，程序的驱动 iic.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &quot;intrins.h&quot;#define DELAY_TIME 5#define SlaveAddrW 0xA0#define SlaveAddrR 0xA1sbit SDA = P2^1; sbit SCL = P2^0; void IIC_Delay(unsigned char i)&#123; do&#123;_nop_();&#125; while(i--); &#125;void IIC_Start(void)&#123; SDA = 1; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 0; IIC_Delay(DELAY_TIME); SCL = 0; &#125;void IIC_Stop(void)&#123; SDA = 0; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 1; IIC_Delay(DELAY_TIME);&#125;void IIC_SendAck(bit ackbit)&#123; SCL = 0; SDA = ackbit; IIC_Delay(DELAY_TIME); SCL = 1; IIC_Delay(DELAY_TIME); SCL = 0; SDA = 1; IIC_Delay(DELAY_TIME);&#125;bit IIC_WaitAck(void)&#123; bit ackbit; SCL = 1; IIC_Delay(DELAY_TIME); ackbit = SDA; SCL = 0; IIC_Delay(DELAY_TIME); return ackbit;&#125;void IIC_SendByte(unsigned char byt)&#123; unsigned char i; for(i=0; i&lt;8; i++) &#123; SCL = 0; IIC_Delay(DELAY_TIME); if(byt &amp; 0x80) SDA = 1; else SDA = 0; IIC_Delay(DELAY_TIME); SCL = 1; byt &lt;&lt;= 1; IIC_Delay(DELAY_TIME); &#125; SCL = 0; &#125;unsigned char IIC_RecByte(void)&#123; unsigned char i, da; for(i=0; i&lt;8; i++) &#123; SCL = 1; IIC_Delay(DELAY_TIME); da &lt;&lt;= 1; if(SDA) da |= 1; SCL = 0; IIC_Delay(DELAY_TIME); &#125; return da; &#125; MAIN.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585#include&lt;reg51.h&gt;#include&lt;iic.c&gt;#define uchar unsigned char#define uint unsigned intsbit R1=P3^0;sbit R2=P3^1;sbit R3=P3^2;sbit R4=P3^3;sbit C1=P4^4;sbit C2=P4^2;sbit C3=P3^5;sbit C4=P3^4;unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0x88,0x83,0xc6,0xa1,0x86,0x8e,0XBF,0XFF,0x86,0x8c,0xc8,0xc6&#125;;//前面是0-9，后面的16是-，17为全灭，18为E，19为P，20为n，21是大写的Cunsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;//从左到右的数码管位置int key[6]=&#123;17,17,17,17,17,17&#125;;//输入的数字数组int key_edit[6]=&#123;17,17,17,17,17,17&#125;;//做修改的数字数组int count=0;//用来统计按键共按了几次int x=0;//就是用来进入按键模式的一个值，没啥意义int password[6]=&#123;8,8,8,8,8,8&#125;;//这个是正确的密码int minus=0;uchar S7=0;//下面都是按键所代表的数值uchar S11=1;uchar S15=2;uchar S19=3;uchar S6=4;uchar S10=5;uchar S14=6;uchar S18=7;uchar S5=8;uchar S9=9;void input_fun();//输入功能void edit_fun();//编辑功能void write_eeprom(unsigned char add,unsigned char date);//写入eeprom数据，前面是地址，后面是数据unsigned char read_eeprom(unsigned char add);//读eeprom的数据，括号里面写地址void write_password();//保存修改的密码void read_password();//给password密码数组赋值void display_input();//显示输入的数字void display_input_minus();//清除所有数字void display_edit();//显示编辑密码的输入界面void display_correct();//显示密码正确打开void Init();//矩阵键盘的配置void key_fun1(x);//第一行按键表示的数字void key_fun2(x);//第二行按键表示的数字void key_fun3(x);//第三行按键表示的数字，这么做是因为矩阵按键代码不能让某一个按键为低电平，所以分行检测void Scan_keys1();//扫描第一行void Scan_keys2();//扫描第二行void Scan_keys3();//扫描第三行void Scan_keys4();//扫描第四行void Start();//开始进入输入状态void delay_ms(int ms);//延时一毫秒void shumaguan_control(uchar a,uchar b);//数码管显示函数，前面是位置，后面是数据void allinit();//配置所有引脚void allinit()//配置所有引脚&#123; P2=(P2&amp;0x1f)|0x80; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xA0; P0 = P0 &amp; 0XAF; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xc0; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xe0; P0=0xFF; P2&amp;=0x1f;&#125;void shumaguan_control(uchar a,uchar b)//数码管显示函数，前面是位置，后面是数据&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1);&#125;void delay_ms(int ms)//延时一毫秒&#123; int q,w; for(q = 0;q&lt;ms;q++)&#123; for(w=845;w&gt;0;w--); &#125;&#125;void write_eeprom(unsigned char add,unsigned char date)//写入eeprom数据，前面是地址，后面是数据&#123; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_SendByte(date); IIC_WaitAck(); IIC_Stop();&#125;unsigned char read_eeprom(unsigned char add)//读eeprom的数据，括号里面写地址&#123; unsigned char temp; EA = 0; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Start(); IIC_SendByte(0xa1); IIC_WaitAck(); temp = IIC_RecByte(); IIC_SendAck(1); IIC_WaitAck(); IIC_Stop(); EA = 1; return temp;&#125;void write_password()//保存修改的密码&#123; write_eeprom(0x00,key_edit[0]); delay_ms(10);//如果不delay10秒就会出错，我也不知道为啥 write_eeprom(0x01,key_edit[1]); delay_ms(10); write_eeprom(0x02,key_edit[2]); delay_ms(10); write_eeprom(0x03,key_edit[3]); delay_ms(10); write_eeprom(0x04,key_edit[4]); delay_ms(10); write_eeprom(0x05,key_edit[5]); delay_ms(10);&#125;void read_password()//给password密码数组赋值&#123; password[0]=read_eeprom(0x00); delay_ms(10); password[1]=read_eeprom(0x01); delay_ms(10); password[2]=read_eeprom(0x02); delay_ms(10); password[3]=read_eeprom(0x03); delay_ms(10); password[4]=read_eeprom(0x04); delay_ms(10); password[5]=read_eeprom(0x05); delay_ms(10);&#125;void display_input()//显示输入的数字&#123; P2=0x80;P0=0xbf; shumaguan_control(7,key[0]); shumaguan_control(6,key[1]); shumaguan_control(5,key[2]); shumaguan_control(4,key[3]); shumaguan_control(3,key[4]); shumaguan_control(2,key[5]); shumaguan_control(0,16);//最左边的-&#125;void display_input_minus()//清除所有数字&#123; key[0]=key[1]=key[2]=key[3]=key[4]=key[5]=17; count=0;//从0开始&#125;void display_edit()//显示编辑密码的输入界面&#123; P2=0x80;P0=0x7f;//L8亮灯 key_edit[0]=key[0]; key_edit[1]=key[1]; key_edit[2]=key[2]; key_edit[3]=key[3]; key_edit[4]=key[4]; key_edit[5]=key[5]; shumaguan_control(0,21); shumaguan_control(7,key_edit[0]); shumaguan_control(6,key_edit[1]); shumaguan_control(5,key_edit[2]); shumaguan_control(4,key_edit[3]); shumaguan_control(3,key_edit[4]); shumaguan_control(2,key_edit[5]);&#125;void display_correct()//显示密码正确打开&#123; shumaguan_control(0,0); shumaguan_control(4,0); shumaguan_control(5,19); shumaguan_control(6,18); shumaguan_control(7,20);&#125;void Init()//矩阵按键配置&#123; R1=R2=R3=R4=1; C1=C2=C3=C4=1;&#125;void key_fun1(x)//第一行按键表示的数字&#123; switch(count) &#123; case 0: key[0]=x; break; case 1: key[1]=key[0]; key[0]=x; break; case 2: key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 3: key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 4: key[4]=key[3]; key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 5: key[5]=key[4]; key[4]=key[3]; key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; default: ; &#125;&#125;void key_fun2(x)//第二行表示的数字&#123; switch(count) &#123; case 0: key[0]=x; break; case 1: key[1]=key[0]; key[0]=x; break; case 2: key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 3: key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 4: key[4]=key[3]; key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 5: key[5]=key[4]; key[4]=key[3]; key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; default: ; &#125;&#125;void key_fun3(x)//第三行表示的数字&#123; switch(count) &#123; case 0: key[0]=x; break; case 1: key[1]=key[0]; key[0]=x; break; case 2: key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 3: key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 4: key[4]=key[3]; key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; case 5: key[5]=key[4]; key[4]=key[3]; key[3]=key[2]; key[2]=key[1]; key[1]=key[0]; key[0]=x; break; default: ; &#125;&#125;void Scan_keys1()//扫描第一行，记得按键一定要防抖&#123; C1 = C2 = C4 = 1; if(C1 == 0) &#123; delay_ms(50); if(C1 == 0) &#123; if(R1==0) key_fun1(S7); count++; &#125; while(C1 == 0); &#125; else if(C2 == 0) &#123; delay_ms(50); if(C2 == 0) &#123; if(R1==0) key_fun1(S11); count++; &#125; while(C2 == 0); &#125; else if(C3 == 0) &#123; delay_ms(50); if(C3 == 0) &#123; if(R1==0) key_fun1(S15); count++; &#125; while(C3 == 0); &#125; else if(C4 == 0) &#123; delay_ms(50); if(C4 == 0) &#123; if(R1==0) key_fun1(S19); count++; &#125; while(C4 == 0); &#125;&#125;void Scan_keys2()//扫描第二行&#123; C1 = C2 = C3 = C4 = 1; if(C1 == 0) &#123; delay_ms(50); if(C1 == 0) &#123; if(R2==0) key_fun2(S6); count++; &#125; while(C1 == 0); &#125; else if(C2 == 0) &#123; delay_ms(50); if(C2 == 0) &#123; if(R2==0) key_fun2(S10); count++; &#125; while(C2 == 0); &#125; else if(C3 == 0) &#123; delay_ms(50); if(C3 == 0) &#123; if(R2==0) key_fun2(S14); count++; &#125; while(C3 == 0); &#125; else if(C4 == 0) &#123; delay_ms(50); if(C4 == 0) &#123; if(R2==0) key_fun2(S18); count++; &#125; while(C4 == 0); &#125;&#125;void Scan_keys3()//扫描第三行&#123; C1 = C2 = C4 = 1; if(C1 == 0) &#123; delay_ms(50); if(C1 == 0) &#123; if(R3==0) key_fun3(S5); count++; &#125; while(C1 == 0); &#125; else if(C2 == 0) &#123; delay_ms(50); if(C2 == 0) &#123; if(R3==0) key_fun3(S9); count++; &#125; while(C2 == 0); &#125; else if(C3 == 0) &#123; delay_ms(50); if(C3 == 0) &#123; P2=0x00; &#125; while(C3 == 0); &#125; else if(C4 == 0) &#123; delay_ms(50); if(C4 == 0) &#123; P2=0x00; &#125; while(C4 == 0); &#125;&#125;void Scan_keys4()//扫描第四行&#123; C1 = C2 = C3 = C4 = 1; if(C1 == 0) &#123; delay_ms(50); if(C1 == 0) &#123; &#125; while(C1 == 0); &#125; else if(C2 == 0) &#123; delay_ms(50); if(C2 == 0) &#123; if(R4==0) &#123; display_input_minus(); &#125; &#125; while(C2 == 0); &#125; else if(C3==0) &#123; while(C3 == 0); &#125; else if(C4==0) &#123; delay_ms(50); if(C4 == 0) &#123; if(R4==0) &#123; if(key[0]==password[0]&amp;&amp;key[1]==password[1]&amp;&amp;key[2]==password[2]&amp;&amp;key[3]==password[3]&amp;&amp;key[4]==password[4]&amp;&amp;key[5]==password[5])//判定代码正确，每一位都相等 &#123; int i=500;//延时5s while(--i) &#123; display_correct(); if(C3==0)//如果S12按下，进入编辑状态 &#123; delay_ms(50); R1=R2=R3=1; if(C3==0) &#123; display_input_minus(); while(1) &#123; edit_fun(); if(C3==0) &#123; write_password();//写入eeprom密码 delay_ms(10); read_password();//读取eeprom密码 break; &#125; &#125; while(C3==0); &#125; &#125; display_input_minus(); &#125; &#125; else //如果密码不正确，清零等5s跳出循环 &#123; display_input_minus(); while(1) &#123; P2=0x80;P0=0xfe; delay_ms(5000); break; &#125; &#125; &#125; &#125; while(C4 == 0); &#125;&#125;void Start()//开始进入输入状态&#123; R4=0; if(C4 == 0&amp;&amp;R4==0)//按下S16进入输入状态，且不能影响其他的行的电平，就只能这么判断 &#123; delay_ms(50); if(C4 == 0&amp;&amp;R4==0) &#123; while(C4 == 0); while(1) &#123; Init(); input_fun(); &#125; &#125; &#125;&#125;void input_fun()//输入模式&#123; R1=0; Scan_keys1(); R2=0; Scan_keys2(); R3=0; Scan_keys3(); R4=0; Scan_keys4(); display_input();&#125;void edit_fun()//编辑模式&#123; R1=0; R2=R3=R4=1; Scan_keys1(); R2=0; R1=R3=R4=1; Scan_keys2(); R3=0; R1=R2=R4=1; Scan_keys3(); R4=0; R1=R2=R3=1; Scan_keys4(); display_edit();&#125;void main()//主函数&#123; while(1) &#123; allinit(); Init(); Start(); &#125;&#125; 写的过程中最大的感觉就是拆东墙补西墙，哪有bug就解决，效率低的不行，但没办法，毕竟也是第一次自己写，慢点就慢点吧，问题最大的就是矩阵按键研究不明白，说白了还是对于原理不熟悉，先歇几天，后面几届过几天在做。如果有问题评论区留言就ok，本人网上冲浪选手，天天上线，看到了就一定回复，因为main里面还有几个函数是我自己写的.h里面的，可能没放进去。如果有bug，直接评论就行","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯第十三届模拟题03——源代码","slug":"蓝桥杯第十三届模拟题03——源代码","date":"2022-04-08T15:00:22.000Z","updated":"2023-03-24T05:22:49.458Z","comments":true,"path":"2022/04/08/蓝桥杯第十三届模拟题03——源代码/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/08/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%A8%A1%E6%8B%9F%E9%A2%9803%E2%80%94%E2%80%94%E6%BA%90%E4%BB%A3%E7%A0%81/","excerpt":"","text":"还有几小时比赛了，做个模拟练练手感 先看原题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280#include &quot;reg51.h&quot;#include &quot;absacc.h&quot;#include &quot;intrins.h&quot;#define uchar unsigned char#define uint unsigned int sbit TX = P1^0;sbit RX = P1^1;//矩阵按键配置sbit R1=P3^0;//第一排初始化（如果跳线帽模式是BTN，则只有最左侧一列能用）sbit R2=P3^1;//第二排初始化sbit R3=P3^2;//第三排初始化sbit R4=P3^3;//第四排初始化sbit C1=P4^4;//第一列初始化sbit C2=P4^2;//第二列初始化sbit C3=P3^5;//第三列初始化sbit C4=P3^4;//第四列初始化sbit Buzz=P0^6;//蜂鸣器unsigned int distance = 0;uchar mode;uchar mode_k;uint high=50;uint low=0;uchar count_b;uchar mode_led;//////////////////////////// 0 1 2 3 4 5 6 7 8 9 - 全灭 .unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff,0x7f&#125;;/////////////////////////// A b C d E F H L P U nunsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1,0xc8&#125;;//////////////////////////// 0 1 2 3 4 5 6 7 unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;////////////////////////// 1 2 3 4 5 6 7 8 灭unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff&#125;;void delay_ms(int ms)&#123; int q,w; for(q=0;q&lt;ms;q++) &#123; for(w=845;w&gt;0;w--); &#125;&#125; void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125;//数码管字母显示void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125;void Init_Keys()&#123; R1=R2=R3=R4=1; C1=C2=C3=C4=1;&#125; void Init_timer0()//定时器配置 &#123; TMOD = 0x01; TH0 = (65535 - 50000) / 256; //50ms技术 TL0 = (65535 - 50000) % 256; EA = 1; ET0 = 1; TR0 = 1; &#125;void Service_timer0() interrupt 1//定时器0，中断&#123; count_b++;//全局变量 if(count_b==4)//计算了1s &#123; count_b=0; if(mode_led==0)//mode_smg也是全局变量 &#123; mode_led=1; &#125; else if(mode_led==1) &#123; mode_led=0; &#125; &#125;&#125;void L3_blink()//显示小时以1s的间隔显示一次&#123; if(mode_led==1) &#123; ledlight(2); &#125; if(mode_led==0) &#123; ledlight(8); &#125;&#125;void display_d()&#123; if(distance == 999) &#123; shumaguan_zimu(0,5); //超出测量范围标志：F &#125; else &#123; shumaguan_shuzi(5, distance / 100); shumaguan_shuzi(5,12); shumaguan_shuzi(6, (distance % 100) / 10); shumaguan_shuzi(7, distance % 10); &#125; P2=0x80; P0=0x00;&#125; void Delay12us() //@12.000MHz 延时12us&#123; unsigned char i; _nop_(); _nop_(); i = 33; while (--i);&#125; void Send_Wave() //产生8个40KHx超声波信号&#123; unsigned char i; for(i = 0; i &lt; 8; i++) &#123; TX = 1; Delay12us(); TX = 0; Delay12us(); &#125;&#125; void Measure_Distance() //超声波测距&#123; unsigned int time = 0; TMOD &amp;= 0x0f; //定时器1模式0，13位，最大8192个计数脉冲 TL1 = 0x00; TH1 = 0x00; Send_Wave(); //发送超声波信号 TR1 = 1; //启动定时器 while((RX == 1) &amp;&amp; (TF1 == 0)); //等待超声波信号返回或者等到测量超出范围 TR1 = 0; //停止定时器 if(TF1 == 0) //正常测量范围 &#123; time = TH1; time = (time &lt;&lt; 8) | TL1; distance = ((time / 10) * 17) / 100 + 3; &#125; else //超出测量范围 &#123; TF1 = 0; distance = 999; &#125;&#125;void display_h()&#123; mode_k=0; shumaguan_zimu(0,9); shumaguan_shuzi(6,high/10); shumaguan_shuzi(7,high%10); ledlight(0);&#125;void display_l()&#123; mode_k=1; shumaguan_zimu(0,10); shumaguan_shuzi(6,low/10); shumaguan_shuzi(7,low%10); ledlight(1);&#125;void select_mode()&#123; switch(mode) &#123; case(0):display_d();break; case(1):display_h();break; case(2):display_l();break; &#125;&#125;void alarm()&#123; if(distance&lt;=low||distance&gt;=high) &#123; P2 = ((P2 &amp; 0x1F) | 0xA0); Buzz=1; L3_blink(); &#125; else &#123; P2 = ((P2 &amp; 0x1F) | 0xA0); Buzz=0; &#125;&#125;void Scan_S4()&#123; R1=1;R2=1;R3=1;R4=0; C2=1;C3=1;C4=1; if(C1==0) &#123; while(C1==0); mode++; if(mode==3) mode=0; &#125;&#125;void Scan_S8()&#123; R1=1;R2=1;R3=1;R4=0; C3=1;C4=1;C1=1; if(C2==0) &#123; while(C2==0); if(mode_k==0) &#123; high=high+10; &#125; if(mode_k==1) &#123; low=low+10; &#125; &#125;&#125;void Scan_S12()&#123; R1=1;R2=1;R3=1;R4=0; C4=1;C1=1;C2=1; if(C3==0) &#123; while(C3==0); if(mode_k==0) &#123; high=high-10; &#125; if(mode_k==1) &#123; low=low-10; &#125; &#125;&#125;void main()&#123; Init_Keys(); Init_timer0(); while(1) &#123; Measure_Distance(); select_mode(); Scan_S12(); Scan_S8(); Scan_S4(); alarm(); &#125;&#125;","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机第十三届模拟题01——源代码","slug":"蓝桥杯单片机第十三届模拟题01——源代码","date":"2022-04-08T01:30:13.000Z","updated":"2023-03-24T01:10:45.586Z","comments":true,"path":"2022/04/08/蓝桥杯单片机第十三届模拟题01——源代码/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/08/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%A8%A1%E6%8B%9F%E9%A2%9801%E2%80%94%E2%80%94%E6%BA%90%E4%BB%A3%E7%A0%81/","excerpt":"","text":"还有一天比赛了，先看原题 很简单，感觉就是前几届不常考的考点，注意那个L10操作 MAIN.C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371#include&lt;reg51.h&gt;#include&lt;ds1302.h&gt;#include&lt;onewire.h&gt;#define uchar unsigned char#define uint unsigned intunsigned char TIME_buffer2[7];unsigned char TIME_buffer1[7];unsigned char TIME_buffer[7];uchar mode;int temp;uchar shi;uchar ge;uchar shi_p;uchar ge_p;int temp2;uchar count; uchar count_a;//////////////////////////// 0 1 2 3 4 5 6 7 8 9 - 全灭 .unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff,0x7f&#125;;/////////////////////////// A b C d E F H L P U nunsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1,0xc8&#125;;//////////////////////////// 0 1 2 3 4 5 6 7 unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;////////////////////////// 1 2 3 4 5 6 7 8 灭unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff&#125;;unsigned char code WRITE_RTC_ADDR[7] = &#123;0x80,0x82,0x84,0x86,0x88,0x8a,0x8c&#125;; //定义写操作的日历时钟寄存器地址unsigned char code READ_RTC_ADDR[7] = &#123;0x81,0x83,0x85,0x87,0x89,0x8b,0xbd&#125;; //定义读操作的日历时钟寄存器地址unsigned char TIME[7] = &#123;0x00,0x00,0x12,0x18,0x02,0x02,0x20&#125;; //定义日历时钟寄存器配置参数(秒、分、时、日、月、星期、年)unsigned char code SEG_code[18] = &#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8, 0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e, 0xbf,0x7f&#125;; //定义共阳数码管段码内容:0~F,—,. sbit R1=P3^0;sbit R2=P3^1;sbit R3=P3^2;sbit R4=P3^3; sbit Relay= P0^4; //继电器sbit Buzz=P0^6;//蜂鸣器void delay_ms(int ms)&#123; int q,w; for(q=0;q&lt;ms;q++)&#123; for(w=845;w&gt;0;w--); &#125;&#125;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125;void DS1302_Config()&#123; unsigned char n; Write_Ds1302_Byte(0x8e,0x00); //允许向内存写入数据 for(n=0;n&lt;7;n++) &#123; Write_Ds1302_Byte(WRITE_RTC_ADDR[n],TIME[n]); //低位先写 &#125; Write_Ds1302_Byte(0x8e,0x80); //禁止向内存写入数据&#125;void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125;//数码管字母显示void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125;void timer0() //定时模式&#123; ET0=1; EA=1; TMOD &amp;= 0xF0; TH0 = (65535-50000)/256;//50000us=50ms TL0 = (65535-50000)%256; TF0 = 1; TR0 = 1;&#125;//数字时钟，需要重装载void Service_timer0() interrupt 1//定时器0&#123; TH0 = (65535-50000)/256;//50000us=50ms TL0 = (65535-50000)%256; count++; if(count==20) &#123; count=0; count_a++; &#125; &#125;//读取实时时间void DS1302_ReadTime()&#123; unsigned char n; for(n=0;n&lt;7;n++) &#123; TIME_buffer[n]=TIME[n]; &#125; for(n=0;n&lt;7;n++) &#123; TIME[n] = Read_Ds1302_Byte(READ_RTC_ADDR[n]); &#125;&#125;//数码管延时函数void Delay_tube(unsigned char t)&#123; while(t--);&#125;//数码管显示void Show_tube(unsigned char position,unsigned char value)&#123; P2 = (P2 &amp; 0x1f) | 0xc0;//数码管的片选端 P0 = 0x01 &lt;&lt; position; P2 = (P2 &amp; 0x1f) | 0xe0;//数码管的数据 P0 = value;&#125;//数码管动态显示void Display_tube()&#123; Show_tube(0,SEG_code[TIME_buffer[2]/16]); //显示时的十位(TIME[n]为16进制数，所以除以16) Delay_tube(500); Show_tube(1,SEG_code[TIME_buffer[2]%16]); //显示时的个位 Delay_tube(500); Show_tube(2,SEG_code[16]); //显示分隔符 Delay_tube(500); Show_tube(3,SEG_code[TIME_buffer[1]/16]); //显示分的十位 Delay_tube(500); Show_tube(4,SEG_code[TIME_buffer[1]%16]); //显示分的个位 Delay_tube(500); Show_tube(5,SEG_code[16]); //显示分隔符 Delay_tube(500); Show_tube(6,SEG_code[TIME_buffer[0]/16]); //显示秒的十位 Delay_tube(500); Show_tube(7,SEG_code[TIME_buffer[0]%16]); //显示秒的个位 Delay_tube(500); P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f; &#125;void jisuan()&#123;if(TIME_buffer[2]==10)&#123; TIME_buffer2[2]=0; TIME_buffer1[2]++; TIME_buffer[2]=TIME_buffer1[2]&lt;&lt;4|(TIME_buffer2[2]&amp;0x0f);//0x10&#125; if(TIME_buffer[2]==0x1a) &#123; TIME_buffer2[2]=0; TIME_buffer1[2]++; TIME_buffer[2]=TIME_buffer1[2]&lt;&lt;4|(TIME_buffer2[2]&amp;0x0f); &#125; if(TIME_buffer[2]==0x24) &#123; TIME_buffer2[2]=0; TIME_buffer1[2]=0; TIME_buffer[2]=0; &#125; if(TIME_buffer[1]==10)&#123; TIME_buffer2[1]=0; TIME_buffer1[1]++; TIME_buffer[1]=TIME_buffer1[1]&lt;&lt;4|(TIME_buffer2[1]&amp;0x0f);//0x10&#125; if(TIME_buffer[1]==0x1a) &#123; TIME_buffer2[1]=0; TIME_buffer1[1]++; TIME_buffer[1]=TIME_buffer1[1]&lt;&lt;4|(TIME_buffer2[1]&amp;0x0f); &#125; if(TIME_buffer[1]==0x2a) &#123; TIME_buffer2[1]=0; TIME_buffer1[1]++; TIME_buffer[1]=TIME_buffer1[1]&lt;&lt;4|(TIME_buffer2[1]&amp;0x0f); &#125; if(TIME_buffer[1]==0x3a) &#123; TIME_buffer2[1]=0; TIME_buffer1[1]++; TIME_buffer[1]=TIME_buffer1[1]&lt;&lt;4|(TIME_buffer2[1]&amp;0x0f); &#125; if(TIME_buffer[1]==0x4a) &#123; TIME_buffer2[1]=0; TIME_buffer1[1]++; TIME_buffer[1]=TIME_buffer1[1]&lt;&lt;4|(TIME_buffer2[1]&amp;0x0f); &#125; if(TIME_buffer[1]==0x5a) &#123; TIME_buffer2[1]=0; TIME_buffer1[1]=0; TIME_buffer[1]=0; &#125; &#125;void display_ds1302()//显示ds1302的时钟&#123; DS1302_ReadTime(); Display_tube(); ledlight(0);&#125;void Init_Keys()&#123; R1=R2=R3=R4=1;&#125;void temperature_get()&#123; uchar high,low; init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0x44); init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=((high&lt;&lt;4)|(low&gt;&gt;4));//不带小数点，注掉后面一行就行 temp2=low&amp;0x0f*100/16;//取小数点两位,注掉上面一行就行 shi=temp%100/10;//不带小数点 ge=temp%10; shi_p=temp2/10;//带两位小数点 ge_p=temp%10;&#125;void display_temp()&#123; shumaguan_zimu(0,2); shumaguan_shuzi(5,shi); shumaguan_shuzi(6,ge); shumaguan_shuzi(6,12);//显示小数点 shumaguan_shuzi(7,ge_p); ledlight(1);&#125;void select_mode()&#123; switch(mode) &#123; case(0):display_ds1302();break; case(1):temperature_get();display_temp();break; &#125;&#125;void Scan_S4()&#123; if(R4==0) &#123; while(R4==0); mode++; if(mode&gt;1) mode=0; &#125;&#125;void Scan_S5()&#123; uchar n; if(R3==0) &#123; while(R3==0)display_ds1302(); TIME_buffer[2]++; jisuan(); Write_Ds1302_Byte(0x8e,0x00); //允许向内存写入数据 for(n=0;n&lt;7;n++) &#123; Write_Ds1302_Byte(WRITE_RTC_ADDR[n],TIME_buffer[n]); //低位先写 &#125; Write_Ds1302_Byte(0x8e,0x80); //禁止向内存写入数据 &#125;&#125;void Scan_S6()&#123; uchar n; if(R2==0) &#123; while(R2==0)display_ds1302(); TIME_buffer[1]++; jisuan(); Write_Ds1302_Byte(0x8e,0x00); //允许向内存写入数据 for(n=0;n&lt;7;n++) &#123; Write_Ds1302_Byte(WRITE_RTC_ADDR[n],TIME_buffer[n]); //低位先写 &#125; Write_Ds1302_Byte(0x8e,0x80); //禁止向内存写入数据 &#125;&#125;void Scan_S7()&#123; uchar n; if(R1==0) &#123; while(R1==0) display_ds1302(); TIME_buffer[0]=0; Write_Ds1302_Byte(0x8e,0x00); //允许向内存写入数据 for(n=0;n&lt;7;n++) &#123; Write_Ds1302_Byte(WRITE_RTC_ADDR[n],TIME_buffer[n]); //低位先写 &#125; Write_Ds1302_Byte(0x8e,0x80); //禁止向内存写入数据 &#125;&#125;void alarm()&#123; if(TIME_buffer[0]==0x00&amp;&amp;TIME_buffer[1]==0x00) &#123; P2=0xA0;Relay=1;Buzz=0; &#125;else if(count_a%3==0) &#123; P2=0xA0;Relay=0;Buzz=0; &#125;&#125;void main()&#123; Init_Keys(); DS1302_Config(); timer0(); while(1) &#123; temperature_get(); Scan_S7(); Scan_S6(); Scan_S5(); Scan_S4(); select_mode(); alarm(); &#125;&#125; 写复杂了，大家主要看思路简化","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机第十二届省赛第二批——源码及设计思路","slug":"蓝桥杯单片机第十二届省赛第二批——源码及设计思路","date":"2022-04-05T10:14:49.000Z","updated":"2023-03-24T01:10:15.539Z","comments":true,"path":"2022/04/05/蓝桥杯单片机第十二届省赛第二批——源码及设计思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%9C%81%E8%B5%9B%E7%AC%AC%E4%BA%8C%E6%89%B9%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"","text":"距离比赛还有15天，昨天发愤图强，想做一个练练手，又想到了第十二届的第二批没有写，然后在同专业大佬的帮助下，在一天做完了一届，速度最快的一次了，废话不多说，先看原题 设计思路 第一眼看真是没什么特别难的感觉，就是一个长按键还没有想到解决方法，先从四个按键入手，S4按键切换三个模式，一开始我用的是递归，在四个while循环，直接把整个程序写死在一个函数里面了，也是迫不得已，当时也没想出什么好方法，S5是电压模式切换，这个就是两个模式切换，简单，S6是读取电压值，一看到保存数据，我直接写了个eeprom，后来一想，没必要那么麻烦，直接保存在一个中间变量进行比较就好，S7也是一样的思路。 到了LED的部分，这个一开始我把所有的LED都写到数码管显示的函数里面了，但是注意了，长按S7是可以关闭LED的，但是关闭LED不影响数码管，这就看出来我的代码有很大问题了，所以要记住，LED一定不要和数码管显示放在一个函数里面。 关于长按怎么做，我这里是大佬教我的，用的定时器2，计时1ms，使变量count_led++,如果count_led=1000后，计时1s，把count_led置为0，然后另一个变量，设一个新变量count_S7每1s自加1，这样的话，定时器中断就设置完毕了，接下来就是S7的长按功能，当S7被按下后，使count_led和count_S7都置0，接下来就进行判断，如果count_S7&gt;=1，判断灯的状态，我们设变量aaa灯亮aaa为0，灯灭aaa为1，如果aaa&lt;1则aaa++，把灯灭掉，else aaa=0，让灯亮，这就实现了长按，看文字描述还是不是很懂，要看代码才行。 源代码 IIC.C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &quot;reg52.h&quot;#include &quot;intrins.h&quot;#define DELAY_TIME 5#define SlaveAddrW 0xA0#define SlaveAddrR 0xA1sbit SDA = P2^1; sbit SCL = P2^0; void IIC_Delay(unsigned char i)&#123; do&#123;_nop_();&#125; while(i--); &#125;void IIC_Start(void)&#123; SDA = 1; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 0; IIC_Delay(DELAY_TIME); SCL = 0; &#125;void IIC_Stop(void)&#123; SDA = 0; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 1; IIC_Delay(DELAY_TIME);&#125;void IIC_SendAck(bit ackbit)&#123; SCL = 0; SDA = ackbit; IIC_Delay(DELAY_TIME); SCL = 1; IIC_Delay(DELAY_TIME); SCL = 0; SDA = 1; IIC_Delay(DELAY_TIME);&#125;bit IIC_WaitAck(void)&#123; bit ackbit; SCL = 1; IIC_Delay(DELAY_TIME); ackbit = SDA; SCL = 0; IIC_Delay(DELAY_TIME); return ackbit;&#125;void IIC_SendByte(unsigned char byt)&#123; unsigned char i; for(i=0; i&lt;8; i++) &#123; SCL = 0; IIC_Delay(DELAY_TIME); if(byt &amp; 0x80) SDA = 1; else SDA = 0; IIC_Delay(DELAY_TIME); SCL = 1; byt &lt;&lt;= 1; IIC_Delay(DELAY_TIME); &#125; SCL = 0; &#125;unsigned char IIC_RecByte(void)&#123; unsigned char i, da; for(i=0; i&lt;8; i++) &#123; SCL = 1; IIC_Delay(DELAY_TIME); da &lt;&lt;= 1; if(SDA) da |= 1; SCL = 0; IIC_Delay(DELAY_TIME); &#125; return da; &#125; MAIN.C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399#include&lt;reg51.h&gt;#include&lt;iic.h&gt;#include&lt;intrins.h&gt;#define uchar unsigned char#define uint unsigned int sfr AUXR = 0x8e; sfr T2H = 0xD6; sfr T2L = 0xD7; sfr IE2 = 0xAF; sbit R1=P3^0;sbit R2=P3^1;sbit R3=P3^2;sbit R4=P3^3;unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff&#125;;unsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1,0xc8&#125;;unsigned char code num[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90&#125;;unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff&#125;;unsigned int count_f = 0;unsigned char count_t = 0;unsigned int dat_f = 0;//频率数值unsigned int dat_term = 0;//周期数值unsigned char S5_mode=4;uchar mode;uint count_led=0;uint count_S7=0;uint voltage_temp;//存电压的中间变量uint fre_temp;//存频率的中间变量uchar i=0;uchar j=0;int voltage_rd1;//rd1的电压值int dat_rd1;//rd1的数值int voltage_rb2;//rb2的电压值int dat_rb2;//rb2的数值uchar aaa=0;//灯的状态void led_0();void Scan_S7();void led_fun();void Scan_S4();void Scan_S5();void Scan_S6();void delay_ms(int ms)&#123; int q,w; for(q = 0;q&lt;ms;q++)&#123; for(w=845;w&gt;0;w--); &#125;&#125;void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1);&#125;void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1);&#125;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125;void Init()&#123; R1=R2=R3=R4=1;&#125;void Init_Timer()&#123; TH0 = 0xff; TL0 = 0xff; TH1 = (65536 - 50000) / 256; TL1 = (65536 - 50000) % 256; TMOD = 0x16; ET0 = 1; ET1 = 1; EA = 1; TR0 = 1; TR1 = 1;&#125;void Timer2(void)&#123; T2H = (65535-1000)/256; T2L = (65535-1000)%256; EA = 1; IE2 |=0x04; AUXR|=0x10; &#125;void Service_T12() interrupt 12&#123; T2H = (65535-1000)/256; T2L = (65535-1000)%256; if(count_led==1000) &#123; count_led=0; count_S7++; &#125; else count_led++;&#125;void Service_T0() interrupt 1&#123; count_f++;&#125; void Service_T1() interrupt 3&#123; TH1 = (65536 - 50000) / 256; TL1 = (65536 - 50000) % 256; count_t++; if(count_t == 20) &#123; dat_f = count_f; count_f = 0; count_t = 0; &#125;&#125;void display_f()&#123; mode=0; shumaguan_zimu(0,5); if(dat_f&gt;9999) shumaguan_shuzi(3,dat_f/10000); if(dat_f&gt;999) shumaguan_shuzi(4,dat_f/1000%10); if(dat_f&gt;99) shumaguan_shuzi(5,dat_f/100%10); if(dat_f&gt;9) shumaguan_shuzi(6,dat_f/10%10); shumaguan_shuzi(7,dat_f%10); &#125;void display_term()&#123; mode=1; shumaguan_zimu(0,10); dat_term=1000000/dat_f; if(dat_f&gt;9999) shumaguan_shuzi(3,dat_term/1000); if(dat_f&gt;999) shumaguan_shuzi(4,dat_term/1000%10); if(dat_f&gt;99) shumaguan_shuzi(5,dat_term/100%10); if(dat_f&gt;9) shumaguan_shuzi(6,dat_term/10%10); shumaguan_shuzi(7,dat_term%10);&#125;void display_RD1()&#123; mode=2; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(0x01); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); dat_rd1 = IIC_RecByte(); IIC_WaitAck(); IIC_Stop(); voltage_rd1=dat_rd1*100/51; shumaguan_zimu(0,9); shumaguan_shuzi(1,10); shumaguan_shuzi(2,1); shumaguan_shuzi(6,voltage_rd1%100/10); shumaguan_shuzi(7,voltage_rd1%10); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[5]; P2=(P2&amp;0X1f)|0xFF;P0=shuzi[voltage_rd1/100]+0x80;&#125;void display_Rb2()&#123; mode=3; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(0x03); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); dat_rb2 = IIC_RecByte(); IIC_WaitAck(); IIC_Stop(); voltage_rb2=dat_rb2*100/51; shumaguan_zimu(0,9); shumaguan_shuzi(1,10); shumaguan_shuzi(2,3); shumaguan_shuzi(6,voltage_rb2%100/10); shumaguan_shuzi(7,voltage_rb2%10); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[5]; P2=(P2&amp;0X1f)|0xFF;P0=shuzi[voltage_rb2/100]+0x80;&#125;void Scan_S4()&#123; if(R4==0) &#123; while(R4==0)&#123;display_term();&#125; while(1) &#123; led_fun(); Scan_S7(); display_term(); if(R4==0) &#123; if(R4==0) &#123; while(R4==0)&#123;display_RD1();&#125; while(1) &#123; led_fun(); Scan_S7(); display_RD1(); Scan_S5(); if(R4==0) &#123; delay_ms(60); if(R4==0) &#123; while(R4==0)&#123;display_f();&#125; while(1) &#123; led_fun(); Scan_S7(); display_f(); if(R4==0) &#123; if(R4==0) &#123; while(R4==0)&#123;Scan_S4();&#125; while(1) &#123; Scan_S4(); &#125; &#125; &#125; while(R4==0); &#125; while(R4==0); &#125; &#125; while(R4==0); &#125; while(R4==0); &#125; &#125; while(R4==0); &#125; while(R4==0); &#125; &#125;void Scan_S5()&#123; if(R3==0) &#123; delay_ms(10); if(R3==0) &#123; S5_mode++; while(R3==0); &#125; &#125; if(S5_mode%2==0) &#123; display_RD1(); &#125; if(S5_mode%2==1) &#123; while(1) &#123; led_fun(); Scan_S7(); Scan_S6(); display_Rb2(); if(R3==0) &#123; delay_ms(10); if(R3==0) &#123; break; while(R3==0); &#125; &#125; &#125; &#125;&#125;void Scan_S6()&#123; if(R2==0) &#123; delay_ms(50); if(R2==0) &#123; voltage_temp=voltage_rb2; while(R2==0); &#125;&#125;&#125;void Scan_S7()&#123; if(R1==0) &#123; count_S7=0; count_led=0; while(R1==0); if(count_S7&gt;=1) &#123;if(aaa&lt;1) aaa++;else aaa=0;&#125; else &#123; fre_temp=dat_f; &#125;&#125;&#125;void led_fun()&#123; if(aaa==0) &#123; if(mode==0) &#123; if(dat_f&gt;fre_temp) &#123; P2=(P2&amp;0X1f)|0x80; P0=0xf9; &#125; else ledlight(2); &#125; if(mode==1) &#123; ledlight(3); &#125; if(mode==2) &#123; ledlight(4); &#125; if(mode==3) &#123; if(voltage_rb2&gt;voltage_temp) &#123; P2=(P2&amp;0X1f)|0x80; P0=0xee; &#125; else ledlight(4); &#125;&#125; if(aaa==1) &#123; P2=0x80;P0=0xff; &#125;&#125;void main()&#123; Init_Timer(); Timer2(); Init(); while(1) &#123; led_fun(); Scan_S7(); Scan_S6(); Scan_S4(); display_f(); &#125;&#125; 总体来说，就是长按键那里有点让人懵，剩下的部分还是很简单的。","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机第十三届省赛模拟冲刺02——源码及设计思路","slug":"蓝桥杯单片机第十三届省赛模拟冲刺02——源码及设计思路","date":"2022-04-05T03:35:03.000Z","updated":"2023-03-24T01:10:53.685Z","comments":true,"path":"2022/04/05/蓝桥杯单片机第十三届省赛模拟冲刺02——源码及设计思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F%E5%86%B2%E5%88%BA02%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"","text":"最近几天闲着没事干，刷动态的时候，看到了十三届的模拟题，然后就去搜了搜，题目来源@电子设计工坊，我是从博主@slow_walker看到的题目，原blog的链接：https://blog.csdn.net/boybs/article/details/123829667 先看题目吧： 刚看的时候，感觉还是很简单的，没有乱七八糟的显示模式切换，也就用到了eeprom和PCF8591，后来往下仔细看，发现了长按键，我心态直接崩了，虽然之前十二届第二批的时候，做过长按键，但是是在大佬的帮助下，才做出来的，现在要自己做，心里总是害怕，做了三天，到最后还是做出来了，跟之前的第十二届第二批其实是一个思路，利用定时器，使一个数字每1s自加一次，然后再去判断。 但是另外一点我没有想到的是，在题目中，要求按下S8不触发储存功能，这个我思考了好久，其实就是需要引入一个中间变量，把eeprom显示界面的数值，赋值给他就好了，先看源代码吧。 IIC.C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* 程序说明: IIC总线驱动程序 软件环境: Keil uVision 4.10 硬件环境: CT107单片机综合实训平台 8051，12MHz 日 期: 2011-8-9*/#include &quot;reg52.h&quot;#include &quot;intrins.h&quot;#define DELAY_TIME 5#define SlaveAddrW 0xA0#define SlaveAddrR 0xA1//总线引脚定义sbit SDA = P2^1; /* 数据线 */sbit SCL = P2^0; /* 时钟线 */void IIC_Delay(unsigned char i)&#123; do&#123;_nop_();&#125; while(i--); &#125;//总线启动条件void IIC_Start(void)&#123; SDA = 1; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 0; IIC_Delay(DELAY_TIME); SCL = 0; &#125;//总线停止条件void IIC_Stop(void)&#123; SDA = 0; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 1; IIC_Delay(DELAY_TIME);&#125;//发送应答void IIC_SendAck(bit ackbit)&#123; SCL = 0; SDA = ackbit; // 0：应答，1：非应答 IIC_Delay(DELAY_TIME); SCL = 1; IIC_Delay(DELAY_TIME); SCL = 0; SDA = 1; IIC_Delay(DELAY_TIME);&#125;//等待应答bit IIC_WaitAck(void)&#123; bit ackbit; SCL = 1; IIC_Delay(DELAY_TIME); ackbit = SDA; SCL = 0; IIC_Delay(DELAY_TIME); return ackbit;&#125;//通过I2C总线发送数据void IIC_SendByte(unsigned char byt)&#123; unsigned char i; for(i=0; i&lt;8; i++) &#123; SCL = 0; IIC_Delay(DELAY_TIME); if(byt &amp; 0x80) SDA = 1; else SDA = 0; IIC_Delay(DELAY_TIME); SCL = 1; byt &lt;&lt;= 1; IIC_Delay(DELAY_TIME); &#125; SCL = 0; &#125;//从I2C总线上接收数据unsigned char IIC_RecByte(void)&#123; unsigned char i, da; for(i=0; i&lt;8; i++) &#123; SCL = 1; IIC_Delay(DELAY_TIME); da &lt;&lt;= 1; if(SDA) da |= 1; SCL = 0; IIC_Delay(DELAY_TIME); &#125; return da; &#125; IIC.H 1234567891011#ifndef _IIC_H#define _IIC_Hvoid IIC_Start(void); void IIC_Stop(void); bit IIC_WaitAck(void); void IIC_SendAck(bit ackbit); void IIC_SendByte(unsigned char byt); unsigned char IIC_RecByte(void); #endif MAIN.C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317#include&lt;reg51.h&gt;#include&lt;iic.h&gt;#include&lt;intrins.h&gt;#define uchar unsigned char //矩阵按键配置sbit R1=P3^0;//第一排初始化（如果跳线帽模式是BTN，则只有最左侧一列能用）sbit R2=P3^1;//第二排初始化sbit R3=P3^2;//第三排初始化sbit R4=P3^3;//第四排初始化sbit C1=P4^4;//第一列初始化sbit C2=P4^2;//第二列初始化sbit C3=P3^5;//第三列初始化sbit C4=P3^4;//第四列初始化//////////////////////////// 0 1 2 3 4 5 6 7 8 9 - 全灭 .unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff,0x7f&#125;;/////////////////////////// A b C d E F H L P U nunsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1,0xc8&#125;;//////////////////////////// 0 1 2 3 4 5 6 7 unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;////////////////////////// 1 2 3 4 5 6 7 8 灭unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff&#125;;uchar count=0;//计数数值uchar count_z;//长按键判断值int n;//定时器1的自加值uchar num_re=0;//保存上一个值uchar led_b;uchar mode_led;uchar temp_num;void write_eeprom(unsigned char add,unsigned char date);unsigned char read_eeprom(unsigned char add);void ledlight(uchar x);void Init_Keys()//配置矩阵键盘&#123; R1=R2=R3=R4=1; C1=C2=C3=C4=1;&#125;void timer0() //定时模式&#123; ET0=1; EA=1; TMOD &amp;= 0xF0; TH0 = (65535-50000)/256;//50000us=50ms TL0 = (65535-50000)%256; TF0 = 1; TR0 = 1;&#125;void Service_timer0() interrupt 1//定时器0，实现长按键功能&#123; TH0 = (65535-50000)/256;//50000us=50ms TL0 = (65535-50000)%256; if(n==20) &#123; n=0; count_z++; &#125; else n++;&#125; //定时器1，定时1msvoid Timer1(void) //定时模式 &#123; TMOD &amp;= 0x0F; TL1 = (65535-20000)%256; TH1 = (65535-20000)/256; TF1 = 0; TR1 = 1; ET1 = 1;&#125;void Timer1_Service() interrupt 3//定时器1的定时模式，控制led闪烁&#123; uchar i; i++; if(i==10) &#123; i=0; led_b++; if(mode_led==0) &#123; mode_led=1; &#125; else if(mode_led==1) &#123; mode_led=0; &#125; &#125;&#125;void led_blink()&#123; if(mode_led==1) &#123; ledlight(1); &#125; if(mode_led==0) &#123; P2=(P2&amp;0X1f)|0x80; P0=0xff; &#125;&#125;//////延时1msvoid delay_ms(int ms)&#123; int q,w; for(q = 0;q&lt;ms;q++)&#123; for(w=845;w&gt;0;w--); &#125;&#125;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125;///数码管数字显示void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125;//数码管字母显示void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1); //消隐 P2 = (P2 &amp; 0x1f) | 0xc0; P0 = 0x00; P2 = P2 &amp; 0x1f;&#125;void display_count()//计数显示&#123; shumaguan_zimu(0,0); shumaguan_shuzi(5,count/100); shumaguan_shuzi(6,count%100/10); shumaguan_shuzi(7,count%10); ledlight(0); temp_num=num_re; &#125;void display_re()//显示eeprom读取的数据&#123; shumaguan_zimu(0,6); num_re=read_eeprom(0x00); shumaguan_shuzi(5,num_re/100); shumaguan_shuzi(6,num_re%100/10); shumaguan_shuzi(7,num_re%10); temp_num=num_re;&#125;void write_eeprom(unsigned char add,unsigned char date)//写入eepeom数据，前面是地址，后面是数据&#123; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_SendByte(date); IIC_WaitAck(); IIC_Stop();&#125;unsigned char read_eeprom(unsigned char add)//读eeprom，直接写出地址就能读,在read和write之间一定要间隔上delay&#123; unsigned char temp; EA = 0; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Start(); IIC_SendByte(0xa1); IIC_WaitAck(); temp = IIC_RecByte(); IIC_SendAck(1); IIC_WaitAck(); IIC_Stop(); EA = 1; return temp;&#125;void pcf8591_dac(char dat)//dac读取的是16进制数值&#123; EA=0; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(0x40); IIC_WaitAck(); IIC_SendByte(dat); IIC_WaitAck(); IIC_Stop(); EA=1;&#125;void Scan_S4()&#123; R4=0;R1=1;R2=1;R3=1; C2=1;C3=1;C4=1; if(C1==0&amp;&amp;R4==0) &#123; while(C1==0)display_count(); count++; &#125; &#125;void Scan_S5()&#123; R4=1;R1=1;R2=1;R3=0; C2=1;C3=1;C4=1; if(C1==0&amp;&amp;R3==0) &#123; while(C1==0)display_count(); count--; &#125;&#125;void Scan_S8()&#123; R4=0;R1=1;R2=1;R3=1; C1=1;C3=1;C4=1; if(C2==0&amp;&amp;R4==0) &#123; n=0; count_z=0; while(C2==0) display_count(); delay_ms(10); write_eeprom(0x00,count); delay_ms(10); while(C2==0)shumaguan_shuzi(0,count_z); if(count_z&gt;=2) &#123; count=0; delay_ms(10); write_eeprom(0x00,temp_num); delay_ms(10); &#125; &#125;&#125;void Scan_S9()&#123; uchar temp=4; R4=1;R1=1;R2=1;R3=0; C1=1;C3=1;C4=1; if(C2==0) &#123; while(C2==0); temp++; &#125; if(temp%2==0) &#123; display_count(); &#125; if(temp%2==1) &#123; while(1) &#123; display_re(); if(C2==0) &#123; while(C2==0); break; &#125; &#125; &#125;&#125;void judge()//判断读取的数值大小&#123; if(count%5==0) &#123; pcf8591_dac(255); &#125; else pcf8591_dac(51); if(count&gt;num_re) &#123; TR1=1; &#125; else if(count&lt;=num_re) &#123; TR1=0; &#125;&#125;void main()&#123; Init_Keys(); timer0(); Timer1(); while(1) &#123; Scan_S4(); Scan_S5(); Scan_S8(); Scan_S9(); judge(); led_blink(); display_count(); &#125;&#125; 还有4天比赛了，这几天不打算去做省赛题了，我打算先去看看客观题，客观题毕竟也占好多分。","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机第十二届第一批省赛题——源码及设计思路","slug":"蓝桥杯单片机第十二届第一批省赛题——源码及设计思路","date":"2022-03-31T07:10:57.000Z","updated":"2023-03-24T01:10:02.775Z","comments":true,"path":"2022/03/31/蓝桥杯单片机第十二届第一批省赛题——源码及设计思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/03/31/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E7%AC%AC%E4%B8%80%E6%89%B9%E7%9C%81%E8%B5%9B%E9%A2%98%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"","text":"今天距离比赛还有9天，想到了之前第十二届第一批做的乱七八糟，现在重新写一遍，果然是当初太笨了，现在再看感觉简单的不行，差不多两个小时就写完了，真的没什么特别难的地方，就是矩阵键盘那里需要注意。 先看原题 MAIN.C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309#include&lt;reg51.h&gt;#include&lt;iic.h&gt;#include&lt;onewire.h&gt;#define uchar unsigned char#define uint unsigned int sbit DQ = P1^4; //总线引脚定义sbit SDA = P2^1; /* 数据线 */sbit SCL = P2^0; /* 时钟线 */sbit R1=P3^0;//第一排初始化（如果跳线帽模式是BTN，则只有最左侧一列能用）sbit R2=P3^1;//第二排初始化sbit R3=P3^2;//第三排初始化sbit R4=P3^3;//第四排初始化sbit C1=P4^4;//第一列初始化sbit C2=P4^2;//第二列初始化sbit C3=P3^5;//第三列初始化sbit C4=P3^4;//第四列初始化//////////////////////////// 0 1 2 3 4 5 6 7 8 9 - 全灭 .unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff,0x7f&#125;;/////////////////////////// A b C d E F H L P U nunsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1,0xc8&#125;;//////////////////////////// 0 1 2 3 4 5 6 7 unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;////////////////////////// 1 2 3 4 5 6 7 8 灭unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff&#125;;//温度变量定义int temp;uchar shi;uchar ge;uchar shi_p;uchar ge_p;int temp2;//参数设置uchar temp_cs=25;//s5模式切换数值uchar mode_dac=0;//dac的输出数值int voltage;int dat;void Scan_S8();void Scan_S9();void Scan_S5();void judge_dac();//////延时1msvoid delay_ms(int ms)&#123; int q,w; for(q = 0;q&lt;ms;q++)&#123; for(w=845;w&gt;0;w--); &#125;&#125;///数码管数字显示void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1);&#125;//数码管字母显示void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1);&#125;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125;void Init_Keys()&#123; R1=R2=R3=R4=1; C1=C2=C3=C4=1;&#125;//DS18B20的配置void temperature_get()&#123; uchar high,low; init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0x44); init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=((high&lt;&lt;4)|(low&gt;&gt;4));//不带小数点，注掉后面一行就行 temp2=low&amp;0x0f*100/16;//取小数点两位,注掉上面一行就行 shi=temp%100/10; ge=temp%10; shi_p=temp2/10; ge_p=temp%10;&#125;void pcf8591_dac(char dat)//dac读取数值&#123; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(0x40); IIC_WaitAck(); IIC_SendByte(dat); IIC_WaitAck(); IIC_Stop(); &#125;void display_temp()&#123; shumaguan_zimu(0,2); shumaguan_shuzi(4,shi); shumaguan_shuzi(5,ge); shumaguan_shuzi(6,shi_p); shumaguan_shuzi(5,12); shumaguan_shuzi(7,ge_p); ledlight(1);&#125;void display_cs()&#123; ledlight(2); shumaguan_zimu(0,8); shumaguan_shuzi(6,temp_cs/10); shumaguan_shuzi(7,temp_cs%10); Scan_S9(); Scan_S8();&#125;void display_dacnum()&#123; judge_dac(); if(mode_dac==0) &#123; shumaguan_zimu(0,0); shumaguan_shuzi(5,voltage); shumaguan_shuzi(5,12); shumaguan_shuzi(6,0); shumaguan_shuzi(7,0); P2=0x80; P0=0xf6; &#125; if(mode_dac==1) &#123; shumaguan_zimu(0,0); shumaguan_shuzi(5,voltage/100); shumaguan_shuzi(5,12); shumaguan_shuzi(6,voltage%100/10); shumaguan_shuzi(7,voltage%10); ledlight(3); &#125; &#125;void judge_dac()&#123; if(mode_dac==0) &#123; temperature_get(); if(temp&gt;temp_cs) &#123; voltage=5; pcf8591_dac(0xff); &#125; if(temp&lt;temp_cs) &#123; voltage=0; pcf8591_dac(0x00); &#125; &#125; if(mode_dac==1) &#123; temperature_get(); if(temp&lt;=20) &#123; voltage=1; &#125; if(temp&gt;20&amp;&amp;temp&lt;40) &#123; voltage=0.15*temp*100; if(voltage&gt;=400) voltage=400; if(voltage&lt;=200) voltage=200; &#125; if(temp&gt;=40) &#123; voltage=4; &#125; &#125;&#125;void Scan_S4()&#123; R4=0;R3=1; if(C1==0) &#123; while(C1==0)display_temp(); while(1) &#123; judge_dac(); display_cs(); R4=0;R3=1; if(C1==0) &#123; while(C1==0)display_dacnum(); while(1) &#123; Scan_S5(); R4=0;R3=1; if(C1==0) &#123; while(C1==0) display_temp(); while(1) &#123; ledlight(3); temperature_get(); judge_dac(); display_temp(); Scan_S4(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;void Scan_S8()&#123; R4=0;R3=1; if(C2==0&amp;&amp;R4==0) &#123; while(C2==0&amp;&amp;R4==0); temp_cs--; &#125;&#125;void Scan_S9()&#123; R3=0;R4=1; if(C2==0&amp;&amp;R3==0) &#123; while(C2==0&amp;&amp;R3==0); temp_cs++; &#125;&#125;void Scan_S5()&#123; uchar temp=4; R3=0;R4=1; if(C1==0&amp;&amp;R3==0) &#123; while(C1==0&amp;&amp;R3==0); temp++; &#125; if(temp%2==0) &#123; mode_dac=0; judge_dac(); display_dacnum(); &#125; if(temp%2==1) &#123; while(1) &#123; mode_dac=1; judge_dac(); display_dacnum(); if(C1==0&amp;&amp;R3==0) &#123; while(C1==0&amp;&amp;R3==0); break; &#125; &#125; &#125;&#125;void main()&#123; while(1) &#123; Init_Keys(); Scan_S4(); judge_dac(); temperature_get(); display_temp(); &#125;&#125; 过几天看看第九届吧，之前我看了第七届，PWM波那里给我看傻了，还不如先做第九届。","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机第八届省赛——源码及设计思路","slug":"蓝桥杯单片机第八届省赛——源码及设计思路","date":"2022-03-30T00:46:42.000Z","updated":"2023-03-24T01:09:50.703Z","comments":true,"path":"2022/03/30/蓝桥杯单片机第八届省赛——源码及设计思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/03/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%9C%81%E8%B5%9B%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"","text":"距离蓝桥杯省赛还有10天，要抓紧练习了，不知道是这一届简单还是自己厉害了的原因，用了一天就做出来了，还是叫大佬帮了一个小忙，时间也不少，还能再做几届。 废话不多说，先看原题 MAIN.C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647#include&lt;reg51.h&gt;#include&lt;onewire.h&gt;#include&lt;intrins.h&gt;#define uchar unsigned char#define uint unsigned int sfr AUXR = 0x8e; sfr T2H = 0xD6; sfr T2L = 0xD7; sfr IE2 = 0xAF; sbit R1=P3^0;//第一排初始化（如果跳线帽模式是BTN，则只有最左侧一列能用）sbit R2=P3^1;//第二排初始化sbit R3=P3^2;//第三排初始化sbit R4=P3^3;//第四排初始化sbit DQ = P1^4; ////////////////////////////0 1 2 3 4 5 6 7 8 9 - 全灭unsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff&#125;;/////////////////////////// A b C d E F H L P U nunsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1,0xc8&#125;;//////////////////////////// 0 1 2 3 4 5 6 7 unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;////////////////////////// 1 2 3 4 5 6 7 8 灭unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff&#125;;int temp;uchar shi;uchar ge;int temp2;unsigned char count_c=0;unsigned char second=50;unsigned char minute=59;unsigned char hour=23;uchar count_b=0;//时钟设置uchar hour_p;uchar minute_p;uchar second_p;//闹钟设置uchar hour_n=0;uchar minute_n=0;uchar second_n=0;uchar mode_smg=0;uchar mode_f=0;uchar mode_e;//闹钟计数uchar count_a;uchar mode_alarm=0;uchar alarm_num=0;void Scan_S7();void alarm();void shumaguan_shuzi();void delay_ms(int ms)&#123; int q,w; for(q = 0;q&lt;ms;q++)&#123; for(w=845;w&gt;0;w--); &#125;&#125;void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1);&#125;//数码管字母显示void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1);&#125;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125;void Init_Keys()&#123; R1=R2=R3=R4=1;&#125;void cls_buzz(void)&#123; P2 = (P2&amp;0x1F|0xA0); P0 = 0x00; P2 &amp;= 0x1F;&#125;void Init_timer0() &#123; TMOD = 0x01; TH0 = (65535 - 50000) / 256; TL0 = (65535 - 50000) % 256; EA = 1; ET0 = 1; TR0 = 1; &#125;void Service_timer0() interrupt 1//定时器0&#123; TH0 = (65535 - 50000) / 256; TL0 = (65535 - 50000) % 256; count_c++; if(count_c == 20) &#123; second++; count_c = 0; &#125; if(second == 60) &#123; minute++; second=0; &#125; if(minute==60) &#123; hour++; minute=0; if(hour==24) hour=0; &#125;&#125;void Timer1(void) //定时模式 &#123; TMOD &amp;= 0x0F; TL1 = (65535-1000)%256; TH1 = (65535-1000)/256; TF1 = 0; TR1 = 0; ET1 = 1;&#125;void Timer1_Service() interrupt 3//定时器1的定时模式&#123; count_a++; if(count_a==200) &#123; count_a=0; alarm_num++; if(mode_alarm==0) &#123; mode_alarm=1; &#125; else if(mode_alarm==1) &#123; mode_alarm=0; &#125; &#125;&#125;void led_blink()&#123; if(mode_alarm==1) &#123; ledlight(0); &#125; if(mode_alarm==0) &#123; P2=0x80; P0=0xff; &#125; if(R1==0||R2==0||R3==0||R4==0) &#123; P2=0x80; P0=0x00; TR1=0; count_a=0; alarm_num=0; mode_alarm=0; &#125; if(alarm_num==25) &#123; TR1=0; count_a=0; alarm_num=0; mode_alarm=0; &#125;&#125;void Timer2(void)&#123; T2H = (65535-50000)/256; T2L = (65535-50000)%256; EA = 1; IE2 |=0x04; AUXR|=0x10; &#125;void Timer2_Service() interrupt 12//定时器2的定时模式&#123; count_b++; if(count_b==20) &#123; count_b=0; if(mode_smg==0) &#123; mode_smg=1; &#125; else if(mode_smg==1) &#123; mode_smg=0; &#125; &#125;&#125;void display_clock()&#123; shumaguan_shuzi(0,hour/10); shumaguan_shuzi(1,hour%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute/10); shumaguan_shuzi(4,minute%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second/10); shumaguan_shuzi(7,second%10); alarm(); led_blink(); while(R4==0) &#123; shumaguan_shuzi(5,shi); shumaguan_shuzi(6,ge); shumaguan_zimu(7,2); &#125;&#125;void hour_blink()&#123; mode_e=1; if(mode_f==1) &#123; if(mode_smg==1) &#123; shumaguan_shuzi(0,hour_p/10); shumaguan_shuzi(1,hour_p%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_p/10); shumaguan_shuzi(4,minute_p%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_p/10); shumaguan_shuzi(7,second_p%10); &#125; if(mode_smg==0) &#123; shumaguan_shuzi(0,11); shumaguan_shuzi(1,11); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_p/10); shumaguan_shuzi(4,minute_p%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_p/10); shumaguan_shuzi(7,second_p%10); &#125; &#125; if(mode_f==2) &#123; if(mode_smg==1) &#123; shumaguan_shuzi(0,hour_n/10); shumaguan_shuzi(1,hour_n%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_n/10); shumaguan_shuzi(4,minute_n%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_n/10); shumaguan_shuzi(7,second_n%10); &#125; if(mode_smg==0) &#123; shumaguan_shuzi(0,11); shumaguan_shuzi(1,11); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_n/10); shumaguan_shuzi(4,minute_n%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_n/10); shumaguan_shuzi(7,second_n%10); &#125; &#125;&#125;void minute_blink()&#123; mode_e=2; if(mode_f==1) &#123; if(mode_smg==1) &#123; shumaguan_shuzi(0,hour_p/10); shumaguan_shuzi(1,hour_p%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_p/10); shumaguan_shuzi(4,minute_p%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_p/10); shumaguan_shuzi(7,second_p%10); &#125; if(mode_smg==0) &#123; shumaguan_shuzi(0,hour_p/10); shumaguan_shuzi(1,hour_p%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,11); shumaguan_shuzi(4,11); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_p/10); shumaguan_shuzi(7,second_p%10); &#125; &#125; if(mode_f==2) &#123; if(mode_smg==1) &#123; shumaguan_shuzi(0,hour_n/10); shumaguan_shuzi(1,hour_n%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_n/10); shumaguan_shuzi(4,minute_n%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_n/10); shumaguan_shuzi(7,second_n%10); &#125; if(mode_smg==0) &#123; shumaguan_shuzi(0,hour_n/10); shumaguan_shuzi(1,hour_n%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,11); shumaguan_shuzi(4,11); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_n/10); shumaguan_shuzi(7,second_n%10); &#125; &#125;&#125;void second_blink()&#123; mode_e=3; if(mode_f==1) &#123; if(mode_smg==1) &#123; shumaguan_shuzi(0,hour_p/10); shumaguan_shuzi(1,hour_p%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_p/10); shumaguan_shuzi(4,minute_p%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_p/10); shumaguan_shuzi(7,second_p%10); &#125; if(mode_smg==0) &#123; shumaguan_shuzi(0,hour_p/10); shumaguan_shuzi(1,hour_p%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_p/10); shumaguan_shuzi(4,minute_p%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,11); shumaguan_shuzi(7,11); &#125; &#125; if(mode_f==2) &#123; if(mode_smg==1) &#123; shumaguan_shuzi(0,hour_n/10); shumaguan_shuzi(1,hour_n%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_n/10); shumaguan_shuzi(4,minute_n%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,second_n/10); shumaguan_shuzi(7,second_n%10); &#125; if(mode_smg==0) &#123; shumaguan_shuzi(0,hour_n/10); shumaguan_shuzi(1,hour_n%10); shumaguan_shuzi(2,10); shumaguan_shuzi(3,minute_n/10); shumaguan_shuzi(4,minute_n%10); shumaguan_shuzi(5,10); shumaguan_shuzi(6,11); shumaguan_shuzi(7,11); &#125; &#125;&#125;void temperature_get()&#123; uchar high,low; init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0x44); init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=((high&lt;&lt;4)|(low&gt;&gt;4));//不带小数点 //temp2=low&amp;0x0f*100/16;//取小数点两位 shi=temp%100/10; ge=temp%10;&#125;void display_temp()&#123; while(R4==0) &#123; shumaguan_shuzi(5,shi); shumaguan_shuzi(6,ge); shumaguan_zimu(7,2); &#125;&#125;void alarm()&#123; if(hour==hour_n&amp;&amp;minute==minute_n&amp;&amp;second==second_n) &#123; P2=(P2&amp;0X1f)|0x80; P0=0xff; TR1=1; &#125; &#125;void Scan_S5()&#123; if(mode_f==1) &#123; if(R3==0) &#123; while(R3==0); if(mode_e==1) &#123; hour_p++; if(hour_p==24) &#123;hour_p=0;&#125; &#125; else if(mode_e==2) &#123; minute_p++; if(minute_p==60) &#123;minute_p=0;&#125; &#125; else if(mode_e==3) &#123; second_p++; if(second_p==60) &#123;second_p=0;&#125; &#125; &#125; &#125; if(mode_f==2) &#123; if(R3==0) &#123; while(R3==0); if(mode_e==1) &#123; hour_n++; if(hour_n==24) &#123;hour_n=0;&#125; &#125; else if(mode_e==2) &#123; minute_n++; if(minute_n==60) &#123;minute_n=0;&#125; &#125; else if(mode_e==3) &#123; second_n++; if(second_n==60) &#123;second_n=0;&#125; &#125; &#125; &#125;&#125;void Scan_S4()&#123; if(mode_f==1) &#123; if(R4==0) &#123; while(R4==0); if(mode_e==1) &#123; hour_p--; if(hour_p==0) &#123;hour_p=24;&#125; &#125; else if(mode_e==2) &#123; minute_p--; if(minute_p==0) &#123;minute_p=60;&#125; &#125; else if(mode_e==3) &#123; second_p--; if(second_p==0) &#123;second_p=60;&#125; &#125; &#125; &#125; if(mode_f==2) &#123; if(R4==0) &#123; while(R4==0); if(mode_e==1) &#123; hour_n--; if(hour_n==0) &#123;hour_n=24;&#125; &#125; else if(mode_e==2) &#123; minute_n--; if(minute_n==0) &#123;minute_n=60;&#125; &#125; else if(mode_e==3) &#123; second_n--; if(second_n==0) &#123;second_n=60;&#125; &#125; &#125; &#125; &#125;void Scan_S6()&#123; mode_f=2; if(R2==0) &#123; while(R2==0); hour_n=hour; minute_n=minute; second_n=second; Timer2(); while(1) &#123; hour_blink(); Scan_S5(); Scan_S4(); if(R2==0) &#123; while(R2==0) minute_blink(); while(1) &#123; minute_blink(); Scan_S5(); Scan_S4(); if(R2==0) &#123; while(R2==0)second_blink(); while(1) &#123; second_blink(); Scan_S5(); Scan_S4(); if(R2==0) &#123; while(R2==0) &#123; display_clock(); &#125; while(1) &#123; display_clock(); Scan_S6(); Scan_S7(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;void Scan_S7()&#123; uchar mode_s7=0; mode_f=1; if(R1==0) &#123; while(R1==0); mode_s7++; hour_p=hour; minute_p=minute; second_p=second; Timer2(); while(1) &#123; hour_blink(); Scan_S5(); Scan_S4(); if(R1==0) &#123; while(R1==0) minute_blink(); while(1) &#123; minute_blink(); Scan_S5(); Scan_S4(); if(R1==0) &#123; while(R1==0)second_blink(); while(1) &#123; second_blink(); Scan_S5(); Scan_S4(); if(R1==0) &#123; while(R1==0) &#123; display_clock(); hour=hour_p; minute=minute_p; second=second_p; &#125; while(1) &#123; display_clock(); Scan_S7(); Scan_S6(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;void main()&#123; Timer1(); Init_Keys(); Init_timer0(); cls_buzz(); while(1) &#123; Scan_S6(); Scan_S7(); display_clock(); temperature_get(); display_temp(); &#125;&#125; 设计思路，就是在做1s间隔的闪烁的时候，需要用到定时器，在做闹钟的触发响应时，也要用到定时器，考到定时器较多，我就定时器学得不好，但是总体来说还是很简单的","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机模式转换思路","slug":"蓝桥杯单片机模式转换思路","date":"2022-03-24T01:25:43.000Z","updated":"2023-03-24T01:11:22.136Z","comments":true,"path":"2022/03/24/蓝桥杯单片机模式转换思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/03/24/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%A8%A1%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%80%9D%E8%B7%AF/","excerpt":"","text":"因为在蓝桥杯的单片机省赛中经常需要用到模式转换。例： 这样的模式转换，我的想法是。每按下一次按键，就给temp+1，在循环里判定temp%2是否等于1，但是这个方法只适用于两种模式，三种模式的我还没想好，先放源代码 这里以S7为例，要放到主函数里面 1234567891011121314151617181920212223242526272829303132333435void Scan_S7()&#123; uchar temp=4; C4=1; if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; temp++; while(R1==0); &#125; &#125; if(temp%2==0) &#123; //模式1 &#125; if(temp%2==1) &#123; while(1) &#123; //模式2 if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; break; while(R1==0); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机第十届省赛——源码以及设计思路","slug":"蓝桥杯单片机第十届省赛——源码以及设计思路","date":"2022-02-11T04:07:05.000Z","updated":"2023-03-24T01:10:32.586Z","comments":true,"path":"2022/02/11/蓝桥杯单片机第十届省赛——源码以及设计思路/","link":"","permalink":"https://mengfanjun020906.github.io/2022/02/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E5%8D%81%E5%B1%8A%E7%9C%81%E8%B5%9B%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"","text":"过完年了，也不能老玩了，寒假一堆事，开学还得考试，真是都要emo了，先选一个开始做吧，十一届做完了的话，就去该做第十届了，废话不多说，先看原题 原题目 设计思路： 这第一眼看上去有4页，可是把我吓了一跳，我以为这个挺难的，后来仔细读了读，按键的切换模式并不多，四个按键，就是用来切换模式的，功能比较简单 就是led闪烁的数值范围需要看仔细，因为之前图方便，自己写了一个ledlight（x），随意控制某个灯，但是写的时候，忘了led灯是8位，不能叠加，所以这个函数只适合在需要一个led灯亮的时候起作用。 还是老方法，PCF8591和NE555，在写函数的时候需要注意一下，尤其是NE555，用到了定时器T0和T1 这个我回去还得钻研一下，因为在家写的话可以上网查资料，真正比赛就不行了。其他也没什么难点，个人觉得比十一届简单一点。 源代码 iic.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &quot;intrins.h&quot;#define DELAY_TIME 5#define SlaveAddrW 0xA0#define SlaveAddrR 0xA1sbit SDA = P2^1; sbit SCL = P2^0; void IIC_Delay(unsigned char i)&#123; do&#123;_nop_();&#125; while(i--); &#125;void IIC_Start(void)&#123; SDA = 1; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 0; IIC_Delay(DELAY_TIME); SCL = 0; &#125;void IIC_Stop(void)&#123; SDA = 0; SCL = 1; IIC_Delay(DELAY_TIME); SDA = 1; IIC_Delay(DELAY_TIME);&#125;void IIC_SendAck(bit ackbit)&#123; SCL = 0; SDA = ackbit; IIC_Delay(DELAY_TIME); SCL = 1; IIC_Delay(DELAY_TIME); SCL = 0; SDA = 1; IIC_Delay(DELAY_TIME);&#125;bit IIC_WaitAck(void)&#123; bit ackbit; SCL = 1; IIC_Delay(DELAY_TIME); ackbit = SDA; SCL = 0; IIC_Delay(DELAY_TIME); return ackbit;&#125;void IIC_SendByte(unsigned char byt)&#123; unsigned char i; for(i=0; i&lt;8; i++) &#123; SCL = 0; IIC_Delay(DELAY_TIME); if(byt &amp; 0x80) SDA = 1; else SDA = 0; IIC_Delay(DELAY_TIME); SCL = 1; byt &lt;&lt;= 1; IIC_Delay(DELAY_TIME); &#125; SCL = 0; &#125;unsigned char IIC_RecByte(void)&#123; unsigned char i, da; for(i=0; i&lt;8; i++) &#123; SCL = 1; IIC_Delay(DELAY_TIME); da &lt;&lt;= 1; if(SDA) da |= 1; SCL = 0; IIC_Delay(DELAY_TIME); &#125; return da; &#125; REG51.H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/*--------------------------------------------------------------------------REG51.HHeader file for generic 80C51 and 80C31 microcontroller.Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.All rights reserved.--------------------------------------------------------------------------*/#ifndef __REG51_H__#define __REG51_H__#define uchar unsigned char#define uint unsigned intunsigned char code shuzi[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff&#125;;unsigned char code zimu[]=&#123;0x88,0x83,0xc6,0xa1,0x86,0x8e,0x89,0xc7,0x8c,0xc1&#125;;unsigned char code num[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90&#125;;unsigned char code weizhi[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00&#125;;unsigned char ledweizhi[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0xff&#125;;//8ÊÇÈ«Ãð/* BYTE Register */sfr P0 = 0x80;sfr P1 = 0x90;sfr P2 = 0xA0;sfr P3 = 0xB0;sfr P4 = 0xC0;sfr PSW = 0xD0;sfr ACC = 0xE0;sfr B = 0xF0;sfr SP = 0x81;sfr DPL = 0x82;sfr DPH = 0x83;sfr PCON = 0x87;sfr TCON = 0x88;sfr TMOD = 0x89;sfr TL0 = 0x8A;sfr TL1 = 0x8B;sfr TH0 = 0x8C;sfr TH1 = 0x8D;sfr IE = 0xA8;sfr IP = 0xB8;sfr SCON = 0x98;sfr SBUF = 0x99;/* BIT Register *//* PSW */sbit CY = 0xD7;sbit AC = 0xD6;sbit F0 = 0xD5;sbit RS1 = 0xD4;sbit RS0 = 0xD3;sbit OV = 0xD2;sbit P = 0xD0;/* TCON */sbit TF1 = 0x8F;sbit TR1 = 0x8E;sbit TF0 = 0x8D;sbit TR0 = 0x8C;sbit IE1 = 0x8B;sbit IT1 = 0x8A;sbit IE0 = 0x89;sbit IT0 = 0x88;/* IE */sbit EA = 0xAF;sbit ES = 0xAC;sbit ET1 = 0xAB;sbit EX1 = 0xAA;sbit ET0 = 0xA9;sbit EX0 = 0xA8;/* IP */ sbit PS = 0xBC;sbit PT1 = 0xBB;sbit PX1 = 0xBA;sbit PT0 = 0xB9;sbit PX0 = 0xB8;/* P3 */sbit RD = 0xB7;sbit WR = 0xB6;sbit T1 = 0xB5;sbit T0 = 0xB4;sbit INT1 = 0xB3;sbit INT0 = 0xB2;sbit TXD = 0xB1;sbit RXD = 0xB0;/* SCON */sbit SM0 = 0x9F;sbit SM1 = 0x9E;sbit SM2 = 0x9D;sbit REN = 0x9C;sbit TB8 = 0x9B;sbit RB8 = 0x9A;sbit TI = 0x99;sbit RI = 0x98;#endifvoid delay_ms(int ms)&#123; int q,w; for(q = 0;q&lt;ms;q++)&#123; for(w=845;w&gt;0;w--); &#125;&#125;void Delay500us() //@12.000MHz&#123; unsigned char i, j; i = 6; j = 211; do &#123; while (--j); &#125; while (--i);&#125;void Delay100us() //@12.000MHz&#123; unsigned char i, j; i = 2; j = 39; do &#123; while (--j); &#125; while (--i);&#125;void allinit()&#123; P2=(P2&amp;0x1f)|0x80; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xA0; P0 = P0 &amp; 0XAF; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xc0; P0=0xff; P2&amp;=0x1f; P2=(P2&amp;0x1f)|0xe0; P0=0xFF; P2&amp;=0x1f;&#125;void shumaguan_bit(unsigned char a[],unsigned char b)//&#123; unsigned char code led_p[]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0x88,0xc6&#125;; unsigned char i; for(i=0;i&lt;=7;i++) &#123; if((b&gt;&gt;(7-i))&amp;0x01) &#123; P2 = (P2 &amp; 0X1F)|(0X07 &lt;&lt; 5); P0 = 0Xff; P2 = (P2 &amp; 0X1F)|(0X06 &lt;&lt; 5); P0 = (0x01 &lt;&lt; i); delay_ms(1); P2 = (P2 &amp; 0X1F)|(0X07 &lt;&lt; 5); P0 = led_p[a[i]]; delay_ms(1); &#125; else &#123; P2 = (P2 &amp; 0X1F)|(0X07 &lt;&lt; 5); P0 = 0Xff; P2 = (P2 &amp; 0X1F)|(0X06 &lt;&lt; 5); P0 = (0x01 &lt;&lt; i); delay_ms(1); P2 = (P2 &amp; 0X1F)|(0X07 &lt;&lt; 5); P0 = 0xff; delay_ms(1); &#125; &#125;&#125;void shumaguan_shuzi(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=shuzi[b]; delay_ms(1);&#125;void shumaguan_zimu(uchar a,uchar b)&#123; delay_ms(1); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[a]; P2=(P2&amp;0X1f)|0xE0;P0=zimu[b]; delay_ms(1);&#125;void ledlight(uchar x)&#123; P2=(P2&amp;0X1f)|0x80; P0=ledweizhi[x];&#125; MAIN.C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include&lt;reg51.h&gt;#include&lt;intrins.h&gt;#include&lt;iic.c&gt;sbit R1=P3^0;sbit R2=P3^1;sbit R3=P3^2;sbit R4=P3^3;int addata;long adc_dat;int voltage;int dat;int v;unsigned int count_f = 0;unsigned char count_t = 0;unsigned int dat_f = 0;void display_v();void display_voltage_led();void Read_AIN3();void Scan_S7();void Scan_S6();void Scan_S5();void Scan_S4();void Init_Keys()&#123; R1=R2=R3=R4=1;&#125;void Init_Timer()&#123; TH0 = 0xff; TL0 = 0xff; TH1 = (65536 - 50000) / 256; TL1 = (65536 - 50000) % 256; TMOD = 0x16; ET0 = 1; ET1 = 1; EA = 1; TR0 = 1; TR1 = 1;&#125; void Service_T0() interrupt 1&#123; count_f++;&#125; void Service_T1() interrupt 3&#123; TH1 = (65536 - 50000) / 256; TL1 = (65536 - 50000) % 256; count_t++; if(count_t == 20) &#123; dat_f = count_f; count_f = 0; count_t = 0; &#125;&#125;void display_f()&#123; int f; shumaguan_zimu(0,5); ledlight(1); if(dat_f&gt;9999) shumaguan_shuzi(3,dat_f/1000); if(dat_f&gt;999) shumaguan_shuzi(4,dat_f/1000%10); if(dat_f&gt;99) shumaguan_shuzi(5,dat_f/100%10); if(dat_f&gt;9) shumaguan_shuzi(6,dat_f/10%10); shumaguan_shuzi(7,dat_f%10); if(1000&lt;=dat_f&amp;&amp;dat_f&lt;5000) &#123; ledlight(3); &#125; else if(dat_f&gt;=10000) &#123; ledlight(3); &#125;&#125;void display_voltage_led()&#123; voltage=dat*100/51; P2=0x80; P0=0xee;//L1 and L5 shumaguan_shuzi(6,voltage%100/10); shumaguan_shuzi(7,voltage%10); shumaguan_zimu(0,9); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[5]; P2=(P2&amp;0X1f)|0xFF;P0=shuzi[voltage/100]+0x80; v=dat*100/51; &#125;void Read_AIN3()&#123; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(0x03); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); dat = IIC_RecByte(); IIC_WaitAck(); IIC_Stop(); &#125;void Scan_S7()&#123; uchar temp=4; if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; temp++; while(R1==0); &#125; &#125; if(temp%2==0) &#123; &#125; if(temp%2==1) &#123; while(1) &#123; shumaguan_shuzi(0,11); shumaguan_shuzi(1,11); shumaguan_shuzi(2,11); shumaguan_shuzi(3,11); shumaguan_shuzi(4,11); shumaguan_shuzi(5,11); shumaguan_shuzi(6,11); shumaguan_shuzi(7,11); if(v!=200) &#123; P2=0x80; P0=0xee;//L1 and L5 &#125; if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; break; while(R1==0); &#125; &#125; &#125; &#125;&#125;void Scan_S6()&#123; uchar temp=4; if(R2==0) &#123; delay_ms(50); if(R2==0) &#123; temp++; while(R2==0); &#125; &#125; if(temp%2==0) &#123; Read_AIN3(); display_voltage_led(); &#125; if(temp%2==1) &#123; while(1) &#123; ledlight(8); Read_AIN3(); display_v(); if(R2==0) &#123; delay_ms(50); if(R2==0) &#123; break; while(R2==0); &#125; &#125; &#125; &#125; &#125;void Scan_S4()&#123; uchar temp=4; if(R4==0) &#123; delay_ms(50); if(R4==0) &#123; temp++; while(R4==0); &#125; &#125; if(temp%2==0) &#123; Read_AIN3(); display_voltage_led(); &#125; if(temp%2==1) &#123; while(1) &#123; display_f(); if(R4==0) &#123; delay_ms(50); if(R4==0) &#123; break; while(R4==0); &#125; &#125; &#125; &#125; &#125;void display_v()&#123; voltage=dat*100/51; shumaguan_shuzi(6,voltage%100/10); shumaguan_shuzi(7,voltage%10); shumaguan_zimu(0,9); P2=(P2&amp;0X1f)|0xC0;P0=weizhi[5]; P2=(P2&amp;0X1f)|0xFF;P0=shuzi[voltage/100]+0x80;&#125;void Scan_S5()&#123; uchar temp=4; if(R3==0) &#123; delay_ms(50); if(R3==0) &#123; temp++; while(R3==0); &#125; &#125; if(temp%2==0) &#123; Read_AIN3(); display_voltage_led(); &#125; if(temp%2==1) &#123; while(1) &#123; dat=102; display_v(); P2=0x80; P0=0xfa;//L1 and L3 if(R3==0) &#123; delay_ms(50); if(R3==0) &#123; break; while(R3==0); &#125; &#125; &#125; &#125; &#125;void main()&#123; Init_Keys(); Init_Timer(); while(1) &#123; Read_AIN3(); display_voltage_led(); Scan_S7(); Scan_S6(); Scan_S5(); Scan_S4(); &#125;&#125; 把reg51.h放出来主要是因为我自己不会做.h，所以把自己之前用的数组和函数都放进reg51里了，就先做到这里，我去学高频了，过几天再做一套，五个小时那种","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"蓝桥杯单片机练习——可调节时钟源代码","slug":"蓝桥杯单片机练习——可调节时钟源代码","date":"2022-02-09T09:12:16.000Z","updated":"2022-12-05T04:55:22.703Z","comments":true,"path":"2022/02/09/蓝桥杯单片机练习——可调节时钟源代码/","link":"","permalink":"https://mengfanjun020906.github.io/2022/02/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%AF%E8%B0%83%E8%8A%82%E6%97%B6%E9%92%9F%E6%BA%90%E4%BB%A3%E7%A0%81/","excerpt":"","text":"可调节时钟，通过外部中断0进行小时、分钟、秒的调节 S5：进入调节模式 S6：向左切换调节对象 S5：向右切换调节对象 S7：加1 S4：减1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524#include&lt;reg51.h&gt;#include&lt;intrins.h&gt;sbit R1=P3^0;sbit R2=P3^1;sbit R3=P3^2;sbit R4=P3^3;unsigned char code num[]=&#123;0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0xbf,0xff&#125;;unsigned char count=0;unsigned char second=0;unsigned char minute=59;uchar hour=23;int mode;void hour_blink()&#123; int mode=1; int i=50,j=50; if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; hour++; if(hour==24) hour=0; while(R1==0); &#125; &#125; if(R4==0) &#123; delay_ms(50); if(R4==0) &#123; hour--; if(hour==0) hour=24; while(R4==0); &#125; &#125; while(i--) &#123; P2=0xC0;P0=weizhi[0]; P2=0xFF;P0=num[hour/10]; delay_ms(1); P2=0xC0;P0=weizhi[1]; P2=0xFF;P0=num[hour%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[5]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[2]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[7]; P2=0xFF;P0=num[second%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[6]; P2=0xFF;P0=num[second/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[3]; P2=0xFF;P0=num[minute/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[4]; P2=0xFF;P0=num[minute%10]; delay_ms(1); &#125; i=50; while(j--) &#123; P2=0xC0;P0=weizhi[0]; P2=0xFF;P0=num[11]; delay_ms(1); P2=0xC0;P0=weizhi[1]; P2=0xFF;P0=num[11]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[5]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[2]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[7]; P2=0xFF;P0=num[second%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[6]; P2=0xFF;P0=num[second/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[3]; P2=0xFF;P0=num[minute/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[4]; P2=0xFF;P0=num[minute%10]; delay_ms(1); &#125; j=50; &#125;void minute_blink()&#123; int mode=2; int i=50,j=50; if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; minute++; if(minute==60) minute=0; while(R1==0); &#125; &#125; if(R4==0) &#123; delay_ms(50); if(R4==0) &#123; minute--; if(minute==0) minute=60; while(R4==0); &#125; &#125; while(i--) &#123; P2=0xC0;P0=weizhi[3]; P2=0xFF;P0=num[minute/10]; delay_ms(1); P2=0xC0;P0=weizhi[4]; P2=0xFF;P0=num[minute%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[5]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[2]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[7]; P2=0xFF;P0=num[second%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[6]; P2=0xFF;P0=num[second/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[0]; P2=0xFF;P0=num[hour/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[1]; P2=0xFF;P0=num[hour%10]; delay_ms(1); &#125; i=50; while(j--) &#123; P2=0xC0;P0=weizhi[3]; P2=0xFF;P0=num[11]; delay_ms(1); P2=0xC0;P0=weizhi[7]; P2=0xFF;P0=num[11]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[5]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[2]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[7]; P2=0xFF;P0=num[second%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[6]; P2=0xFF;P0=num[second/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[0]; P2=0xFF;P0=num[hour/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[1]; P2=0xFF;P0=num[hour%10]; delay_ms(1); &#125; j=50; &#125;void second_blink()&#123; int mode=3; int i=50,j=50; if(R1==0) &#123; delay_ms(50); if(R1==0) &#123; second++; if(second==60) second=0; while(R1==0); &#125; &#125; if(R4==0) &#123; delay_ms(50); if(R4==0) &#123; second--; if(second==0) second=60; while(R4==0); &#125; &#125; while(i--) &#123; P2=0xC0;P0=weizhi[6]; P2=0xFF;P0=num[second/10];//ÃëµÄÊ®Î» delay_ms(1); P2=0xC0;P0=weizhi[7]; P2=0xFF;P0=num[second%10];//ÃëµÄ¸öÎ» delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[5]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[2]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[4]; P2=0xFF;P0=num[minute%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[3]; P2=0xFF;P0=num[minute/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[0]; P2=0xFF;P0=num[hour/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[1]; P2=0xFF;P0=num[hour%10]; delay_ms(1); &#125; i=50; while(j--) &#123; P2=0xC0;P0=weizhi[6]; P2=0xFF;P0=num[11]; delay_ms(1); P2=0xC0;P0=weizhi[7]; P2=0xFF;P0=num[11]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[5]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[2]; P2=0xFF;P0=num[10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[4]; P2=0xFF;P0=num[minute%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[3]; P2=0xFF;P0=num[minute/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[0]; P2=0xFF;P0=num[hour/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[1]; P2=0xFF;P0=num[hour%10]; delay_ms(1); &#125; j=50;&#125;void Init()&#123; R1=R2=R3=R4=1;&#125;void INT0_Init(void)//Íâ²¿ÖÐ¶Ï0 &#123; IT0 = 1; EX0 = 1; EA = 1; IT1=1; EX1=1; &#125;void Init_timer0() &#123; TMOD = 0x01; TH0 = (65535 - 50000) / 256; TL0 = (65535 - 50000) % 256; EA = 1; ET0 = 1; TR0 = 1; &#125;void INT0_handle(void) interrupt 0 &#123; int hour_data=0; int minute_data=0; int second_data=0; int i=50,j=50; int count_left =0; int count_right =0; while(1) &#123; second_blink(); if(R2==0) &#123; delay_ms(50); if(R2==0) &#123; count_right++; while(R2==0); &#125; &#125;switch(count_right) &#123; case 1: while(1) &#123; hour_blink(); if(R2==0) break; if(R3==0) &#123; count_left=0; break; &#125; &#125; case 2: while(1) &#123; minute_blink(); if(R2==0) &#123; count_right=0; break; &#125; if(R3==0) &#123; count_left=2; break; &#125; &#125; &#125; if(R3==0) &#123; delay_ms(50); if(R3==0) &#123; count_left++; while(R3==0); &#125; &#125;switch(count_left) &#123; case 1: while(1) &#123; minute_blink(); if(R3==0) break; if(R2==0) &#123; count_right=0; break; &#125; &#125; case 2: while(1) &#123; hour_blink(); if(R3==0) &#123; count_left=0; break; &#125; if(R2==0) &#123; count_right=2; break; &#125; &#125; &#125; &#125; &#125;void Service_timer0() interrupt 1&#123; TH0 = (65535 - 50000) / 256; TL0 = (65535 - 50000) % 256; count++; if(count == 20) &#123; second++; count = 0; &#125; if(second == 60) &#123; minute++; second=0; &#125; if(minute==60) &#123; hour++; minute=0; if(hour==24) hour=0; &#125;&#125;void main() &#123; allinit(); INT0_Init(); Init_timer0(); while(1) &#123; delay_ms(1); shumaguan_control(6,second/10);// P2=0xC0;P0=weizhi[6];// P2=0xFF;P0=num[second/10];//ÃëµÄÊ®Î» delay_ms(1); shumaguan_control(7,second%10);// P2=0xC0;P0=weizhi[7];// P2=0xFF;P0=num[second%10];//ÃëµÄ¸öÎ» delay_ms(1); P2=0xC0;P0=weizhi[5]; P2=0xFF;P0=num[10]; delay_ms(1); shumaguan_control(4,minute%10);// P2=0xC0;P0=weizhi[4];// P2=0xFF;P0=num[minute%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[3]; P2=0xFF;P0=num[minute/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[0]; P2=0xFF;P0=num[hour/10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[1]; P2=0xFF;P0=num[hour%10]; delay_ms(1); delay_ms(1); P2=0xC0;P0=weizhi[2]; P2=0xFF;P0=num[10]; delay_ms(1); &#125; &#125;","categories":[{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"Arduino Uno零基础入门学习笔记","slug":"Arduino Uno零基础入门学习笔记","date":"2021-10-01T01:42:10.000Z","updated":"2023-03-24T05:56:01.319Z","comments":true,"path":"2021/10/01/Arduino Uno零基础入门学习笔记/","link":"","permalink":"https://mengfanjun020906.github.io/2021/10/01/Arduino%20Uno%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"关于零基础学习Arduino的一篇学习笔记 一、配置篇 因为要用Arduino来驱动小车，所以我就担任起了学习Arduino的重任，但由于我之前从来没有接触过编程，只有一定的c语言学习经验，所以是零基础进行学习，首先我是用的macos系统，配置环境大概比Windows系统要复杂一点，关于下载和环境配置如何进行，参考这一篇blog：https://blog.csdn.net/yczyd/article/details/78503420 ****但需要注意的是，经过此篇文章的配置，我发现在我的端口里没有找到Arudino的端口，百思不得其解，之前的步骤也没有做错，后来，我把连接线的插口从左边换到了右边，问题就解决了，原理尚不清楚，如果有哪位大佬清楚，还请在评论区中指出 现在我们就可以顺利的进行程序的编写了！！ 在这里插入图片描述 二、学习篇 第一个要学习的程序，自然是点灯了。 我们点开左上角的文件，选择示例，选择Basics，选择Blink，一个led闪烁的程序就这么诞生了","categories":[{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"}]},{"title":"关于在练习计算机二级时，用VisualStudio2019出现的无法调试问题","slug":"关于在练习计算机二级时，用VisualStudio2019出现的无法调试问题","date":"2021-08-09T08:03:25.000Z","updated":"2023-03-24T01:08:02.741Z","comments":true,"path":"2021/08/09/关于在练习计算机二级时，用VisualStudio2019出现的无法调试问题/","link":"","permalink":"https://mengfanjun020906.github.io/2021/08/09/%E5%85%B3%E4%BA%8E%E5%9C%A8%E7%BB%83%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E6%97%B6%EF%BC%8C%E7%94%A8VisualStudio2019%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%A0%E6%B3%95%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.问题描述 今天在刷二级题的时候，打开了.c后缀填空题文件，发现无法调试 调试那一栏，总是灰色的，不知道为什么，在改完代码后发现没有办法运行，也不知道自己写的是对是错 2.解决方法 在文件夹的同一目录下，不知还有.sln后缀名的文件，将其与.c文件同时打开后。就可以进行调试了 虽然问题是解决了，但还是不懂原理","categories":[{"name":"计算机二级","slug":"计算机二级","permalink":"https://mengfanjun020906.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7/"}],"tags":[{"name":"visual studio","slug":"visual-studio","permalink":"https://mengfanjun020906.github.io/tags/visual-studio/"}]},{"title":"记一次mac的vscode学习记录 关于为什么输出里没法进行输入","slug":"记一次mac的vscode学习记录 关于为什么输出里没法进行输入","date":"2021-07-12T13:51:49.000Z","updated":"2023-03-24T01:09:16.463Z","comments":true,"path":"2021/07/12/记一次mac的vscode学习记录 关于为什么输出里没法进行输入/","link":"","permalink":"https://mengfanjun020906.github.io/2021/07/12/%E8%AE%B0%E4%B8%80%E6%AC%A1mac%E7%9A%84vscode%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20%E5%85%B3%E4%BA%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%93%E5%87%BA%E9%87%8C%E6%B2%A1%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%85%A5/","excerpt":"","text":"1.问题描述 在我的vscode中运行一个简单c++程序时，发现遇到了cin就没法进行输入了，试了很多方法都没有解决，今天刚解决，解决方法如下。 2.解决方法 2.1打开设置 2.2在搜索框中搜索runInTerminal 2.3将第一个框框打勾即可 3.问题解决","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://mengfanjun020906.github.io/tags/vscode/"}]}],"categories":[{"name":"文献阅读","slug":"文献阅读","permalink":"https://mengfanjun020906.github.io/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"},{"name":"学习通信原理","slug":"学习通信原理","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"FPGA","slug":"FPGA","permalink":"https://mengfanjun020906.github.io/categories/FPGA/"},{"name":"MATLAB与数学建模","slug":"MATLAB与数学建模","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"考研","slug":"MATLAB与数学建模/考研","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%80%83%E7%A0%94/"},{"name":"学习通信原理","slug":"MATLAB与数学建模/考研/学习通信原理","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"Latex","slug":"Latex","permalink":"https://mengfanjun020906.github.io/categories/Latex/"},{"name":"Git","slug":"Git","permalink":"https://mengfanjun020906.github.io/categories/Git/"},{"name":"考研数学","slug":"考研数学","permalink":"https://mengfanjun020906.github.io/categories/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"},{"name":"Arduino学习","slug":"Arduino学习","permalink":"https://mengfanjun020906.github.io/categories/Arduino%E5%AD%A6%E4%B9%A0/"},{"name":"The 7th Sky Hackathon","slug":"The-7th-Sky-Hackathon","permalink":"https://mengfanjun020906.github.io/categories/The-7th-Sky-Hackathon/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Pytorch学习","slug":"Pytorch学习","permalink":"https://mengfanjun020906.github.io/categories/Pytorch%E5%AD%A6%E4%B9%A0/"},{"name":"通信原理","slug":"通信原理","permalink":"https://mengfanjun020906.github.io/categories/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"蓝桥杯单片机学习","slug":"蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"MATLAB与数学建模/学习笔记","permalink":"https://mengfanjun020906.github.io/categories/MATLAB%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"蓝桥杯单片机学习","slug":"学习笔记/蓝桥杯单片机学习","permalink":"https://mengfanjun020906.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"},{"name":"SKlearn学习笔记","slug":"SKlearn学习笔记","permalink":"https://mengfanjun020906.github.io/categories/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"个人反思与总结","slug":"蓝桥杯单片机学习/个人反思与总结","permalink":"https://mengfanjun020906.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/%E4%B8%AA%E4%BA%BA%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%80%BB%E7%BB%93/"},{"name":"计算机二级","slug":"计算机二级","permalink":"https://mengfanjun020906.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://mengfanjun020906.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"文献","slug":"文献","permalink":"https://mengfanjun020906.github.io/tags/%E6%96%87%E7%8C%AE/"},{"name":"研究所","slug":"研究所","permalink":"https://mengfanjun020906.github.io/tags/%E7%A0%94%E7%A9%B6%E6%89%80/"},{"name":"matlab","slug":"matlab","permalink":"https://mengfanjun020906.github.io/tags/matlab/"},{"name":"考研","slug":"考研","permalink":"https://mengfanjun020906.github.io/tags/%E8%80%83%E7%A0%94/"},{"name":"github","slug":"github","permalink":"https://mengfanjun020906.github.io/tags/github/"},{"name":"FPGA","slug":"FPGA","permalink":"https://mengfanjun020906.github.io/tags/FPGA/"},{"name":"Latex","slug":"Latex","permalink":"https://mengfanjun020906.github.io/tags/Latex/"},{"name":"git","slug":"git","permalink":"https://mengfanjun020906.github.io/tags/git/"},{"name":"Arduino","slug":"Arduino","permalink":"https://mengfanjun020906.github.io/tags/Arduino/"},{"name":"Nvidia","slug":"Nvidia","permalink":"https://mengfanjun020906.github.io/tags/Nvidia/"},{"name":"人工智能","slug":"人工智能","permalink":"https://mengfanjun020906.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"大数据","slug":"大数据","permalink":"https://mengfanjun020906.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"数字信号处理","slug":"数字信号处理","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"前端","slug":"前端","permalink":"https://mengfanjun020906.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"html","slug":"html","permalink":"https://mengfanjun020906.github.io/tags/html/"},{"name":"pytorch","slug":"pytorch","permalink":"https://mengfanjun020906.github.io/tags/pytorch/"},{"name":"神经网络","slug":"神经网络","permalink":"https://mengfanjun020906.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"https://mengfanjun020906.github.io/tags/python/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://mengfanjun020906.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"算法","slug":"算法","permalink":"https://mengfanjun020906.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学建模","slug":"数学建模","permalink":"https://mengfanjun020906.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"stm32","slug":"stm32","permalink":"https://mengfanjun020906.github.io/tags/stm32/"},{"name":"单片机","slug":"单片机","permalink":"https://mengfanjun020906.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"TAO","slug":"TAO","permalink":"https://mengfanjun020906.github.io/tags/TAO/"},{"name":"嵌入式硬件","slug":"嵌入式硬件","permalink":"https://mengfanjun020906.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://mengfanjun020906.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"机器学习","slug":"机器学习","permalink":"https://mengfanjun020906.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"pcb工艺","slug":"pcb工艺","permalink":"https://mengfanjun020906.github.io/tags/pcb%E5%B7%A5%E8%89%BA/"},{"name":"vscode","slug":"vscode","permalink":"https://mengfanjun020906.github.io/tags/vscode/"},{"name":"pip","slug":"pip","permalink":"https://mengfanjun020906.github.io/tags/pip/"},{"name":"sklearn","slug":"sklearn","permalink":"https://mengfanjun020906.github.io/tags/sklearn/"},{"name":"visual studio","slug":"visual-studio","permalink":"https://mengfanjun020906.github.io/tags/visual-studio/"}]}